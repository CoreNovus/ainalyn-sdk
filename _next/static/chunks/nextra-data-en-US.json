{"/":{"title":"Ainalyn Documentation","data":{"":"Welcome to the Ainalyn SDK documentation.\nRedirecting to documentation...If you are not redirected, click here."}},"/v1/advanced/architecture-overview":{"title":"Architecture & Code Guide","data":{"":"The Ainalyn SDK is built on Hexagonal Architecture (Ports & Adapters), ensuring clean separation of concerns, testability, and maintainability.\nNote: This section is for contributors who want to understand or modify the SDK's internal architecture. If you're using the SDK to build Agents, see the Concepts section instead.","core-principles#Core Principles":"Compiler, Not Runtime - The SDK creates Agent Definitions; execution belongs to the platform\nDependency Inversion - Core business logic depends on abstractions, not implementations\nClean Boundaries - Each component has a single, well-defined responsibility\nImmutability - Domain entities are immutable by design","architecture-diagram#Architecture Diagram":"┌─────────────────────┐\n                              │    CLI (cli.py)     │\n                              │   Inbound Adapter   │\n                              └──────────┬──────────┘\n                                         │\n    ┌──────────────────┐                 │                 ┌──────────────────┐\n    │  Python API      │                 │                 │  YAML Serializer │\n    │  (api.py)        │                 │                 │  Outbound Adapter│\n    │  Inbound Adapter │                 │                 └────────┬─────────┘\n    └────────┬─────────┘                 │                          │\n             │                           │                          │\n             │         ╔═════════════════╧══════════════════╗       │\n             │         ║                                    ║       │\n             └────────▶║       APPLICATION CORE             ║◀──────┘\n                       ║  ┌──────────────────────────────┐  ║\n    ┌──────────────┐   ║  │         Application          │  ║   ┌──────────────┐\n    │   Builders   │   ║  │  ┌────────────────────────┐  │  ║   │   Schema     │\n    │   (inbound/  │──▶║  │  │  Services & Use Cases  │  │  ║◀──│   Validator  │\n    │   builders/) │   ║  │  │  (Orchestration)       │  │  ║   │   (outbound/)│\n    └──────────────┘   ║  │  └───────────┬────────────┘  │  ║   └──────────────┘\n                       ║  │              │               │  ║\n                       ║  │    Ports     │    Ports      │  ║\n                       ║  │   (inbound)  │   (outbound)  │  ║\n                       ║  │              │               │  ║\n                       ║  │  ┌───────────▼────────────┐  │  ║   ┌──────────────┐\n                       ║  │  │        Domain          │  │  ║   │   Static     │\n                       ║  │  │  ┌──────────────────┐  │  │  ║◀──│   Analyzer   │\n                       ║  │  │  │ Entities, Rules  │  │  │  ║   │   (outbound/)│\n                       ║  │  │  │ (Business Logic) │  │  │  ║   └──────────────┘\n                       ║  │  │  └──────────────────┘  │  │  ║\n                       ║  │  └────────────────────────┘  │  ║\n                       ║  └──────────────────────────────┘  ║\n                       ║                                    ║\n                       ╚════════════════════════════════════╝\n                                         │\n                              ┌──────────┴──────────┐\n                              │    Infrastructure   │\n                              │  (service_factory)  │\n                              │    Wiring/DI        │\n                              └─────────────────────┘\nUnlike layered/onion architecture where layers wrap around each other, hexagonal architecture places the Application Core at the center with Ports defining boundaries and Adapters connecting to the outside world.","key-concepts#Key Concepts":"Concept\tDescription\tLocation\tApplication Core\tBusiness logic that never depends on external systems\tdomain/ + application/\tInbound Ports\tInterfaces for use cases (what the core offers)\tapplication/ports/inbound/\tOutbound Ports\tInterfaces for external capabilities the core needs\tapplication/ports/outbound/\tInbound Adapters\tEntry points that drive the application (CLI, API, Builders)\tadapters/inbound/, api.py, cli.py\tOutbound Adapters\tImplementations of external capabilities (validators, serializers)\tadapters/outbound/\tInfrastructure\tDependency injection and wiring\tinfrastructure/","dependency-rules#Dependency Rules":"Dependencies always point inward toward the Application Core:\n                         Inbound Adapters\n                    (api.py, cli.py, builders/)\n                                │\n                                │ calls\n                                ▼\n                    ┌───────────────────────┐\n                    │   Application Layer   │\n                    │   (services, use_cases)│\n                    │           │           │\n                    │     defines ports     │\n                    │           │           │\n                    └───────────┼───────────┘\n                                │\n        ┌───────────────────────┼───────────────────────┐\n        │                       │                       │\n        ▼                       ▼                       ▼\n   Outbound Ports          Domain Layer           Infrastructure\n   (interfaces)         (entities, rules)         (wiring/DI)\n        ▲                                              │\n        │                                              │\n        └──────────────────────────────────────────────┘\n                    implements ports with\n                     Outbound Adapters\n               (schema_validator, yaml_serializer)\nComponent\tCan Depend On\tCannot Depend On\tDomain\tNothing (pure Python)\tAny outer layer\tApplication (ports)\tDomain\tAdapters, Infrastructure\tApplication (services)\tDomain, Ports (interfaces)\tConcrete Adapters\tInbound Adapters\tApplication (via services), Domain\tOutbound Adapters\tOutbound Adapters\tDomain, implements Outbound Ports\tApplication internals\tInfrastructure\tEverything (for wiring)\t-","layer-details#Layer Details":"","domain-layer#Domain Layer":"Location: ainalyn/domain/Pure business logic with zero external dependencies.\n@dataclass(frozen=True)\nclass AgentDefinition:\n    \"\"\"Immutable domain entity.\"\"\"\n    name: str\n    version: str\n    workflows: tuple[Workflow, ...]\n    def __post_init__(self) -> None:\n        if not DefinitionRules.is_valid_name(self.name):\n            raise InvalidFormatError(f\"Invalid name: {self.name}\")\nDomain Errors:\nclass DefinitionError(Exception):\n    \"\"\"Base error for Agent Definition issues.\"\"\"\nclass InvalidFormatError(DefinitionError):\n    \"\"\"Field format validation error.\"\"\"\nclass CyclicDependencyError(DefinitionError):\n    \"\"\"Workflow contains cycles.\"\"\"","application-layer#Application Layer":"Location: ainalyn/application/Orchestrates domain logic via port interfaces.Ports - Define contracts:\nclass IDefinitionSchemaValidator(Protocol):\n    \"\"\"Port for schema validation capability.\"\"\"\n    def validate_schema(self, definition: AgentDefinition) -> tuple[ValidationError, ...]: ...\nServices - Orchestrate via dependency injection:\nclass DefinitionService:\n    def __init__(\n        self,\n        schema_validator: IDefinitionSchemaValidator,  # Port, not concrete\n        static_analyzer: IDefinitionAnalyzer,\n        serializer: IDefinitionSerializer,\n    ):\n        self._schema_validator = schema_validator\n        # ...","adapters-layer#Adapters Layer":"Location: ainalyn/adapters/Inbound - Entry points (Builders):\nclass AgentBuilder:\n    \"\"\"Fluent builder for Agent Definitions.\"\"\"\n    def version(self, version: str) -> AgentBuilder:\n        self._version = version\n        return self\n    def build(self) -> AgentDefinition:\n        return AgentDefinition(name=self._name, ...)\nOutbound - External capabilities:\nclass YamlSerializer:\n    \"\"\"Implements IDefinitionSerializer port.\"\"\"\n    def serialize(self, definition: AgentDefinition) -> str:\n        return yaml.dump(self._to_dict(definition))","infrastructure-layer#Infrastructure Layer":"Location: ainalyn/infrastructure/Wires concrete adapters to ports:\ndef create_default_service() -> DefinitionService:\n    return DefinitionService(\n        schema_validator=SchemaValidator(),  # Concrete adapter\n        static_analyzer=StaticAnalyzer(),\n        serializer=YamlSerializer(),\n    )","related-pages#Related Pages":"System Context - SDK's role in the overall system\nCompilation Flow - How data flows through the SDK","further-reading#Further Reading":"Hexagonal Architecture - Original concept by Alistair Cockburn\nCONTRIBUTING.md - Contribution guidelines"}},"/v1/advanced/compilation-flow":{"title":"Compilation Flow","data":{"":"This page explains how data flows through the SDK when compiling an Agent Definition.","overview#Overview":"The compilation process follows a clear pipeline:\n┌──────────────────────────────────────────────────────────────────────────────┐\n│                           SDK User (Developer)                                │\n└──────────────────────────────────┬───────────────────────────────────────────┘\n                                   │\n                                   ▼\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ 1. BUILD                                                                      │\n│    ┌────────────────┐                                                        │\n│    │  AgentBuilder  │  (Inbound Adapter)                                     │\n│    │  .version()    │                                                        │\n│    │  .add_workflow()                                                        │\n│    │  .build()      │────────────────────────────────────────────────────┐   │\n│    └────────────────┘                                                    │   │\n└──────────────────────────────────────────────────────────────────────────┼───┘\n                                                                           │\n                                   ▼                                       │\n┌──────────────────────────────────────────────────────────────────────────┼───┐\n│ 2. CREATE DOMAIN ENTITY                                                  │   │\n│    ┌────────────────────────────────────────────────────────────────┐    │   │\n│    │  AgentDefinition (Domain Entity)                               │◀───┘   │\n│    │  - Immutable (frozen dataclass)                                │        │\n│    │  - Self-validating via __post_init__                           │        │\n│    │  - Contains: workflows, prompts, tools, modules                │        │\n│    └────────────────────────────────────────────────────────────────┘        │\n└──────────────────────────────────┬───────────────────────────────────────────┘\n                                   │\n                                   ▼\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ 3. COMPILE via API                                                            │\n│    ┌────────────────┐      ┌───────────────────────────────────────────┐     │\n│    │ compile_agent()│─────▶│  DefinitionService (Application Service)  │     │\n│    │ (api.py)       │      │                                           │     │\n│    └────────────────┘      │  Orchestrates via Outbound Ports:         │     │\n│                            │  - IDefinitionSchemaValidator             │     │\n│                            │  - IDefinitionAnalyzer                    │     │\n│                            │  - IDefinitionSerializer                  │     │\n│                            └───────────────────┬───────────────────────┘     │\n└────────────────────────────────────────────────┼─────────────────────────────┘\n                                                 │\n            ┌────────────────────────────────────┼────────────────────────────┐\n            │                                    │                            │\n            ▼                                    ▼                            ▼\n┌───────────────────────┐         ┌───────────────────────┐    ┌─────────────────────┐\n│ 4a. VALIDATE          │         │ 4b. ANALYZE           │    │ 4c. SERIALIZE       │\n│ ┌───────────────────┐ │         │ ┌───────────────────┐ │    │ ┌─────────────────┐ │\n│ │ SchemaValidator   │ │         │ │ StaticAnalyzer    │ │    │ │ YamlExporter    │ │\n│ │ (Outbound Adapter)│ │         │ │ (Outbound Adapter)│ │    │ │ (Outbound       │ │\n│ └───────────────────┘ │         │ └───────────────────┘ │    │ │  Adapter)       │ │\n│ - Structure checks    │         │ - DAG validation      │    │ └─────────────────┘ │\n│ - Required fields     │         │ - Reference integrity │    │ - Domain → YAML     │\n│ - Type validation     │         │ - Unused detection    │    │ - Platform format   │\n└───────────────────────┘         └───────────────────────┘    └─────────────────────┘\n            │                                    │                            │\n            └────────────────────────────────────┼────────────────────────────┘\n                                                 │\n                                                 ▼\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ 5. OUTPUT                                                                     │\n│    ┌────────────────────────────────────────────────────────────────────┐    │\n│    │  CompilationResult                                                 │    │\n│    │  - validation_result: ValidationResult (errors, warnings)          │    │\n│    │  - yaml_content: str | None (only if valid)                        │    │\n│    │  - is_successful: bool                                             │    │\n│    └────────────────────────────────────────────────────────────────────┘    │\n│                                         │                                     │\n│                                         ▼                                     │\n│                              ┌─────────────────────┐                          │\n│                              │  agent.yaml file    │  ──▶  Submit to Platform │\n│                              └─────────────────────┘                          │\n└──────────────────────────────────────────────────────────────────────────────┘","step-by-step-breakdown#Step-by-Step Breakdown":"","step-1-build#Step 1: Build":"Developers use fluent builders to construct their agent:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My first agent\")\n    .add_workflow(\n        WorkflowBuilder(\"main\")\n        .add_node(NodeBuilder(\"start\").type(\"llm\").build())\n        .build()\n    )\n    .build()  # ← Returns AgentDefinition\n)\nWhat happens:\nAgentBuilder is an Inbound Adapter\nCollects configuration via fluent methods\n.build() creates an immutable AgentDefinition","step-2-create-domain-entity#Step 2: Create Domain Entity":"The builder creates an AgentDefinition domain entity:\n@dataclass(frozen=True)\nclass AgentDefinition:\n    name: str\n    version: str\n    description: str\n    workflows: tuple[Workflow, ...]\n    def __post_init__(self) -> None:\n        # Domain validation runs immediately\n        if not DefinitionRules.is_valid_name(self.name):\n            raise InvalidFormatError(...)\nWhat happens:\nEntity is created as frozen (immutable)\n__post_init__ runs domain validation\nInvalid entities cannot exist","step-3-compile-via-api#Step 3: Compile via API":"Developer calls the high-level API:\nfrom ainalyn import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nWhat happens:\ncompile_agent() is an Inbound Adapter (public API)\nGets DefinitionService from infrastructure\nDelegates to service for orchestration\nInternal flow:\n# api.py\ndef compile_agent(definition, output_path=None):\n    service = _get_service()  # From infrastructure\n    if output_path:\n        return service.compile_to_file(definition, output_path)\n    return service.compile(definition)","step-4a-schema-validation#Step 4a: Schema Validation":"SchemaValidator checks structural correctness:\nclass SchemaValidator:\n    \"\"\"Outbound Adapter implementing IDefinitionSchemaValidator\"\"\"\n    def validate_schema(self, definition: AgentDefinition) -> tuple[ValidationError, ...]:\n        errors = []\n        # Required fields\n        if not definition.workflows:\n            errors.append(ValidationError(\"E001\", \"At least one workflow required\"))\n        # Type validation\n        for workflow in definition.workflows:\n            if not workflow.nodes:\n                errors.append(ValidationError(\"E002\", f\"Workflow '{workflow.name}' has no nodes\"))\n        return tuple(errors)\nChecks performed:\nRequired fields present\nType correctness\nValue constraints\nStructural integrity","step-4b-static-analysis#Step 4b: Static Analysis":"StaticAnalyzer checks logical correctness:\nclass StaticAnalyzer:\n    \"\"\"Outbound Adapter implementing IDefinitionAnalyzer\"\"\"\n    def analyze(self, definition: AgentDefinition) -> tuple[AnalysisIssue, ...]:\n        issues = []\n        for workflow in definition.workflows:\n            # DAG validation\n            if self._has_cycles(workflow):\n                issues.append(AnalysisIssue(\"W001\", f\"Workflow '{workflow.name}' has cycles\"))\n            # Reference integrity\n            for edge in workflow.edges:\n                if not self._node_exists(workflow, edge.to):\n                    issues.append(AnalysisIssue(\"E010\", f\"Edge references unknown node '{edge.to}'\"))\n        return tuple(issues)\nChecks performed:\nWorkflow is a DAG (no cycles)\nAll references resolve\nNo orphan nodes\nNo unused definitions","step-4c-serialization#Step 4c: Serialization":"YamlExporter converts domain to YAML:\nclass YamlExporter:\n    \"\"\"Outbound Adapter implementing IDefinitionSerializer\"\"\"\n    def serialize(self, definition: AgentDefinition) -> str:\n        data = {\n            \"name\": definition.name,\n            \"version\": definition.version,\n            \"description\": definition.description,\n            \"workflows\": [\n                self._serialize_workflow(w) for w in definition.workflows\n            ],\n        }\n        return yaml.dump(data, sort_keys=False)\nWhat happens:\nDomain entities → Python dicts\nDicts → YAML string\nPlatform-compatible format","step-5-output#Step 5: Output":"CompilationResult contains the outcome:\n@dataclass\nclass CompilationResult:\n    validation_result: ValidationResult\n    yaml_content: str | None  # None if validation failed\n    output_path: Path | None  # Set if written to file\n    @property\n    def is_successful(self) -> bool:\n        return self.validation_result.is_valid\nUsage:\nresult = compile_agent(agent)\nif result.is_successful:\n    print(result.yaml_content)\n    # Submit to platform\nelse:\n    for error in result.validation_result.errors:\n        print(f\"{error.code}: {error.message}\")","validation-layers#Validation Layers":"The SDK has multiple validation layers, each with a specific responsibility:\nLayer\tLocation\tWhen\tPurpose\tDomain\tdomain/entities/\tEntity creation\tInvariants that must always hold\tSchema\tadapters/outbound/schema_validator.py\tCompilation\tStructural correctness\tStatic Analysis\tadapters/outbound/static_analyzer.py\tCompilation\tLogical correctness","domain-validation-example#Domain Validation Example":"# Cannot create invalid entity\nAgentDefinition(name=\"invalid name!\")  # Raises InvalidFormatError","schema-validation-example#Schema Validation Example":"# Valid entity, but missing required fields for platform\nagent = AgentBuilder(\"test\").build()  # Missing version\nresult = compile_agent(agent)\n# result.validation_result.errors contains \"version required\"","static-analysis-example#Static Analysis Example":"# Valid structure, but logical error\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"a\").build())\n    .add_node(NodeBuilder(\"b\").build())\n    .add_edge(\"a\", \"b\")\n    .add_edge(\"b\", \"a\")  # Creates cycle!\n    .build()\n)\nresult = compile_agent(agent)\n# result.validation_result.errors contains \"cycle detected\"","error-handling#Error Handling":"","error-categories#Error Categories":"Category\tCode Range\tExample\tDomain Errors\tExceptions\tInvalidFormatError, CyclicDependencyError\tSchema Errors\tE001-E099\tMissing required field\tAnalysis Errors\tE100-E199\tInvalid reference\tAnalysis Warnings\tW001-W099\tUnused definition","error-response#Error Response":"result = compile_agent(agent)\nif not result.is_successful:\n    for error in result.validation_result.errors:\n        print(f\"[{error.code}] {error.message}\")\n        print(f\"  Location: {error.location}\")\n        print(f\"  Suggestion: {error.suggestion}\")","related-pages#Related Pages":"Hexagonal Architecture - How components are organized\nSystem Context - SDK's role in the system\nValidation Guide - User-facing validation docs"}},"/v1/api-reference/api":{"title":"API Reference","data":{"":"The main API functions for validating and exporting agents.","validate#validate()":"Validates an agent definition.\nfrom ainalyn.api import validate\nresult = validate(agent)\nParameters:\ndefinition (AgentDefinition) - The agent to validate\nReturns:\nValidationResult - Contains validation errors and warnings\nresult.is_valid (bool) - True if no errors found\nresult.has_warnings (bool) - True if warnings found\nresult.errors (tuple[ValidationError, ...]) - All errors and warnings\nValidation Steps:\nSchema validation (structural correctness)\nStatic analysis (logical consistency, circular dependencies, unreachable nodes)\nExample:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate\nprompt = PromptBuilder(\"my-prompt\").description(\"Test prompt\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test workflow\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node 1\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\nresult = validate(agent)\nif result.is_valid:\n    print(\"Valid!\")\nelse:\n    for error in result.errors:\n        print(f\"{error.severity.value}: {error.code} - {error.message}\")","export_yaml#export_yaml()":"Exports an agent definition to YAML.\nfrom ainalyn.api import export_yaml\nyaml_output = export_yaml(agent)\nParameters:\ndefinition (AgentDefinition) - The agent to export\nReturns:\nstr - YAML-formatted string with header comments\nImportant:\nThis function does NOT validate before exporting\nFor a complete workflow with validation, use compile_agent() instead\nExample:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import export_yaml\nprompt = PromptBuilder(\"my-prompt\").description(\"Test\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\nyaml_str = export_yaml(agent)\nprint(yaml_str)","compile_agent#compile_agent()":"Validates and exports an agent definition (recommended workflow).\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nParameters:\ndefinition (AgentDefinition) - The agent to compile\noutput_path (Path | None) - Optional file path to save YAML. If None, returns YAML without writing.\nReturns:\nCompilationResult - Contains:\nvalidation_result (ValidationResult) - Validation results\nyaml_content (str | None) - YAML string if successful\noutput_path (Path | None) - File path if written\nis_successful (bool) - True if validation passed\nWorkflow:\nValidates the definition (schema + static analysis)\nExports to YAML (only if validation passes)\nWrites to file (if output_path provided)\nImportant: Local compilation does NOT equal platform execution. This creates a description for platform submission.Example:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Build agent\nprompt = PromptBuilder(\"my-prompt\").description(\"Test\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\n# Compile to file\nresult = compile_agent(agent, Path(\"output.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\nelse:\n    print(\"Validation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.code}: {error.message}\")"}},"/v1/api-reference/builders":{"title":"Builders API","data":{"":"Builders provide a fluent API for creating agent definitions.","agentbuilder#AgentBuilder":"Creates an agent definition.\nfrom ainalyn import AgentBuilder\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .description(\"What the agent does\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)\nMethods:\n.description(text) - Set agent description (required)\n.version(version) - Set semantic version like \"1.0.0\" (required)\n.add_workflow(workflow) - Add a workflow (at least one required)\n.workflows(*workflows) - Add multiple workflows at once\n.add_module(module) - Add a reusable module (optional)\n.modules(*modules) - Add multiple modules at once\n.add_prompt(prompt) - Add a prompt template (optional)\n.prompts(*prompts) - Add multiple prompts at once\n.add_tool(tool) - Add a tool definition (optional)\n.tools(*tools) - Add multiple tools at once\n.build() - Create the immutable AgentDefinition\nNaming Convention: Agent names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens (e.g., \"my-agent\", \"data-processor\")","workflowbuilder#WorkflowBuilder":"Creates a workflow.\nfrom ainalyn import WorkflowBuilder, NodeBuilder, PromptBuilder\nprompt = PromptBuilder(\"task-prompt\").description(\"Task prompt\").template(\"Do task\").build()\nworkflow = (\n    WorkflowBuilder(\"main-flow\")\n    .description(\"Main workflow\")\n    .add_node(\n        NodeBuilder(\"task1\")\n        .description(\"Complete task 1\")\n        .uses_prompt(\"task-prompt\")\n        .build()\n    )\n    .entry_node(\"task1\")\n    .build()\n)\nMethods:\n.description(text) - Set workflow description (required)\n.add_node(node) - Add a node to this workflow\n.nodes(*nodes) - Add multiple nodes at once\n.entry_node(name) - Set which node starts the workflow (required)\n.build() - Create the immutable Workflow\nNaming Convention: Workflow names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","nodebuilder#NodeBuilder":"Creates a node (workflow processing step).\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"my-task\")\n    .description(\"What this task accomplishes\")\n    .uses_prompt(\"my-prompt\")  # or uses_module() or uses_tool()\n    .inputs(\"input_data\")\n    .outputs(\"result_data\")\n    .next_nodes(\"next-task\")\n    .build()\n)\nMethods:\n.description(text) - Set the node description (required)\n.uses_module(name) - Set this node to use a module (choose one of uses_*)\n.uses_prompt(name) - Set this node to use a prompt (choose one of uses_*)\n.uses_tool(name) - Set this node to use a tool (choose one of uses_*)\n.inputs(*names) - Define input parameter names (optional)\n.outputs(*names) - Define output parameter names (optional)\n.next_nodes(*names) - Specify which nodes follow this one (optional)\n.build() - Create the immutable Node\nNode Types: Nodes must reference either a module, prompt, or tool. The type is automatically set based on which .uses_*() method you call.Naming Convention: Node names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","modulebuilder#ModuleBuilder":"Creates a reusable module.\nfrom ainalyn import ModuleBuilder\nmodule = (\n    ModuleBuilder(\"http-client\")\n    .description(\"HTTP request module\")\n    .input_schema({\"type\": \"object\", \"properties\": {...}})\n    .output_schema({\"type\": \"object\", \"properties\": {...}})\n    .build()\n)\nMethods:\n.description(text) - Set module description\n.input_schema(schema) - Define input JSON Schema\n.output_schema(schema) - Define output JSON Schema\n.build() - Create the Module","promptbuilder#PromptBuilder":"Creates an LLM prompt template.\nfrom ainalyn import PromptBuilder\nprompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a greeting message\")\n    .template(\"Hello {{name}}! Welcome to {{location}}.\")\n    .variables(\"name\", \"location\")\n    .build()\n)\nMethods:\n.description(text) - Set prompt description (required)\n.template(text) - Set prompt template with {{variable}} placeholders (required)\n.variables(*names) - List variable names used in template (optional)\n.build() - Create the immutable Prompt\nTemplate Syntax: Use double curly braces {{variable}} for placeholders in the template.Naming Convention: Prompt names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","toolbuilder#ToolBuilder":"Creates a tool definition.\nfrom ainalyn import ToolBuilder\ntool = (\n    ToolBuilder(\"calculator-tool\")\n    .description(\"Performs mathematical calculations\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"expression\": {\"type\": \"string\"}\n        },\n        \"required\": [\"expression\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"result\": {\"type\": \"number\"}\n        }\n    })\n    .build()\n)\nMethods:\n.description(text) - Set tool description (required)\n.input_schema(schema) - Define input JSON Schema (optional)\n.output_schema(schema) - Define output JSON Schema (optional)\n.build() - Create the immutable Tool\nNaming Convention: Tool names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","common-patterns#Common Patterns":"Always call .build()\n# Correct\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\").build()\n# Wrong - missing .build()\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\")\nChain methods\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_workflow(workflow)\n    .build()\n)\nSequential workflow with next_nodes\nprompt1 = PromptBuilder(\"prompt1\").description(\"First\").template(\"Step 1\").build()\nprompt2 = PromptBuilder(\"prompt2\").description(\"Second\").template(\"Step 2\").build()\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Sequential processing\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First step\")\n        .uses_prompt(\"prompt1\")\n        .next_nodes(\"step2\")  # Points to next step\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second step\")\n        .uses_prompt(\"prompt2\")\n        .build()\n    )\n    .entry_node(\"step1\")  # Start at step1\n    .build()\n)\nBranching workflow\n# Node that splits into multiple paths\nworkflow = (\n    WorkflowBuilder(\"branching\")\n    .description(\"Branching workflow\")\n    .add_node(\n        NodeBuilder(\"analyze\")\n        .description(\"Analyze input\")\n        .uses_module(\"analyzer\")\n        .next_nodes(\"path-a\", \"path-b\")  # Multiple next nodes\n        .build()\n    )\n    .add_node(NodeBuilder(\"path-a\").description(\"Path A\").uses_prompt(\"prompt-a\").build())\n    .add_node(NodeBuilder(\"path-b\").description(\"Path B\").uses_prompt(\"prompt-b\").build())\n    .entry_node(\"analyze\")\n    .build()\n)"}},"/v1/api-reference/cli":{"title":"Command Line Interface","data":{"":"The ainalyn CLI provides commands for validating and compiling agents.","installation#Installation":"The CLI is installed automatically with the SDK:\npip install ainalyn-sdk","commands#Commands":"","validate#validate":"Validates an agent definition file.\nainalyn validate agent.py\nArguments:\nfile - Path to Python file containing an AgentDefinition\nExample:\n# agent.py\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nprompt = PromptBuilder(\"my-prompt\").description(\"Test\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\n$ ainalyn validate agent.py\nValidation successful","compile#compile":"Compiles an agent definition to YAML.\nainalyn compile agent.py -o output.yaml\nArguments:\nfile - Path to Python file\n-o, --output - Output YAML file path (required)\nExample:\n$ ainalyn compile agent.py -o my_agent.yaml\nCompiled successfully to my_agent.yaml","--version#--version":"Shows the SDK version.\nainalyn --version","exit-codes#Exit Codes":"0 - Success\n1 - Validation or compilation failed\n2 - File not found or invalid","common-workflows#Common Workflows":"Validate before deploying:\nainalyn validate agent.py && echo \"Ready to deploy!\"\nCompile multiple agents:\nainalyn compile agent1.py -o agent1.yaml\nainalyn compile agent2.py -o agent2.yaml"}},"/v1/api-reference/entities":{"title":"Entities","data":{"":"Core domain entities represent the structure of agent definitions.","agentdefinition#AgentDefinition":"The complete agent specification.Attributes:\nname (str) - Unique agent identifier (lowercase, hyphens only)\nversion (str) - Version string (e.g., \"1.0.0\")\ndescription (str) - What the agent does\nworkflows (tuple) - List of workflows (required, at least one)\nmodules (tuple) - Reusable modules (optional)\nprompts (tuple) - LLM prompt templates (optional)\ntools (tuple) - External tool definitions (optional)\nExample:\nfrom ainalyn.domain.entities import AgentDefinition\nagent = AgentDefinition(\n    name=\"my-agent\",\n    version=\"1.0.0\",\n    description=\"Does something useful\",\n    workflows=(workflow,),\n    modules=(),\n    prompts=(),\n    tools=()\n)\nNote: Usually created via AgentBuilder, not directly.","workflow#Workflow":"A task execution flow.Attributes:\nname (str) - Workflow identifier\ndescription (str) - What this workflow does (optional)\nentry_node (str) - Which node starts the workflow\nnodes (tuple) - List of nodes in this workflow\nExample:\nfrom ainalyn.domain.entities import Workflow\nworkflow = Workflow(\n    name=\"main\",\n    description=\"Main workflow\",\n    entry_node=\"start\",\n    nodes=(node1, node2)\n)","node#Node":"A single task unit within a workflow.Attributes:\nname (str) - Node identifier\ngoal (str) - What this node should accomplish\ndescription (str) - Additional details (optional)\nnode_type (NodeType) - Type: TASK, MODULE, or SUBWORKFLOW\noutputs (tuple) - Output variable names (optional)\ndependencies (tuple) - Names of nodes this depends on (optional)\nreference (str) - Reference to module/workflow (optional)\nExample:\nfrom ainalyn.domain.entities import Node, NodeType\nnode = Node(\n    name=\"process-data\",\n    goal=\"Process the input data\",\n    description=\"Cleans and validates data\",\n    node_type=NodeType.TASK,\n    outputs=(\"cleaned_data\",),\n    dependencies=(\"load-data\",),\n    reference=None\n)","nodetype#NodeType":"Enum for node types.Values:\nNodeType.TASK - A task node\nNodeType.MODULE - References a module\nNodeType.SUBWORKFLOW - References another workflow\nExample:\nfrom ainalyn.domain.entities import NodeType\n# Use in node creation\nnode_type = NodeType.TASK","module#Module":"A reusable capability unit.Attributes:\nname (str) - Module identifier\ndescription (str) - What this module does\ninput_schema (dict) - JSON Schema for inputs (optional)\noutput_schema (dict) - JSON Schema for outputs (optional)\nExample:\nfrom ainalyn.domain.entities import Module\nmodule = Module(\n    name=\"http-client\",\n    description=\"Makes HTTP requests\",\n    input_schema={\"type\": \"object\", \"properties\": {\"url\": {\"type\": \"string\"}}},\n    output_schema={\"type\": \"object\", \"properties\": {\"body\": {\"type\": \"string\"}}}\n)","prompt#Prompt":"An LLM prompt template.Attributes:\nname (str) - Prompt identifier\ntemplate (str) - Prompt text with placeholders\nExample:\nfrom ainalyn.domain.entities import Prompt\nprompt = Prompt(\n    name=\"greeting\",\n    template=\"Hello {name}, welcome to {place}!\"\n)","tool#Tool":"An external tool definition.Attributes:\nname (str) - Tool identifier\ndescription (str) - What this tool does\nExample:\nfrom ainalyn.domain.entities import Tool\ntool = Tool(\n    name=\"calculator\",\n    description=\"Performs mathematical operations\"\n)","immutability#Immutability":"All entities are frozen dataclasses - they cannot be modified after creation.\n# Create new entity\nagent = AgentDefinition(name=\"my-agent\", ...)\n# Cannot modify\nagent.name = \"new-name\"  # Error!\n# Create new version instead\nagent_v2 = AgentDefinition(name=\"new-name\", ...)","creating-entities#Creating Entities":"Direct creation (advanced):\nfrom ainalyn.domain.entities import AgentDefinition, Workflow, Node\nagent = AgentDefinition(...)\nUsing builders (recommended):\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_workflow(...)\n    .build()\n)\nBuilders are easier and include validation."}},"/v1/concepts/building-your-agent":{"title":"Building Your Agent","data":{"":"An Agent Definition is your blueprint for solving a specific problem. This guide shows you how to think about and structure your Agent for success.","the-core-structure#The Core Structure":"Every Agent has three essential parts:\nagent = (\n    AgentBuilder(\"YourAgent\")\n    .description(\"What it does\")     # 1. Identity\n    .version(\"1.0.0\")\n    .add_workflow(your_workflow)     # 2. Logic\n    .build()                         # 3. Validation\n)\nLet's break down each part:","1-identity-what-your-agent-is#1. Identity: What Your Agent Is":"AgentBuilder(\"EmailExtractor\")\n    .description(\"Extract email addresses from documents\")\n    .version(\"1.0.0\")\nThink about:\nWhat problem does this solve?\nHow would you explain it in one sentence?\nWhat version of the solution is this?\nGood names:\nClear: \"InvoiceProcessor\", \"EmailExtractor\"\nSpecific: \"PDFTableExtractor\" not \"DataProcessor\"\nMemorable: Users will search for these\nGood descriptions:\nOne clear sentence\nFocus on the outcome\nAvoid technical jargon","2-logic-how-your-agent-works#2. Logic: How Your Agent Works":".add_workflow(extraction_workflow)\nWorkflows define the steps your Agent takes:\nworkflow = (\n    WorkflowBuilder(\"extract_emails\")\n    .description(\"Find and validate email addresses\")\n    .add_node(parse_node)\n    .add_node(extract_node)\n    .add_node(validate_node)\n    .entry_node(\"parse\")\n    .build()\n)\nThink about:\nWhat steps are needed?\nWhat's the logical flow?\nHow do steps connect?","3-validation-making-sure-its-right#3. Validation: Making Sure It's Right":".build()  # ← This validates your definition\nThe SDK checks:\n✅ All required fields present\n✅ Names are valid\n✅ Workflows are connected properly\n✅ No circular dependencies","workflows-your-agents-brain#Workflows: Your Agent's Brain":"Workflows are where your Agent's logic lives.","simple-linear-workflow#Simple Linear Workflow":"workflow = (\n    WorkflowBuilder(\"process_data\")\n    .description(\"Process user input step by step\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"Load and validate input\")\n        .outputs(\"validated_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Process the data\")\n        .depends_on(\"step1\")\n        .outputs(\"result\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)\nFlow:\nstep1 (load and validate)\n  ↓\nstep2 (process)\n  ↓\nresult","parallel-processing-workflow#Parallel Processing Workflow":"workflow = (\n    WorkflowBuilder(\"analyze_document\")\n    .description(\"Extract multiple types of data in parallel\")\n    .add_node(\n        NodeBuilder(\"load\")\n        .description(\"Load document\")\n        .outputs(\"document\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"extract_text\")\n        .description(\"Extract text content\")\n        .depends_on(\"load\")\n        .outputs(\"text\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"extract_images\")\n        .description(\"Extract images\")\n        .depends_on(\"load\")\n        .outputs(\"images\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"combine\")\n        .description(\"Combine results\")\n        .depends_on(\"extract_text\", \"extract_images\")\n        .outputs(\"final_result\")\n        .build()\n    )\n    .entry_node(\"load\")\n    .build()\n)\nFlow:\n         load\n          ↓\n    ┌─────┴─────┐\n    ↓           ↓\nextract_text  extract_images\n    └─────┬─────┘\n          ↓\n       combine","conditional-workflow#Conditional Workflow":"workflow = (\n    WorkflowBuilder(\"smart_processor\")\n    .description(\"Process based on input type\")\n    .add_node(\n        NodeBuilder(\"detect_type\")\n        .description(\"Determine input type\")\n        .outputs(\"input_type\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process_pdf\")\n        .description(\"Handle PDF inputs\")\n        .depends_on(\"detect_type\")\n        .outputs(\"result\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process_image\")\n        .description(\"Handle image inputs\")\n        .depends_on(\"detect_type\")\n        .outputs(\"result\")\n        .build()\n    )\n    .entry_node(\"detect_type\")\n    .build()\n)\nThe platform routes to the appropriate node based on your logic.","nodes-individual-steps#Nodes: Individual Steps":"Each node represents one focused task:\nnode = (\n    NodeBuilder(\"extract_emails\")\n    .description(\"Find all email addresses in text\")\n    .depends_on(\"parse_text\")       # What comes before\n    .outputs(\"email_list\")           # What this produces\n    .build()\n)","node-design-principles#Node Design Principles":"1. Single Responsibility\n# Good: Each node does one thing\nparse_node = NodeBuilder(\"parse\").description(\"Parse document\").build()\nextract_node = NodeBuilder(\"extract\").description(\"Extract emails\").build()\n# Bad: Node does too much\nprocess_node = NodeBuilder(\"process\").description(\"Parse and extract\").build()\n2. Clear Dependencies\n# Good: Explicit dependencies\nNodeBuilder(\"step2\").depends_on(\"step1\").build()\n# Bad: Unclear flow\nNodeBuilder(\"process\").build()  # What runs before this?\n3. Meaningful Outputs\n# Good: Clear output names\n.outputs(\"validated_emails\", \"confidence_scores\")\n# Bad: Generic names\n.outputs(\"result\", \"data\")","prompts-guiding-llms#Prompts: Guiding LLMs":"If your Agent uses LLMs, define prompts:\nprompt = (\n    PromptBuilder(\"analyze_sentiment\")\n    .description(\"Analyze text sentiment\")\n    .template(\"\"\"\n        Analyze the sentiment of the following text:\n        {text}\n        Provide a sentiment score from -1 (negative) to 1 (positive).\n    \"\"\")\n    .variables(\"text\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"SentimentAnalyzer\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\nPrompt tips:\nBe specific about what you want\nProvide clear output format instructions\nUse variables for dynamic content\nTest with edge cases","tools-external-capabilities#Tools: External Capabilities":"Declare external services your Agent needs:\nweather_tool = (\n    ToolBuilder(\"weather_api\")\n    .description(\"Fetch current weather data\")\n    .add_parameter(\"location\")\n    .add_parameter(\"units\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"WeatherAgent\")\n    .add_tool(weather_tool)\n    .add_workflow(workflow)\n    .build()\n)\nThe platform handles the actual API integration.","modules-reusable-capabilities#Modules: Reusable Capabilities":"Share functionality across workflows:\n# Define reusable module\ndata_validator = (\n    ModuleBuilder(\"DataValidator\")\n    .description(\"Common validation utilities\")\n    .add_capability(\"validate_email\")\n    .add_capability(\"validate_phone\")\n    .add_capability(\"validate_url\")\n    .build()\n)\n# Use in multiple agents\nagent1 = AgentBuilder(\"EmailProcessor\").add_module(data_validator).build()\nagent2 = AgentBuilder(\"ContactManager\").add_module(data_validator).build()","complete-example-invoice-processor#Complete Example: Invoice Processor":"Let's build a real Agent from scratch:\nfrom ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    PromptBuilder,\n    ToolBuilder,\n)\n# Define tools\nocr_tool = (\n    ToolBuilder(\"ocr_service\")\n    .description(\"Extract text from images\")\n    .add_parameter(\"image_data\")\n    .build()\n)\n# Define prompts\nextraction_prompt = (\n    PromptBuilder(\"extract_invoice_data\")\n    .description(\"Extract structured data from invoice text\")\n    .template(\"\"\"\n        Extract the following fields from this invoice:\n        {invoice_text}\n        Fields to extract:\n        - Invoice number\n        - Date\n        - Vendor name\n        - Total amount\n        - Line items\n        Return as JSON.\n    \"\"\")\n    .variables(\"invoice_text\")\n    .build()\n)\n# Define workflow\nprocessing_workflow = (\n    WorkflowBuilder(\"process_invoice\")\n    .description(\"Extract and structure invoice data\")\n    .add_node(\n        NodeBuilder(\"load_image\")\n        .description(\"Load invoice image\")\n        .outputs(\"image_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"extract_text\")\n        .description(\"OCR the invoice\")\n        .depends_on(\"load_image\")\n        .uses_tool(\"ocr_service\")\n        .outputs(\"invoice_text\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"parse_data\")\n        .description(\"Extract structured fields\")\n        .depends_on(\"extract_text\")\n        .uses_prompt(\"extract_invoice_data\")\n        .outputs(\"structured_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"validate\")\n        .description(\"Validate extracted data\")\n        .depends_on(\"parse_data\")\n        .outputs(\"validated_data\")\n        .build()\n    )\n    .entry_node(\"load_image\")\n    .build()\n)\n# Build the Agent\ninvoice_processor = (\n    AgentBuilder(\"InvoiceProcessor\")\n    .description(\"Extract structured data from invoice images\")\n    .version(\"1.0.0\")\n    .add_tool(ocr_tool)\n    .add_prompt(extraction_prompt)\n    .add_workflow(processing_workflow)\n    .build()\n)\n# Validate\nfrom ainalyn.api import validate\nvalidate(invoice_processor)\n# Export\nfrom ainalyn.api import export_yaml\nyaml_output = export_yaml(invoice_processor)","design-guidelines#Design Guidelines":"","start-simple#Start Simple":"Your first version doesn't need to be perfect:\n# Version 1.0.0: Basic extraction\nagent = (\n    AgentBuilder(\"EmailExtractor\")\n    .version(\"1.0.0\")\n    .add_workflow(basic_workflow)\n    .build()\n)\n# Version 1.1.0: Add validation\nagent = (\n    AgentBuilder(\"EmailExtractor\")\n    .version(\"1.1.0\")\n    .add_workflow(enhanced_workflow)\n    .build()\n)\nShip early, iterate based on feedback.","think-about-edge-cases#Think About Edge Cases":"workflow = (\n    WorkflowBuilder(\"process\")\n    .add_node(\n        NodeBuilder(\"validate_input\")\n        .description(\"Check input is valid\")  # ← Handle bad inputs\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process validated input\")\n        .depends_on(\"validate_input\")\n        .build()\n    )\n    .build()\n)\nGood Agents handle edge cases gracefully.","design-for-users#Design for Users":"# Good: Clear output\n.outputs(\"extracted_emails\", \"confidence_scores\", \"invalid_addresses\")\n# Bad: Unclear output\n.outputs(\"result\")\nUsers should understand what they get.","keep-workflows-focused#Keep Workflows Focused":"# Good: One workflow, one purpose\nworkflow = WorkflowBuilder(\"extract_emails\").build()\n# Consider splitting if it does too much\nworkflow = WorkflowBuilder(\"extract_and_validate_and_categorize\").build()\nFocused workflows are easier to debug and maintain.","validation-and-testing#Validation and Testing":"","always-validate#Always Validate":"from ainalyn.api import validate\ntry:\n    validate(agent)\n    print(\"✓ Agent definition is valid\")\nexcept ValidationError as e:\n    print(f\"✗ Validation failed: {e}\")\nValidation catches:\nMissing required fields\nInvalid names\nCircular dependencies\nBroken references","review-generated-yaml#Review Generated YAML":"yaml = export_yaml(agent)\nprint(yaml)\nThe YAML is what the platform sees. Make sure it matches your intent.","iterate-based-on-feedback#Iterate Based on Feedback":"Once deployed:\nMonitor usage patterns\nRead user feedback\nFix edge cases\nRelease improved versions","versioning-your-agent#Versioning Your Agent":"Use semantic versioning:\n# Initial release\n.version(\"1.0.0\")\n# Bug fix (backwards compatible)\n.version(\"1.0.1\")\n# New feature (backwards compatible)\n.version(\"1.1.0\")\n# Breaking change\n.version(\"2.0.0\")\nThe platform helps users migrate between versions.","common-patterns#Common Patterns":"","input-validation-pattern#Input Validation Pattern":"workflow = (\n    WorkflowBuilder(\"safe_processing\")\n    .add_node(\n        NodeBuilder(\"validate\")\n        .description(\"Validate input meets requirements\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process validated input\")\n        .depends_on(\"validate\")\n        .build()\n    )\n    .entry_node(\"validate\")\n    .build()\n)","error-handling-pattern#Error Handling Pattern":"workflow = (\n    WorkflowBuilder(\"robust_processing\")\n    .add_node(\n        NodeBuilder(\"try_process\")\n        .description(\"Attempt processing\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"handle_error\")\n        .description(\"Provide helpful error message\")\n        .depends_on(\"try_process\")\n        .build()\n    )\n    .build()\n)","multi-stage-processing-pattern#Multi-Stage Processing Pattern":"workflow = (\n    WorkflowBuilder(\"multi_stage\")\n    .add_node(NodeBuilder(\"stage1\").description(\"Initial processing\").build())\n    .add_node(NodeBuilder(\"stage2\").depends_on(\"stage1\").build())\n    .add_node(NodeBuilder(\"stage3\").depends_on(\"stage2\").build())\n    .entry_node(\"stage1\")\n    .build()\n)","best-practices-summary#Best Practices Summary":"Agent Design Checklist:\n✅ Clear, specific name\n✅ One-sentence description\n✅ Semantic version\n✅ Focused workflows\n✅ Single-responsibility nodes\n✅ Clear dependencies\n✅ Meaningful output names\n✅ Edge case handling\n✅ Validated definition\n✅ Reviewed YAML output","next-steps#Next Steps":"Now that you understand Agent structure:\nBuild Your First Agent - Hands-on tutorial\nWorkflow Guide - Advanced workflow patterns\nAPI Reference - Complete builder documentation\nRemember: Your Agent definition is a blueprint, not executable code.Focus on describing the solution clearly.The platform handles executing it reliably.That's how great Agents are built."}},"/v1/concepts/what-is-an-agent":{"title":"What is an Agent?","data":{"":"Agents are the heart of Ainalyn. When you build an Agent, you're creating something powerful: a task that anyone can use, from anywhere, without leaving their workflow.","the-big-idea#The Big Idea":"Imagine if every useful task you've ever automated could be:\nUsed by millions of people\nAccessible from a single, unified interface\nAutomatically handled for infrastructure, billing, and security\nMonetized fairly based on actual usage\nThat's what Agents are.\nAn Agent is a complete, self-contained solution to a specific task that users can invoke with a single request and get results—without ever thinking about how it works.","why-this-matters#Why This Matters":"","the-problem-with-traditional-software#The Problem with Traditional Software":"When you build traditional software, you spend time on:\n10% - The actual problem you're solving\n90% - Everything else (auth, hosting, UI, billing, deployment, maintenance...)\nAnd your users have to:\nCreate yet another account\nLearn yet another interface\nSwitch between yet another app\nManage yet another subscription\nEveryone loses time. Everyone loses focus.","the-agent-solution#The Agent Solution":"With Agents, you focus on what you do best:\n95% - Solving the actual problem\n5%  - Integrating with Ainalyn SDK\nAnd your users get:\nOne Client for all tasks\nZero context switching\nPay-per-use pricing\nInstant access to your solution\nEveryone wins.","what-makes-agents-special#What Makes Agents Special":"","1-task-focused-not-screen-focused#1. Task-Focused, Not Screen-Focused":"Traditional apps are about screens and navigation:\nLogin → Dashboard → Settings → Features → Sub-menus → Finally do the thing\nAgents are about accomplishing goals:\n\"I need to extract emails from this PDF\" → Done\nNo navigation. No learning curve. Just results.","2-one-client-infinite-capabilities#2. One Client, Infinite Capabilities":"Users don't install your Agent. They don't visit your website. They don't create an account.They simply:\nOpen the Ainalyn Client (which they already have)\nFind your Agent\nUse it\nGet results\nYour Agent becomes part of their workflow, not a distraction from it.","3-you-build-the-logic-platform-handles-the-rest#3. You Build the Logic, Platform Handles the Rest":"When you define an Agent:You focus on:\nWhat inputs are needed\nWhat processing should happen\nWhat outputs to provide\nWhat makes your solution unique\nThe platform handles:\nUser authentication\nExecution infrastructure\nBilling and payments\nScaling and reliability\nSecurity and compliance","real-examples#Real Examples":"Let's see what Agents look like in practice:","example-1-pdf-data-extractor#Example 1: PDF Data Extractor":"Traditional approach:\nBuild a web app with login\nCreate file upload UI\nSet up payment processing\nDeploy and maintain servers\nMarket to get users to find you\nAgent approach:\nagent = (\n    AgentBuilder(\"PDFDataExtractor\")\n    .description(\"Extract structured data from any PDF\")\n    .add_workflow(extraction_workflow)\n    .build()\n)\nDone. Users find it in the Ainalyn marketplace and use it instantly.","example-2-email-report-generator#Example 2: Email Report Generator":"Traditional approach:\nBuild email integration\nCreate dashboard for viewing reports\nHandle user data storage\nManage scheduled jobs\nAgent approach:\nagent = (\n    AgentBuilder(\"EmailReportGenerator\")\n    .description(\"Generate weekly email activity reports\")\n    .add_workflow(report_workflow)\n    .build()\n)\nThat's it. The platform handles scheduling, storage, and delivery.","the-developer-experience-you-deserve#The Developer Experience You Deserve":"","write-in-python-deploy-anywhere#Write in Python, Deploy Anywhere":"from ainalyn import AgentBuilder, WorkflowBuilder\n# Define your Agent\nagent = (\n    AgentBuilder(\"MyAwesomeAgent\")\n    .description(\"Solves a real problem for real people\")\n    .version(\"1.0.0\")\n    .add_workflow(my_workflow)\n    .build()\n)\n# Validate it works\nvalidate(agent)\n# Export and deploy\nyaml = export_yaml(agent)\nClean. Simple. Focused.","type-safe-development#Type-Safe Development":"Your IDE knows exactly what you're building:\nbuilder: AgentBuilder = AgentBuilder(\"MyAgent\")\n# ↑ Full autocomplete and type checking\nCatch errors before they happen, not in production.","instant-validation#Instant Validation":"from ainalyn.api import validate\nvalidate(agent)  # Immediate feedback on any issues\nNo surprises during deployment.","the-vision-a-unified-task-platform#The Vision: A Unified Task Platform":"","for-users#For Users":"Imagine opening one app and being able to:\nExtract data from PDFs\nGenerate reports from emails\nAnalyze customer feedback\nProcess invoices\nSummarize documents\nAnd anything else they need\nNo app switching. No account juggling. One workflow.That's what Ainalyn is building.","for-developers#For Developers":"Imagine solving one problem really well and having:\nMillions of potential users\nZero infrastructure management\nFair, automatic revenue sharing\nA community of peers solving adjacent problems\nNo distraction. No overhead. Pure problem-solving.That's what building Agents enables.","what-agents-are-not#What Agents Are NOT":"Let's be clear about what you're NOT building:\nAgents Are NOT:\nChatbots for open-ended conversation\nLong-running background services\nPlatforms or frameworks themselves\nAutonomous AI that acts independently\nReplacements for every type of software\nAgents are focused task solvers that complete specific jobs when users need them.","not-a-chat-interface#Not a Chat Interface":"While your Agent might use LLMs internally, it's not designed for:\nUser: \"Hey, how's it going?\"\nAgent: \"I'm doing well! How can I help?\"\nUser: \"What can you do?\"\nIt's designed for:\nUser: [Uploads PDF] \"Extract the invoices\"\nAgent: [Returns structured data]\nInput → Processing → Output → Done.","not-autonomous-systems#Not Autonomous Systems":"Agents don't:\nRun continuously in the background\nMake decisions without user input\nAct on their own initiative\nMaintain state across invocations\nThey execute tasks on demand, then complete.","not-everything#Not Everything":"Some things still need traditional apps:\nComplex multi-screen workflows\nReal-time collaborative editing\nPersistent state management\nGaming and entertainment\nAgents excel at discrete, goal-oriented tasks.","the-community-were-building#The Community We're Building":"","developers-helping-users#Developers Helping Users":"Every Agent you build makes the platform more valuable:\nYou solve one problem brilliantly\nUsers get access to that solution instantly\nOther developers build complementary Agents\nThe ecosystem grows stronger\nYour contribution matters.","quality-through-specialization#Quality Through Specialization":"Because you're only responsible for task logic:✅ You can perfect edge cases\n✅ You can optimize performance\n✅ You can iterate based on feedback\n✅ You can maintain focus on qualityInstead of spreading thin across infrastructure concerns.","fair-value-exchange#Fair Value Exchange":"You build → Users use → You earn\nNo ads. No dark patterns. No growth hacking.\nJust fair compensation for valuable work.","how-users-experience-your-agent#How Users Experience Your Agent":"Understanding the user journey helps you design better Agents:","discovery#Discovery":"User searches for \"PDF extraction\" in the Ainalyn marketplace:\nSees your Agent name and description\nReads ratings and reviews\nChecks pricing estimate\nDecides to try it\nYour job: Make the value proposition crystal clear.","execution-request#Execution Request":"User clicks \"Use This Agent\":\nProvides their PDF file\nReviews what the Agent will do\nConfirms the request\nYour job: Design intuitive, minimal input requirements.","results#Results":"User receives results in seconds or minutes:\nDownloads extracted data\nSees exactly what they were charged\nContinues with their work\nRates their experience\nYour job: Deliver accurate, useful results consistently.","the-agent-lifecycle-your-perspective#The Agent Lifecycle (Your Perspective)":"","1-define#1. Define":"You describe what your Agent does:\nagent = (\n    AgentBuilder(\"InvoiceProcessor\")\n    .description(\"Extract line items from invoice PDFs\")\n    .version(\"1.0.0\")\n    .add_workflow(processing_workflow)\n    .build()\n)","2-validate#2. Validate":"You ensure it meets platform requirements:\nfrom ainalyn.api import validate\nvalidate(agent)  # Catches issues early","3-deploy#3. Deploy":"You export and submit to the platform:\nyaml = export_yaml(agent)\n# Upload to Ainalyn platform","4-iterate#4. Iterate":"Users use it, you improve it:\nMonitor usage patterns\nRead feedback\nFix edge cases\nRelease new versions\nThe platform handles backwards compatibility.","getting-started#Getting Started":"Ready to build your first Agent?","step-1-identify-a-clear-task#Step 1: Identify a Clear Task":"Ask yourself:\nWhat specific problem am I solving?\nCan it be completed in one request?\nWill users get verifiable results?\nGood task: \"Extract all email addresses from a document\"\nBad task: \"Help users with various text processing needs\"","step-2-design-for-simplicity#Step 2: Design for Simplicity":"Think from the user's perspective:\nWhat's the minimum input needed?\nWhat's the clearest output format?\nHow can I make this dead simple?\nRemember: Users should be able to use your Agent without reading documentation.","step-3-build-with-the-sdk#Step 3: Build with the SDK":"from ainalyn import AgentBuilder\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .description(\"One clear sentence about what it does\")\n    .version(\"1.0.0\")\n    # ... add your workflows\n    .build()\n)","step-4-test-thoroughly#Step 4: Test Thoroughly":"Validate your Agent catches edge cases:\nEmpty inputs\nMalformed data\nUnexpected formats\nLarge files\nQuality matters. Your reputation is on the line.","step-5-deploy-and-learn#Step 5: Deploy and Learn":"Ship your Agent to the platform, then:\nMonitor how users interact with it\nRead reviews and feedback\nIterate to improve\nBuild trust over time","why-youll-love-building-agents#Why You'll Love Building Agents":"","focus-on-what-matters#Focus on What Matters":"No more:\nDebugging authentication flows\nScaling database clusters\nWriting payment integration code\nDesigning responsive UIs\nManaging cloud infrastructure\nJust solve the problem.","reach-millions#Reach Millions":"Your solution becomes instantly accessible to every Ainalyn user.No marketing campaigns. No user acquisition costs. No growth hacking.Just good work that people find and use.","fair-compensation#Fair Compensation":"Get paid based on the value you provide:\nUsers pay per use\nYou earn per execution\nPlatform takes a fair cut for infrastructure\nEveryone's incentives align\nNo ads. No subscriptions. No gimmicks.","join-a-community#Join a Community":"Connect with developers who:\nShare your values\nSolve complementary problems\nRespect focused, quality work\nBuild for users, not metrics\nA community of makers, not growth hackers.","the-bigger-picture#The Bigger Picture":"","one-agent-at-a-time#One Agent at a Time":"You don't need to build a platform. You don't need to change the world.You just need to solve one problem really well.That's enough. That's valuable. That's what Agents are for.","together-we-build-the-future#Together, We Build the Future":"When thousands of developers each solve one problem brilliantly:\nUsers get a unified experience for any task\nDevelopers earn fair compensation for good work\nThe ecosystem grows organically\nEveryone benefits from specialization\nThat's the Ainalyn vision.","next-steps#Next Steps":"Ready to build?\nStart Here:\nInstall the SDK - Get set up in 60 seconds\nBuild Your First Agent - Step-by-step tutorial\nJoin the Community - Connect with other developers\nWelcome to Ainalyn. Let's build something great.\nRemember: You're not building infrastructure. You're not managing users. You're not scaling servers.You're solving problems. And that's exactly where your talent should be spent."}},"/v1/concepts/what-you-control":{"title":"What You Control (And What You Don't Have To)","data":{"":"Building traditional software means managing everything. Building Agents means focusing on what matters.This document clarifies what you're responsible for—and celebrates everything you're not responsible for.","the-great-news-first#The Great News First":"You DON'T Have To:\nBuild authentication systems\nManage user accounts\nHandle payment processing\nScale infrastructure\nMonitor servers\nDeal with security patches\nWrite billing logic\nHandle execution retries\nManage databases\nBuild admin dashboards\nWorry about uptime\nHandle user support infrastructure\nThe platform handles all of that.Your job is simpler and more valuable: solve the actual problem your Agent addresses.","what-you-control#What You Control":"","1-the-task-logic#1. The Task Logic":"This is your domain—the actual problem-solving:\n# You define WHAT your Agent does\nagent = (\n    AgentBuilder(\"InvoiceProcessor\")\n    .description(\"Extract line items from invoices\")\n    .add_workflow(processing_logic)  # ← This is yours\n    .build()\n)\nYou decide:\nWhat inputs are needed\nWhat processing happens\nWhat outputs are produced\nHow to handle edge cases\nWhat quality standards to maintain\nYou don't decide:\nWhen executions happen (users do)\nHow execution is scheduled (platform does)\nHow much to charge (market dynamics + your pricing)\nHow to scale (platform does)","2-the-user-experience-of-your-task#2. The User Experience of Your Task":"You design how users interact with your specific task:\n# Clear, minimal inputs\ninput_schema = {\n    \"document\": \"PDF file to process\",\n    \"extract_tables\": \"boolean (optional)\"\n}\n# Useful, structured outputs\noutput_schema = {\n    \"line_items\": \"array of extracted items\",\n    \"confidence_scores\": \"reliability metrics\"\n}\nYou control:\nWhat users need to provide\nHow results are structured\nWhat information is returned\nError messages for your task\nYou don't control:\nThe overall Client interface (platform does)\nAuthentication flows (platform does)\nPayment screens (platform does)\nMarketplace presentation (platform does, with your metadata)","3-your-agents-quality#3. Your Agent's Quality":"You're responsible for making your Agent work well:You ensure:\n✅ Correct outputs for valid inputs\n✅ Clear error messages for invalid inputs\n✅ Reasonable handling of edge cases\n✅ Consistent behavior across invocations\n✅ Appropriate use of resources\nYou don't ensure:\n❌ Platform uptime (platform's job)\n❌ Network reliability (platform's job)\n❌ User quota limits (platform's job)\n❌ Payment processing (platform's job)","4-your-agents-evolution#4. Your Agent's Evolution":"You decide how your Agent improves over time:\n# Version 1.0.0: Basic extraction\nagent_v1 = (\n    AgentBuilder(\"InvoiceProcessor\")\n    .version(\"1.0.0\")\n    .add_workflow(basic_extraction)\n    .build()\n)\n# Version 1.1.0: Add table extraction\nagent_v1_1 = (\n    AgentBuilder(\"InvoiceProcessor\")\n    .version(\"1.1.0\")  # You control versioning\n    .add_workflow(enhanced_extraction)\n    .build()\n)\nYou control:\nWhen to release updates\nWhat features to add\nHow to version changes\nWhether to deprecate old versions\nPlatform controls:\nHow users migrate between versions\nBackward compatibility enforcement\nWhich version users see by default","what-youre-free-from#What You're Free From":"Let's celebrate what you DON'T have to manage:","infrastructure-management#Infrastructure Management":"You don't:\n# ❌ Configure servers\n# ❌ Set up load balancers\n# ❌ Manage databases\n# ❌ Handle deployments\n# ❌ Monitor logs\n# ❌ Debug networking issues\n# ❌ Optimize resource allocation\nThe platform handles:\nAutomatic scaling\nResource allocation\nLoad balancing\nMonitoring and alerting\nInfrastructure security\nYou just define your Agent. The platform runs it.","user-management#User Management":"You don't:\n# ❌ Build signup flows\n# ❌ Verify emails\n# ❌ Reset passwords\n# ❌ Manage sessions\n# ❌ Handle 2FA\n# ❌ Store user data\n# ❌ Comply with GDPR for user accounts\nThe platform handles:\nUser authentication\nUser authorization\nAccount management\nPrivacy compliance\nSecurity measures\nUsers are already authenticated. Your Agent just works.","payment-processing#Payment Processing":"You don't:\n# ❌ Integrate payment gateways\n# ❌ Handle credit cards\n# ❌ Manage subscriptions\n# ❌ Calculate taxes\n# ❌ Process refunds\n# ❌ Handle chargebacks\n# ❌ Generate invoices\nThe platform handles:\nPayment collection\nBilling calculations\nRevenue distribution\nTax compliance\nFinancial reporting\nYou just get paid. The platform handles the complexity.","execution-management#Execution Management":"You don't:\n# ❌ Decide when to retry\n# ❌ Implement timeout logic\n# ❌ Handle execution failures\n# ❌ Track execution state\n# ❌ Manage execution queues\n# ❌ Balance execution load\nThe platform handles:\nExecution scheduling\nRetry strategies\nFailure recovery\nState management\nResource fairness\nYou define the logic. The platform executes it reliably.","the-freedom-this-gives-you#The Freedom This Gives You":"","focus-on-value-creation#Focus on Value Creation":"Traditional software development:\n1 week: Actual feature\n3 weeks: Infrastructure, auth, billing, UI, deployment\nAgent development:\n1 week: Actual feature\n1 day: SDK integration and validation\n4x more time on what matters.","rapid-experimentation#Rapid Experimentation":"Want to try a new Agent idea?Traditional approach:\nSet up infrastructure\nBuild authentication\nCreate UI\nHandle payments\nDeploy\nMarket to get users\nWeeks of work before you know if it's useful\nAgent approach:\n# Define your Agent\nagent = AgentBuilder(\"NewIdea\").add_workflow(...).build()\n# Validate it\nvalidate(agent)\n# Deploy to marketplace\nexport_yaml(agent)\nShip in hours. Learn immediately.","sustainable-maintenance#Sustainable Maintenance":"Traditional software gets harder to maintain over time:\nSecurity patches\nDependency updates\nInfrastructure changes\nScaling challenges\nAgents stay simple:\nUpdate task logic when needed\nSDK handles validation\nPlatform handles execution\nNo infrastructure to maintain\nYour Agent from 2024 still works in 2025. No maintenance burden.","understanding-the-boundaries#Understanding the Boundaries":"These boundaries exist to protect you, not limit you:","why-you-cant-control-execution#Why You Can't Control Execution":"Scenario: What if every developer implemented their own retry logic?\n# Developer A: Retry 3 times\n# Developer B: Retry 100 times\n# Developer C: Retry forever\nResult: Platform overload, unfair resource usage, unreliable billing.Solution: Platform handles retry logic consistently.Benefit to you: You don't have to think about it. Just define the task.","why-you-cant-control-billing#Why You Can't Control Billing":"Scenario: What if every developer calculated their own costs?\n# Developer A: Charges $0.01 per execution\n# Developer B: Forgot to count LLM tokens\n# Developer C: Charges $100 for a simple task\nResult: Confused users, unfair pricing, marketplace chaos.Solution: Platform calculates costs based on actual resource usage.Benefit to you: Fair, transparent pricing without your effort.","why-you-cant-control-authentication#Why You Can't Control Authentication":"Scenario: What if every Agent required separate login?\nUser workflow:\n1. Login to Platform\n2. Login to Agent A\n3. Login to Agent B\n4. Login to Agent C\nResult: Terrible user experience, security vulnerabilities, low adoption.Solution: Platform handles authentication once.Benefit to you: Users can use your Agent immediately, no friction.","what-this-means-practically#What This Means Practically":"","you-write-this#You Write This":"from ainalyn import AgentBuilder, WorkflowBuilder\n# Just describe the task\nagent = (\n    AgentBuilder(\"DataProcessor\")\n    .description(\"Process user data efficiently\")\n    .version(\"1.0.0\")\n    .add_workflow(\n        WorkflowBuilder(\"process\")\n        .add_node(processing_node)\n        .build()\n    )\n    .build()\n)\n# Validate and export\nvalidate(agent)\nyaml = export_yaml(agent)\nThat's it. ~20 lines of focused code.","you-dont-write-this#You DON'T Write This":"# ❌ You don't write any of this:\nclass UserAuth:\n    def signup(self, email, password): ...\n    def login(self, credentials): ...\n    def verify_email(self, token): ...\nclass PaymentProcessor:\n    def charge_card(self, amount): ...\n    def handle_webhook(self, event): ...\nclass ExecutionManager:\n    def schedule(self, agent, input): ...\n    def retry(self, execution): ...\n    def monitor(self, execution): ...\nclass InfrastructureManager:\n    def scale_up(self, load): ...\n    def handle_failure(self, instance): ...\nclass BillingCalculator:\n    def calculate_cost(self, usage): ...\n    def distribute_revenue(self, payment): ...\nHundreds of lines you never have to write.","the-developers-perspective#The Developer's Perspective":"","what-you-focus-on#What You Focus On":"90% - Task logic (the interesting part)\n5%  - Input/output design\n5%  - SDK integration\nThe work you actually want to do.","what-you-dont-worry-about#What You Don't Worry About":"0% - Infrastructure\n0% - Authentication\n0% - Payment processing\n0% - User management\n0% - Scaling\n0% - Monitoring\n0% - Security patches\n0% - Compliance\nThe work that drains energy without adding value.","real-world-example#Real-World Example":"Let's compare building a PDF text extractor:","traditional-approach#Traditional Approach":"What you build:\nWeb application with login\nFile upload handling\nPDF processing logic ← The actual value\nResult display UI\nPayment integration\nDatabase for user data\nAPI for third-party access\nAdmin dashboard\nUser support system\nEffort distribution:\n10% - PDF extraction logic (the valuable part)\n90% - Everything else\nTime to market: 2-3 months","agent-approach#Agent Approach":"What you build:\nagent = (\n    AgentBuilder(\"PDFTextExtractor\")\n    .description(\"Extract text from PDF documents\")\n    .version(\"1.0.0\")\n    .add_workflow(extraction_workflow)\n    .build()\n)\nEffort distribution:\n95% - PDF extraction logic (the valuable part)\n5% - SDK integration\nTime to market: 1-2 weeksThe difference is massive.","embracing-the-boundaries#Embracing the Boundaries":"These boundaries aren't limitations—they're liberation.","youre-not-limited#You're Not Limited":"You can still build:\n✅ Complex processing logic\n✅ Multi-step workflows\n✅ LLM-powered features\n✅ External API integrations\n✅ Sophisticated algorithms\n✅ Any task-oriented solution","youre-just-freed#You're Just Freed":"From:\n❌ Infrastructure concerns\n❌ User management\n❌ Payment processing\n❌ Execution orchestration\n❌ Scaling challenges\nAll your energy goes into the problem you're solving.","the-mental-shift#The Mental Shift":"","old-way-of-thinking#Old Way of Thinking":"\"I need to build a complete product with login, hosting, payments, UI, and the actual feature.\"Result: Overwhelmed, slow progress, maintenance burden.","new-way-of-thinking#New Way of Thinking":"\"I need to solve this specific problem really well and let the platform handle the rest.\"Result: Focused, rapid progress, sustainable maintenance.","common-questions#Common Questions":"","what-if-i-need-custom-authentication-for-my-agent#\"What if I need custom authentication for my Agent?\"":"Users are already authenticated with the platform. Your Agent receives authorized requests.You don't need custom auth. The platform handles it.","what-if-i-want-to-charge-custom-pricing#\"What if I want to charge custom pricing?\"":"You set pricing guidance, but actual charges depend on real resource usage.You influence pricing. The platform ensures fairness.","what-if-i-need-to-store-user-data-between-requests#\"What if I need to store user data between requests?\"":"Agents are stateless—each execution is independent.You process inputs and return outputs. The platform manages state if needed.","what-if-my-agent-needs-special-infrastructure#\"What if my Agent needs special infrastructure?\"":"Declare your requirements in the Agent definition:\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .add_tool(special_tool_definition)\n    .build()\n)\nYou declare needs. The platform provisions resources.","next-steps#Next Steps":"Now that you understand what you control:\nReady to Focus on What Matters?\nAgent Definition - Learn how to describe your Agent\nYour First Agent - Build something real\nWorkflow Guide - Design complex task logic\nYou control the task. The platform handles everything else.\nRemember: The best software is focused software.You focus on solving one problem brilliantly.The platform focuses on running it reliably for everyone.That's how great products get built."}},"/v1/getting-started/installation":{"title":"Installation","data":{"requirements#Requirements":"Python 3.11, 3.12, or 3.13\npip","install-from-pypi#Install from PyPI":"pip install ainalyn-sdk","install-from-source#Install from Source":"For development:\ngit clone https://github.com/CoreNovus/ainalyn-sdk.git\ncd ainalyn-sdk\npip install -e \".[dev]\"","verify-installation#Verify Installation":"Check the SDK is installed:\nainalyn --version\nTest Python import:\npython -c \"import ainalyn; print('OK')\"","next-steps#Next Steps":"Quickstart - 5-minute tutorial\nYour First Agent - Detailed walkthrough","need-help#Need Help?":"Report issues\nAsk questions"}},"/v1/getting-started/quickstart":{"title":"Quickstart","data":{"":"Build your first agent in 5 minutes.","install#Install":"pip install ainalyn-sdk","create-an-agent#Create an Agent":"Create my_agent.py:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate, export_yaml\n# Define a prompt\ngreeting_prompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a personalized greeting\")\n    .template(\"Generate a personalized greeting for {{user_name}}\")\n    .variables(\"user_name\")\n    .build()\n)\n# Define the agent\nagent = (\n    AgentBuilder(\"greeting-agent\")\n    .description(\"Generates personalized greetings\")\n    .version(\"1.0.0\")\n    .add_prompt(greeting_prompt)\n    .add_workflow(\n        WorkflowBuilder(\"greet-user\")\n        .description(\"Main greeting workflow\")\n        .add_node(\n            NodeBuilder(\"generate-greeting\")\n            .description(\"Generate a personalized greeting\")\n            .uses_prompt(\"greeting-prompt\")\n            .outputs(\"greeting\")\n            .build()\n        )\n        .entry_node(\"generate-greeting\")\n        .build()\n    )\n    .build()\n)\n# Validate\nvalidate(agent)\nprint(\"Valid!\")\n# Export to YAML\nyaml_output = export_yaml(agent)\nprint(yaml_output)","run#Run":"python my_agent.py\nOutput:\nValid!\n# Ainalyn Agent Definition\n# This file is a description submitted to Platform Core for review.\n# It does NOT execute by itself. Execution is handled by Platform Core.\n#\n# Local compilation does NOT equal platform execution.\nname: greeting-agent\nversion: 1.0.0\ndescription: Generates personalized greetings\nworkflows:\n- name: greet-user\n  description: Main greeting workflow\n  entry_node: generate-greeting\n  nodes:\n  - name: generate-greeting\n    description: Generate a personalized greeting\n    type: prompt\n    reference: greeting-prompt\n    outputs:\n    - greeting\nprompts:\n- name: greeting-prompt\n  description: Generates a personalized greeting\n  template: Generate a personalized greeting for {{user_name}}\n  variables:\n  - user_name","whats-happening#What's Happening":"PromptBuilder creates a prompt template\nAgentBuilder creates an agent\nWorkflowBuilder adds a workflow with entry_node\nNodeBuilder adds a task node that uses the prompt\nvalidate() checks the definition\nexport_yaml() converts to YAML","next-steps#Next Steps":"Build a more complex agent\nUnderstand platform boundaries\nExplore the API","using-the-cli#Using the CLI":"You can also use the command line:\n# Validate\nainalyn validate my_agent.py\n# Compile to YAML\nainalyn compile my_agent.py -o output.yaml","common-patterns#Common Patterns":"Multiple nodes with flow:\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Sequential processing workflow\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First step\")\n        .uses_prompt(\"step1-prompt\")\n        .next_nodes(\"step2\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second step\")\n        .uses_prompt(\"step2-prompt\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)\nMultiple workflows:\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow1)\n    .add_workflow(workflow2)\n    .build()\n)","need-help#Need Help?":"Full tutorial\nAPI reference\nReport issues"}},"/v1/getting-started/your-first-agent":{"title":"Your First Agent","data":{"":"Build a complete agent step by step.","what-well-build#What We'll Build":"A research assistant that:\nSearches for information\nAnalyzes findings\nGenerates a report","step-1-create-the-prompts-and-modules#Step 1: Create the Prompts and Modules":"from ainalyn import ModuleBuilder, PromptBuilder\n# Module for search\nsearch_module = (\n    ModuleBuilder(\"search-module\")\n    .description(\"Searches for relevant information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\"query\": {\"type\": \"string\"}},\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\"results\": {\"type\": \"array\"}},\n    })\n    .build()\n)\n# Prompt for analysis\nanalyze_prompt = (\n    PromptBuilder(\"analyze-prompt\")\n    .description(\"Analyzes collected information\")\n    .template(\"Analyze the following information: {{search_results}}\")\n    .variables(\"search_results\")\n    .build()\n)\n# Prompt for report generation\nreport_prompt = (\n    PromptBuilder(\"report-prompt\")\n    .description(\"Generates a structured research report\")\n    .template(\"Create a report based on: {{analysis}}\")\n    .variables(\"analysis\")\n    .build()\n)","step-2-create-the-nodes#Step 2: Create the Nodes":"from ainalyn import NodeBuilder\n# Node 1: Search\nsearch_node = (\n    NodeBuilder(\"search-information\")\n    .description(\"Search and collect relevant information\")\n    .uses_module(\"search-module\")\n    .inputs(\"query\")\n    .outputs(\"search_results\")\n    .next_nodes(\"analyze-findings\")\n    .build()\n)\n# Node 2: Analyze (follows search)\nanalyze_node = (\n    NodeBuilder(\"analyze-findings\")\n    .description(\"Analyze the collected information\")\n    .uses_prompt(\"analyze-prompt\")\n    .inputs(\"search_results\")\n    .outputs(\"analysis\")\n    .next_nodes(\"generate-report\")\n    .build()\n)\n# Node 3: Report (follows analyze)\nreport_node = (\n    NodeBuilder(\"generate-report\")\n    .description(\"Create a structured research report\")\n    .uses_prompt(\"report-prompt\")\n    .inputs(\"analysis\")\n    .outputs(\"report\")\n    .build()\n)\nFlow: search → analyze → report","step-3-create-the-workflow#Step 3: Create the Workflow":"from ainalyn import WorkflowBuilder\nresearch_workflow = (\n    WorkflowBuilder(\"conduct-research\")\n    .description(\"Research and reporting workflow\")\n    .add_node(search_node)\n    .add_node(analyze_node)\n    .add_node(report_node)\n    .entry_node(\"search-information\")\n    .build()\n)","step-4-create-the-agent#Step 4: Create the Agent":"from ainalyn import AgentBuilder\nresearch_agent = (\n    AgentBuilder(\"research-assistant\")\n    .description(\"Searches, analyzes, and reports on topics\")\n    .version(\"1.0.0\")\n    .add_module(search_module)\n    .add_prompt(analyze_prompt)\n    .add_prompt(report_prompt)\n    .add_workflow(research_workflow)\n    .build()\n)","step-5-validate-and-export#Step 5: Validate and Export":"from ainalyn.api import validate, export_yaml\n# Validate\nresult = validate(research_agent)\nif result.is_valid:\n    print(\"Valid!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error.message}\")\n# Export\nyaml_output = export_yaml(research_agent)\n# Save to file\nwith open(\"research_assistant.yaml\", \"w\", encoding=\"utf-8\") as f:\n    f.write(yaml_output)","complete-code#Complete Code":"research_agent.py:\nfrom ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    ModuleBuilder,\n    PromptBuilder,\n)\nfrom ainalyn.api import validate, export_yaml\n# Create resources\nsearch_module = (\n    ModuleBuilder(\"search-module\")\n    .description(\"Searches for relevant information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\"query\": {\"type\": \"string\"}},\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\"results\": {\"type\": \"array\"}},\n    })\n    .build()\n)\nanalyze_prompt = (\n    PromptBuilder(\"analyze-prompt\")\n    .description(\"Analyzes collected information\")\n    .template(\"Analyze the following information: {{search_results}}\")\n    .variables(\"search_results\")\n    .build()\n)\nreport_prompt = (\n    PromptBuilder(\"report-prompt\")\n    .description(\"Generates a structured research report\")\n    .template(\"Create a report based on: {{analysis}}\")\n    .variables(\"analysis\")\n    .build()\n)\n# Create nodes\nsearch_node = (\n    NodeBuilder(\"search-information\")\n    .description(\"Search and collect relevant information\")\n    .uses_module(\"search-module\")\n    .inputs(\"query\")\n    .outputs(\"search_results\")\n    .next_nodes(\"analyze-findings\")\n    .build()\n)\nanalyze_node = (\n    NodeBuilder(\"analyze-findings\")\n    .description(\"Analyze the collected information\")\n    .uses_prompt(\"analyze-prompt\")\n    .inputs(\"search_results\")\n    .outputs(\"analysis\")\n    .next_nodes(\"generate-report\")\n    .build()\n)\nreport_node = (\n    NodeBuilder(\"generate-report\")\n    .description(\"Create a structured research report\")\n    .uses_prompt(\"report-prompt\")\n    .inputs(\"analysis\")\n    .outputs(\"report\")\n    .build()\n)\n# Create workflow\nresearch_workflow = (\n    WorkflowBuilder(\"conduct-research\")\n    .description(\"Research and reporting workflow\")\n    .add_node(search_node)\n    .add_node(analyze_node)\n    .add_node(report_node)\n    .entry_node(\"search-information\")\n    .build()\n)\n# Create agent\nresearch_agent = (\n    AgentBuilder(\"research-assistant\")\n    .description(\"Searches, analyzes, and reports on topics\")\n    .version(\"1.0.0\")\n    .add_module(search_module)\n    .add_prompt(analyze_prompt)\n    .add_prompt(report_prompt)\n    .add_workflow(research_workflow)\n    .build()\n)\n# Validate and export\nresult = validate(research_agent)\nif result.is_valid:\n    yaml_output = export_yaml(research_agent)\n    with open(\"research_assistant.yaml\", \"w\", encoding=\"utf-8\") as f:\n        f.write(yaml_output)\n    print(\"Agent created and saved!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error.message}\")","run-it#Run It":"python research_agent.py","the-generated-yaml#The Generated YAML":"name: research-assistant\nversion: 1.0.0\ndescription: Searches, analyzes, and reports on topics\nworkflows:\n- name: conduct-research\n  description: Research and reporting workflow\n  entry_node: search-information\n  nodes:\n  - name: search-information\n    description: Search and collect relevant information\n    type: module\n    reference: search-module\n    next_nodes:\n    - analyze-findings\n    inputs:\n    - query\n    outputs:\n    - search_results\n  - name: analyze-findings\n    description: Analyze the collected information\n    type: prompt\n    reference: analyze-prompt\n    next_nodes:\n    - generate-report\n    inputs:\n    - search_results\n    outputs:\n    - analysis\n  - name: generate-report\n    description: Create a structured research report\n    type: prompt\n    reference: report-prompt\n    inputs:\n    - analysis\n    outputs:\n    - report\nmodules:\n- name: search-module\n  description: Searches for relevant information\n  input_schema:\n    type: object\n    properties:\n      query:\n        type: string\n    required:\n    - query\n  output_schema:\n    type: object\n    properties:\n      results:\n        type: array\nprompts:\n- name: analyze-prompt\n  description: Analyzes collected information\n  template: 'Analyze the following information: {{search_results}}'\n  variables:\n  - search_results\n- name: report-prompt\n  description: Generates a structured research report\n  template: 'Create a report based on: {{analysis}}'\n  variables:\n  - analysis","key-concepts#Key Concepts":"Workflow Flow\nUse .next_nodes() to define the next steps in the flow\nSet .entry_node() on the workflow to specify where it starts\nNodes reference resources (modules, prompts, tools) via .uses_*()\nBuilder Pattern\nAlways call .build() at the end\nMethods return self for chaining\nImmutable entities created on .build()\nBottom-Up Construction\nBuild resources first (modules, prompts, tools)\nBuild nodes that reference those resources\nAdd nodes to workflow with entry_node\nAdd resources and workflows to agent","common-mistakes#Common Mistakes":"Forgetting .build()\n# Wrong\nnode = NodeBuilder(\"task\").description(\"Do something\")\n# Correct\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\").build()\nCircular flow\n# Wrong (A points to B, B points to A)\nnode_a = NodeBuilder(\"a\").description(\"A\").uses_prompt(\"prompt-a\").next_nodes(\"b\").build()\nnode_b = NodeBuilder(\"b\").description(\"B\").uses_prompt(\"prompt-b\").next_nodes(\"a\").build()\nNot setting entry_node\n# Wrong\nworkflow = WorkflowBuilder(\"main\").add_node(node).build()\n# Correct\nworkflow = WorkflowBuilder(\"main\").add_node(node).entry_node(\"node-name\").build()\nInvalid names\n# Wrong\nAgentBuilder(\"My Agent\")   # No spaces\nAgentBuilder(\"MyAgent\")    # Must start with lowercase\n# Correct (use lowercase with hyphens)\nAgentBuilder(\"my-agent\")\nAgentBuilder(\"research-assistant\")","next-steps#Next Steps":"Platform Boundaries - What the SDK can/cannot do\nAPI Reference - All builder methods\nWorkflows - Advanced workflow patterns\nModules - Create custom modules","need-help#Need Help?":"Quickstart - Simpler example\nAPI docs - Function reference\nIssues - Report bugs"}},"/v1/guides/errors":{"title":"Error Handling","data":{"":"Common errors when building agents and how to fix them.","builder-errors#Builder Errors":"","missingrequiredfielderror#MissingRequiredFieldError":"What it means: You forgot to set a required field before calling .build().\n# Error\nagent = AgentBuilder(\"MyAgent\").build()\n# MissingRequiredFieldError: Required field 'version' is not set\n# Fix\nagent = AgentBuilder(\"MyAgent\").version(\"1.0.0\").build()\nRequired fields:\nAgentBuilder: name, version\nWorkflowBuilder: name\nNodeBuilder: name, goal","invalidvalueerror#InvalidValueError":"What it means: The value doesn't meet the requirements.\n# Error - invalid name format\nagent = AgentBuilder(\"My Agent\").build()\n# InvalidValueError: Invalid value for 'name': 'My Agent'\n# Fix - use valid format\nagent = AgentBuilder(\"MyAgent\").build()\nNaming rules:\nStart with lowercase letter or uppercase letter\nUse letters, numbers, underscores, or hyphens\nNo spaces, no special characters\nValid names:\n\"MyAgent\"        # CamelCase\n\"my_agent\"       # snake_case\n\"agent-v2\"       # With hyphens\n\"agent123\"       # With numbers\nInvalid names:\n\"my agent\"       # Space\n\"my@agent\"       # Special char\n\"123agent\"       # Starts with number","invalidreferenceerror#InvalidReferenceError":"What it means: A node references a module/prompt/tool that doesn't exist.\n# Error\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .description(\"Main workflow\")\n    .add_node(\n        NodeBuilder(\"task1\")\n        .description(\"Task 1\")\n        .uses_module(\"http-client\")  # Module doesn't exist!\n        .build()\n    )\n    .entry_node(\"task1\")\n    .build()\n)\n# Fix - define the module first\nmodule = ModuleBuilder(\"http-client\").build()\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")\n    .add_module(module)  # Add module to agent\n    .add_workflow(workflow)\n    .build()\n)","duplicatenameerror#DuplicateNameError":"What it means: Two items have the same name in the same scope.\n# Error - duplicate node names\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task\").goal(\"First\").build())\n    .add_node(NodeBuilder(\"task\").goal(\"Second\").build())  # Duplicate!\n    .build()\n)\n# Fix - use unique names\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task1\").goal(\"First\").build())\n    .add_node(NodeBuilder(\"task2\").goal(\"Second\").build())\n    .build()\n)","emptycollectionerror#EmptyCollectionError":"What it means: A required collection is empty.\n# Error - workflow has no nodes\nworkflow = WorkflowBuilder(\"main\").build()\n# EmptyCollectionError: Workflow 'main' has no nodes\n# Fix - add at least one node\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task1\").goal(\"Do something\").build())\n    .build()\n)","validation-errors#Validation Errors":"","circulardependencyerror#CircularDependencyError":"What it means: Nodes depend on each other in a loop.\n# Error - A depends on B, B depends on A\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"A\").goal(\"Task A\").depends_on(\"B\").build())\n    .add_node(NodeBuilder(\"B\").goal(\"Task B\").depends_on(\"A\").build())\n    .build()\n)\n# ValidationError: Circular dependency detected: A → B → A\n# Fix - remove the circular dependency\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"A\").goal(\"Task A\").build())\n    .add_node(NodeBuilder(\"B\").goal(\"Task B\").depends_on(\"A\").build())\n    .build()\n)","invaliddependencyerror#InvalidDependencyError":"What it means: A node depends on a non-existent node.\n# Error\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(\n        NodeBuilder(\"task1\")\n        .goal(\"Do something\")\n        .depends_on(\"task0\")  # task0 doesn't exist!\n        .build()\n    )\n    .build()\n)\n# Fix - ensure dependency exists\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task0\").goal(\"First task\").build())\n    .add_node(\n        NodeBuilder(\"task1\")\n        .goal(\"Do something\")\n        .depends_on(\"task0\")  # Now it exists\n        .build()\n    )\n    .build()\n)","catching-errors#Catching Errors":"","try-catch-pattern#Try-Catch Pattern":"from ainalyn import AgentBuilder, BuilderError\nfrom ainalyn.api import validate\ntry:\n    agent = (\n        AgentBuilder(\"MyAgent\")\n        .version(\"1.0.0\")\n        .build()\n    )\n    validate(agent)\n    print(\"Success!\")\nexcept BuilderError as e:\n    print(f\"Build error: {e.message}\")\nexcept Exception as e:\n    print(f\"Error: {e}\")","specific-error-types#Specific Error Types":"from ainalyn import (\n    MissingRequiredFieldError,\n    InvalidValueError,\n    DuplicateNameError\n)\ntry:\n    agent = AgentBuilder(\"MyAgent\").build()\nexcept MissingRequiredFieldError as e:\n    print(f\"Missing: {e.field_name}\")\n    print(f\"In: {e.builder_type}\")\nexcept InvalidValueError as e:\n    print(f\"Invalid {e.field_name}: {e.value}\")\n    print(f\"Rule: {e.constraint}\")\nexcept DuplicateNameError as e:\n    print(f\"Duplicate {e.entity_type}: {e.name}\")","common-patterns#Common Patterns":"","progressive-building#Progressive Building":"Build complex agents step-by-step to catch errors early:\n# Create nodes first\nnode1 = NodeBuilder(\"task1\").goal(\"First task\").build()\nnode2 = NodeBuilder(\"task2\").goal(\"Second task\").depends_on(\"task1\").build()\n# Create workflow\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(node1)\n    .add_node(node2)\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nvalidate(agent)","validation-before-export#Validation Before Export":"Always validate before exporting:\nfrom ainalyn.api import validate, export_yaml\ntry:\n    # Validate first\n    validate(agent)\n    # Then export\n    yaml_output = export_yaml(agent)\n    # Save to file\n    with open(\"agent.yaml\", \"w\") as f:\n        f.write(yaml_output)\n    print(\"Exported successfully!\")\nexcept Exception as e:\n    print(f\"Failed: {e}\")","quick-reference#Quick Reference":"Error\tCause\tFix\tMissingRequiredFieldError\tForgot to set field\tCall .field(value)\tInvalidValueError\tWrong value format\tUse valid format\tInvalidReferenceError\tReference doesn't exist\tDefine the resource first\tDuplicateNameError\tSame name used twice\tUse unique names\tEmptyCollectionError\tEmpty nodes/workflows\tAdd at least one item\tCircularDependencyError\tCircular dependencies\tRemove the loop","getting-help#Getting Help":"If you encounter an error not listed here:\nRead the error message carefully\nCheck the API reference\nReview the validation guide\nReport an issue"}},"/v1/guides/modules":{"title":"Modules","data":{"":"How to define reusable capability units for your agents.","what-is-a-module#What is a Module?":"A module is a self-contained functional component that can perform specific tasks. It defines:\nWhat it does (description)\nWhat input it expects (input schema)\nWhat output it produces (output schema)\nImportant: The SDK only defines the module's contract. The actual implementation is provided by the platform.","creating-a-module#Creating a Module":"from ainalyn import ModuleBuilder\nmodule = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Fetches data from HTTP endpoints\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\"]}\n        },\n        \"required\": [\"url\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\"type\": \"integer\"},\n            \"body\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","using-modules-in-workflows#Using Modules in Workflows":"Step 1: Define the module\nhttp_module = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Fetches data from HTTP endpoints\")\n    .input_schema({...})\n    .output_schema({...})\n    .build()\n)\nStep 2: Add module to agent\nagent = (\n    AgentBuilder(\"data-agent\")\n    .version(\"1.0.0\")\n    .add_module(http_module)  # Register module\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"fetch-data\")\n    .description(\"Fetch user data\")\n    .uses_module(\"http-client\")  # References the module\n    .inputs(\"url\")\n    .outputs(\"response\")\n    .build()\n)","json-schema#JSON Schema":"Modules use JSON Schema to define input/output contracts.Basic types:\n# String\n{\"type\": \"string\"}\n# Number\n{\"type\": \"number\"}\n# Integer\n{\"type\": \"integer\"}\n# Boolean\n{\"type\": \"boolean\"}\n# Array\n{\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n# Object\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}\nRequired fields:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"url\": {\"type\": \"string\"},\n        \"timeout\": {\"type\": \"integer\"}\n    },\n    \"required\": [\"url\"]  # url is required, timeout is optional\n}\nDefault values:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"method\": {\n            \"type\": \"string\",\n            \"default\": \"GET\"  # Default if not provided\n        }\n    }\n}\nEnums:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"enum\": [\"active\", \"inactive\", \"pending\"]\n        }\n    }\n}","common-module-patterns#Common Module Patterns":"","http-client#HTTP Client":"http_module = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Makes HTTP requests\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"string\"}\n        },\n        \"required\": [\"url\", \"method\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\"type\": \"integer\"},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","data-processor#Data Processor":"processor = (\n    ModuleBuilder(\"data-processor\")\n    .description(\"Processes and transforms data\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"data\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n            \"operation\": {\"type\": \"string\", \"enum\": [\"filter\", \"map\", \"reduce\"]}\n        },\n        \"required\": [\"data\", \"operation\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"result\": {\"type\": \"array\"},\n            \"count\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","file-operations#File Operations":"file_module = (\n    ModuleBuilder(\"file-handler\")\n    .description(\"Reads and writes files\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"path\": {\"type\": \"string\"},\n            \"operation\": {\"type\": \"string\", \"enum\": [\"read\", \"write\"]},\n            \"content\": {\"type\": \"string\"}\n        },\n        \"required\": [\"path\", \"operation\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"success\": {\"type\": \"boolean\"},\n            \"content\": {\"type\": \"string\"},\n            \"size\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","module-naming#Module Naming":"Valid names:\n\"http-client\"        # Lowercase with hyphens\n\"data-processor\"     # Descriptive\n\"file-handler-v2\"    # With version suffix\nInvalid names:\n\"HttpClient\"         # Must be lowercase\n\"data_processor\"     # No underscores\n\"my module\"          # No spaces","best-practices#Best Practices":"1. Keep schemas simple\n# Simple, focused schema\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"url\": {\"type\": \"string\"}\n    },\n    \"required\": [\"url\"]\n}\n# Avoid overly complex nested schemas\n2. Use descriptive property names\n# Clear property names\n{\n    \"properties\": {\n        \"user_id\": {\"type\": \"string\"},\n        \"email_address\": {\"type\": \"string\"}\n    }\n}\n# Avoid unclear names like \"id\" or \"data\"\n3. Document expected formats\n# Specify format\n{\n    \"properties\": {\n        \"email\": {\"type\": \"string\", \"format\": \"email\"},\n        \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n        \"date\": {\"type\": \"string\", \"format\": \"date\"}\n    }\n}\n4. Define required fields\n# Explicit required fields\n{\n    \"properties\": {\n        \"id\": {\"type\": \"string\"},\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    },\n    \"required\": [\"id\", \"name\"]  # age is optional\n}","module-vs-prompt-vs-tool#Module vs Prompt vs Tool":"Use Module when:\nYou need custom business logic\nPlatform provides the implementation\nInput/output are structured data\nUse Prompt when:\nYou need LLM-based reasoning\nInput/output are text-based\nSee Prompts Guide\nUse Tool when:\nYou need external services (APIs, databases)\nPlatform provides the integration\nSee Tools Guide","complete-example#Complete Example":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, ModuleBuilder, NodeType\n# Define module\nemail_module = (\n    ModuleBuilder(\"email-sender\")\n    .description(\"Sends emails via SMTP\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"to\": {\"type\": \"string\", \"format\": \"email\"},\n            \"subject\": {\"type\": \"string\"},\n            \"body\": {\"type\": \"string\"}\n        },\n        \"required\": [\"to\", \"subject\", \"body\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"sent\": {\"type\": \"boolean\"},\n            \"message_id\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"send-notification\")\n    .entry_node(\"send\")\n    .add_node(\n        NodeBuilder(\"send\")\n        .description(\"Send email notification\")\n        .uses_module(\"email-sender\")  # Reference module\n        .inputs(\"to\", \"subject\", \"body\")\n        .outputs(\"sent\", \"message_id\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"notification-agent\")\n    .version(\"1.0.0\")\n    .description(\"Sends email notifications\")\n    .add_module(email_module)  # Register module\n    .add_workflow(workflow)\n    .build()\n)","see-also#See Also":"ModuleBuilder API - Full API reference\nPrompts Guide - Using prompt templates\nTools Guide - External tool integration\nWorkflows - Using modules in workflows"}},"/v1/guides/tools":{"title":"Tools","data":{"":"How to define external tool interfaces for your agents.","what-is-a-tool#What is a Tool?":"A tool represents an external capability that your agent can invoke. It defines:\nWhat it does (description)\nWhat input it expects (input schema)\nWhat output it produces (output schema)\nImportant: The SDK only defines the tool's interface contract. The platform provides the actual implementation.","creating-a-tool#Creating a Tool":"from ainalyn import ToolBuilder\ntool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"max_results\": {\"type\": \"integer\", \"default\": 10}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"title\": {\"type\": \"string\"},\n                        \"url\": {\"type\": \"string\"},\n                        \"snippet\": {\"type\": \"string\"}\n                    }\n                }\n            }\n        }\n    })\n    .build()\n)","using-tools-in-workflows#Using Tools in Workflows":"Step 1: Define the tool\nsearch_tool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web\")\n    .input_schema({...})\n    .output_schema({...})\n    .build()\n)\nStep 2: Add tool to agent\nagent = (\n    AgentBuilder(\"research-agent\")\n    .version(\"1.0.0\")\n    .add_tool(search_tool)  # Register tool\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"search\")\n    .description(\"Search for information\")\n    .uses_tool(\"web-search\")  # References the tool\n    .inputs(\"query\")\n    .outputs(\"results\")\n    .build()\n)","common-tool-patterns#Common Tool Patterns":"","web-search#Web Search":"search = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"language\": {\"type\": \"string\", \"default\": \"en\"},\n            \"safe_search\": {\"type\": \"boolean\", \"default\": True}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n            \"total_count\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","database-query#Database Query":"db_query = (\n    ToolBuilder(\"database-query\")\n    .description(\"Executes SQL queries on database\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"parameters\": {\"type\": \"array\"},\n            \"timeout\": {\"type\": \"integer\", \"default\": 30}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"rows\": {\"type\": \"array\"},\n            \"row_count\": {\"type\": \"integer\"},\n            \"execution_time\": {\"type\": \"number\"}\n        }\n    })\n    .build()\n)","file-operations#File Operations":"file_writer = (\n    ToolBuilder(\"file-writer\")\n    .description(\"Writes content to files\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"path\": {\"type\": \"string\"},\n            \"content\": {\"type\": \"string\"},\n            \"encoding\": {\"type\": \"string\", \"default\": \"utf-8\"},\n            \"append\": {\"type\": \"boolean\", \"default\": False}\n        },\n        \"required\": [\"path\", \"content\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"success\": {\"type\": \"boolean\"},\n            \"bytes_written\": {\"type\": \"integer\"},\n            \"file_path\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","email-sender#Email Sender":"email_sender = (\n    ToolBuilder(\"email-sender\")\n    .description(\"Sends emails via SMTP\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"to\": {\"type\": \"array\", \"items\": {\"type\": \"string\", \"format\": \"email\"}},\n            \"subject\": {\"type\": \"string\"},\n            \"body\": {\"type\": \"string\"},\n            \"attachments\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n        },\n        \"required\": [\"to\", \"subject\", \"body\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"sent\": {\"type\": \"boolean\"},\n            \"message_id\": {\"type\": \"string\"},\n            \"recipients\": {\"type\": \"array\"}\n        }\n    })\n    .build()\n)","api-client#API Client":"api_client = (\n    ToolBuilder(\"rest-api-client\")\n    .description(\"Makes REST API calls\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"endpoint\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"object\"}\n        },\n        \"required\": [\"endpoint\", \"method\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status_code\": {\"type\": \"integer\"},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"object\"}\n        }\n    })\n    .build()\n)","tool-naming#Tool Naming":"Valid names:\n\"web-search\"          # Lowercase with hyphens\n\"file-writer\"         # Descriptive\n\"api-client-v2\"       # With version\nInvalid names:\n\"WebSearch\"           # Must be lowercase\n\"file_writer\"         # No underscores\n\"my tool\"             # No spaces","best-practices#Best Practices":"1. Use descriptive schemas\n# Clear input contract\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"search_query\": {\"type\": \"string\"},\n        \"result_limit\": {\"type\": \"integer\", \"minimum\": 1, \"maximum\": 100}\n    },\n    \"required\": [\"search_query\"]\n}\n2. Provide defaults for optional parameters\n{\n    \"properties\": {\n        \"timeout\": {\"type\": \"integer\", \"default\": 30},\n        \"retry_count\": {\"type\": \"integer\", \"default\": 3},\n        \"encoding\": {\"type\": \"string\", \"default\": \"utf-8\"}\n    }\n}\n3. Use appropriate constraints\n{\n    \"properties\": {\n        \"page_size\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 100,\n            \"default\": 20\n        },\n        \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\"\n        },\n        \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        }\n    }\n}\n4. Document expected behavior\n# Clear description\nToolBuilder(\"cache-manager\")\n    .description(\"Manages in-memory cache with TTL support\")","tool-vs-module-vs-prompt#Tool vs Module vs Prompt":"Use Tool when:\nYou need external services (APIs, databases, web search)\nPlatform provides the integration\nTask involves I/O operations\nUse Module when:\nYou need custom business logic\nTask is computation or data processing\nSee Modules Guide\nUse Prompt when:\nYou need LLM-based reasoning\nTask involves text understanding/generation\nSee Prompts Guide","complete-example#Complete Example":"from ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    ToolBuilder,\n    NodeType\n)\n# Define tool\nsearch_tool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"max_results\": {\"type\": \"integer\", \"default\": 10}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\"type\": \"array\"},\n            \"total_found\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"research\")\n    .entry_node(\"search\")\n    .add_node(\n        NodeBuilder(\"search\")\n        .description(\"Search for research topic\")\n        .uses_tool(\"web-search\")\n        .inputs(\"query\")\n        .outputs(\"results\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"research-agent\")\n    .version(\"1.0.0\")\n    .description(\"Web research assistant\")\n    .add_tool(search_tool)\n    .add_workflow(workflow)\n    .build()\n)","see-also#See Also":"ToolBuilder API - Full API reference\nModules Guide - Custom business logic\nPrompts Guide - LLM templates\nWorkflows - Using tools in workflows"}},"/v1/guides/validation":{"title":"Validation","data":{"":"How validation works and what gets checked.","what-gets-validated#What Gets Validated":"The SDK validates your agent definition before export to ensure it's ready for the platform.Schema Validation:\nRequired fields are present\nNaming conventions are correct\nVersion format is valid (semantic versioning)\nReferences are defined\nStructural Validation:\nWorkflows have at least one node\nEntry nodes exist\nNode references point to valid resources\nAll dependencies are defined","using-validate#Using validate()":"from ainalyn import AgentBuilder, validate\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")\n    .description(\"My first agent\")\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nresult = validate(agent)\nif result.is_valid:\n    print(\"Validation passed!\")\nelse:\n    print(\"Validation failed:\")\n    for error in result.errors:\n        print(f\"  {error.code}: {error.message}\")","validation-results#Validation Results":"The ValidationResult object contains:Properties:\nis_valid - Boolean indicating if validation passed\nerrors - List of validation errors\nwarnings - List of warnings (optional issues)\nError Details:\nEach error contains:\ncode - Error code (e.g., \"MISSING_AGENT_VERSION\")\npath - Location in the definition (e.g., \"agent.version\")\nmessage - Human-readable description\nseverity - ERROR or WARNING","naming-rules#Naming Rules":"Valid names:\n\"my-agent\"           # Lowercase with hyphens\n\"data-processor-v2\"  # Letters, numbers, hyphens\n\"fetch-data\"         # Starts with letter\nInvalid names:\n\"MyAgent\"      # Must be lowercase\n\"my_agent\"     # No underscores\n\"my agent\"     # No spaces\n\"2-agent\"      # Must start with letter","version-format#Version Format":"Valid versions:\n\"1.0.0\"        # Semantic versioning\n\"2.1.3\"        # Major.minor.patch\n\"0.1.0\"        # Pre-release\nInvalid versions:\n\"1.0\"          # Must have three parts\n\"v1.0.0\"       # No 'v' prefix\n\"1.0.0-beta\"   # No pre-release tags (yet)","common-validation-errors#Common Validation Errors":"","missing_agent_version#MISSING_AGENT_VERSION":"Cause: Forgot to set agent version.\n# Error\nagent = AgentBuilder(\"my-agent\").build()\n# Fix\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()","invalid_workflow_name#INVALID_WORKFLOW_NAME":"Cause: Workflow name doesn't follow naming rules.\n# Error\nworkflow = WorkflowBuilder(\"MyWorkflow\").build()\n# Fix\nworkflow = WorkflowBuilder(\"my-workflow\").build()","missing_workflows#MISSING_WORKFLOWS":"Cause: Agent has no workflows.\n# Error\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\n# Fix\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)","undefined_resource_reference#UNDEFINED_RESOURCE_REFERENCE":"Cause: Node references a resource that doesn't exist.\n# Error - prompt not defined\nnode = (\n    NodeBuilder(\"task\")\n    .description(\"Task node\")\n    .uses_prompt(\"analyzer\")  # No prompt named \"analyzer\"\n    .build()\n)\n# Fix - define the prompt first\nprompt = PromptBuilder(\"analyzer\").template(\"Analyze: {data}\").build()\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_prompt(prompt)  # Add prompt to agent\n    .add_workflow(workflow)\n    .build()\n)","invalid_entry_node#INVALID_ENTRY_NODE":"Cause: Workflow entry_node doesn't exist in nodes.\n# Error\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .entry_node(\"start\")  # No node named \"start\"\n    .add_node(NodeBuilder(\"step1\").goal(\"Do something\").build())\n    .build()\n)\n# Fix\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .entry_node(\"step1\")  # Valid node name\n    .add_node(NodeBuilder(\"step1\").goal(\"Do something\").build())\n    .build()\n)","best-practices#Best Practices":"1. Validate early and often\n# Build progressively, validate at each step\nnode = NodeBuilder(\"task\").goal(\"Process data\").build()\nworkflow = WorkflowBuilder(\"main\").add_node(node).build()\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").add_workflow(workflow).build()\n# Validate before export\nresult = validate(agent)\nif not result.is_valid:\n    print(\"Fix these errors before exporting:\")\n    for error in result.errors:\n        print(f\"  - {error.message}\")\n2. Check validation results\nresult = validate(agent)\n# Don't ignore validation!\nif not result.is_valid:\n    raise ValueError(f\"Invalid agent: {result.errors[0].message}\")\n# Now safe to export\nyaml_output = export_yaml(agent)\n3. Use compile_agent() for safety\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Automatically validates before exporting\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.message}\")","when-validation-happens#When Validation Happens":"Builder validation:\nHappens during .build() call\nChecks required fields\nValidates value formats\nThrows exceptions immediately\nSchema validation:\nHappens when you call validate()\nChecks structural correctness\nReturns ValidationResult\nDoes not throw exceptions\nExample:\n# Builder validation - throws exception\ntry:\n    agent = AgentBuilder(\"Invalid Name!\").build()  # Throws exception\nexcept InvalidValueError as e:\n    print(f\"Builder error: {e.message}\")\n# Schema validation - returns result\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\nresult = validate(agent)  # Returns ValidationResult\nif not result.is_valid:\n    print(f\"Schema error: {result.errors[0].message}\")","see-also#See Also":"Error Handling - Builder errors and how to fix them\nAPI Reference - validate() function details\nBuilders - Builder validation rules"}},"/v1/guides/workflows":{"title":"Workflows","data":{"":"How to structure task flows with nodes and dependencies.","what-is-a-workflow#What is a Workflow?":"A workflow defines the execution flow of tasks in your agent. It's a directed graph where:\nNodes are processing steps\nnext_nodes define execution order\nentry_node is where execution starts","basic-workflow#Basic Workflow":"from ainalyn import WorkflowBuilder, NodeBuilder\nworkflow = (\n    WorkflowBuilder(\"process-data\")\n    .description(\"Fetch and process data\")\n    .add_node(\n        NodeBuilder(\"fetch\")\n        .description(\"Fetch raw data\")\n        .uses_module(\"http-client\")\n        .outputs(\"raw_data\")\n        .next_nodes(\"process\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process the data\")\n        .uses_prompt(\"analyzer\")\n        .inputs(\"raw_data\")\n        .build()\n    )\n    .entry_node(\"fetch\")\n    .build()\n)\nExecution flow: fetch → process","node-dependencies#Node Dependencies":"Dependencies define execution order through next_nodes.Linear flow:\n# A → B → C\nnode_a = (\n    NodeBuilder(\"step-a\")\n    .description(\"First step\")\n    .uses_prompt(\"prompt-a\")\n    .next_nodes(\"step-b\")\n    .build()\n)\nnode_b = (\n    NodeBuilder(\"step-b\")\n    .description(\"Second step\")\n    .uses_prompt(\"prompt-b\")\n    .next_nodes(\"step-c\")\n    .build()\n)\nnode_c = (\n    NodeBuilder(\"step-c\")\n    .description(\"Final step\")\n    .uses_prompt(\"prompt-c\")\n    .build()\n)\nParallel execution:\n# A → [B, C] → D\nnode_a = (\n    NodeBuilder(\"start\")\n    .description(\"Start processing\")\n    .uses_prompt(\"start-prompt\")\n    .next_nodes(\"process-1\", \"process-2\")  # Both run in parallel\n    .build()\n)\nnode_b = (\n    NodeBuilder(\"process-1\")\n    .description(\"First parallel task\")\n    .uses_prompt(\"process-prompt-1\")\n    .next_nodes(\"merge\")\n    .build()\n)\nnode_c = (\n    NodeBuilder(\"process-2\")\n    .description(\"Second parallel task\")\n    .uses_prompt(\"process-prompt-2\")\n    .next_nodes(\"merge\")\n    .build()\n)\nnode_d = (\n    NodeBuilder(\"merge\")\n    .description(\"Merge results\")\n    .uses_prompt(\"merge-prompt\")\n    .build()\n)\nConditional branching:\n# A → [B or C] (decided by platform)\nnode_a = (\n    NodeBuilder(\"analyze\")\n    .description(\"Analyze input\")\n    .uses_module(\"analyzer\")\n    .next_nodes(\"path-a\", \"path-b\")  # Platform decides which path\n    .build()\n)","entry-node#Entry Node":"Every workflow must specify where execution starts.\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .entry_node(\"start\")  # Execution begins here\n    .add_node(\n        NodeBuilder(\"start\")\n        .description(\"Starting point\")\n        .build()\n    )\n    .build()\n)\nRules:\nEntry node must exist in the workflow's nodes\nOnly one entry node per workflow\nEntry node name must match exactly","data-flow#Data Flow":"Nodes pass data using inputs and outputs.\n# Node 1: Produces data\nproducer = (\n    NodeBuilder(\"fetch-user\")\n    .description(\"Fetch user data\")\n    .outputs([\"user_id\", \"user_name\"])  # Outputs these values\n    .next_nodes([\"process\"])\n    .build()\n)\n# Node 2: Consumes data\nconsumer = (\n    NodeBuilder(\"process\")\n    .description(\"Process user data\")\n    .inputs([\"user_id\", \"user_name\"])  # Uses these inputs\n    .outputs([\"result\"])\n    .build()\n)\nNotes:\nInput/output names are descriptive\nPlatform handles actual data passing\nSDK just defines the structure","multiple-workflows#Multiple Workflows":"Agents can have multiple workflows for different tasks.\nfrom ainalyn import AgentBuilder\n# Workflow 1: Data processing\nprocessing_workflow = WorkflowBuilder(\"process-data\").build()\n# Workflow 2: Reporting\nreporting_workflow = WorkflowBuilder(\"generate-report\").build()\n# Agent with both workflows\nagent = (\n    AgentBuilder(\"data-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(processing_workflow)\n    .add_workflow(reporting_workflow)\n    .build()\n)\nEach workflow is independent and can be invoked separately by the platform.","node-types#Node Types":"Uses Prompt - Uses a prompt template\nNodeBuilder(\"analyze\")\n    .description(\"Analyze data\")\n    .uses_prompt(\"analyzer-prompt\")  # References a Prompt\nUses Module - Executes custom logic\nNodeBuilder(\"fetch\")\n    .description(\"Fetch data\")\n    .uses_module(\"http-client\")  # References a Module\nUses Tool - Calls an external tool\nNodeBuilder(\"search\")\n    .description(\"Search web\")\n    .uses_tool(\"web-search\")  # References a Tool\nNote: The node type is automatically determined by which .uses_*() method you call.","common-patterns#Common Patterns":"","sequential-processing#Sequential Processing":"# Step 1 → Step 2 → Step 3\nworkflow = (\n    WorkflowBuilder(\"sequential\")\n    .description(\"Sequential workflow\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First\")\n        .uses_prompt(\"prompt1\")\n        .next_nodes(\"step2\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second\")\n        .uses_prompt(\"prompt2\")\n        .next_nodes(\"step3\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step3\")\n        .description(\"Final\")\n        .uses_prompt(\"prompt3\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)","fan-out-fan-in#Fan-Out, Fan-In":"# One node → Multiple parallel nodes → Merge\nworkflow = (\n    WorkflowBuilder(\"parallel\")\n    .description(\"Parallel workflow\")\n    .add_node(\n        NodeBuilder(\"split\")\n        .description(\"Split work\")\n        .uses_prompt(\"split-prompt\")\n        .next_nodes(\"work1\", \"work2\", \"work3\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work1\")\n        .description(\"Work 1\")\n        .uses_prompt(\"work-prompt-1\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work2\")\n        .description(\"Work 2\")\n        .uses_prompt(\"work-prompt-2\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work3\")\n        .description(\"Work 3\")\n        .uses_prompt(\"work-prompt-3\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"merge\")\n        .description(\"Combine results\")\n        .uses_prompt(\"merge-prompt\")\n        .build()\n    )\n    .entry_node(\"split\")\n    .build()\n)","pipeline-processing#Pipeline Processing":"# Input → Transform → Filter → Output\nworkflow = (\n    WorkflowBuilder(\"pipeline\")\n    .description(\"Pipeline workflow\")\n    .add_node(\n        NodeBuilder(\"input\")\n        .description(\"Read input\")\n        .uses_module(\"input-reader\")\n        .next_nodes(\"transform\")\n        .outputs(\"raw_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"transform\")\n        .description(\"Transform data\")\n        .uses_prompt(\"transform-prompt\")\n        .inputs(\"raw_data\")\n        .next_nodes(\"filter\")\n        .outputs(\"transformed_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"filter\")\n        .description(\"Filter data\")\n        .uses_prompt(\"filter-prompt\")\n        .inputs(\"transformed_data\")\n        .next_nodes(\"output\")\n        .outputs(\"filtered_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"output\")\n        .description(\"Write output\")\n        .uses_module(\"output-writer\")\n        .inputs(\"filtered_data\")\n        .build()\n    )\n    .entry_node(\"input\")\n    .build()\n)","validation-rules#Validation Rules":"Valid workflows:\nAt least one node\nEntry node exists in nodes\nAll next_nodes references exist\nNo circular dependencies (A → B → A)\nInvalid workflows:\n# No nodes\nworkflow = WorkflowBuilder(\"empty\").build()\n# Entry node doesn't exist\nworkflow = (\n    WorkflowBuilder(\"bad\")\n    .entry_node(\"missing\")  # No node named \"missing\"\n    .add_node(NodeBuilder(\"actual\").build())\n    .build()\n)\n# Undefined next_node reference\nnode = (\n    NodeBuilder(\"broken\")\n    .next_nodes([\"nonexistent\"])  # No node named \"nonexistent\"\n    .build()\n)","best-practices#Best Practices":"1. Use descriptive names\n# Clear names\nNodeBuilder(\"fetch-user-data\")\nNodeBuilder(\"validate-email\")\nNodeBuilder(\"send-notification\")\n# Unclear names\nNodeBuilder(\"step1\")\nNodeBuilder(\"process\")\nNodeBuilder(\"do-stuff\")\n2. Define clear data flow\n# Explicit inputs/outputs\nNodeBuilder(\"transform\")\n    .inputs([\"raw_data\"])\n    .outputs([\"clean_data\"])\n# No data flow specified\nNodeBuilder(\"transform\")\n    # Where does data come from?\n3. Keep workflows focused\n# Single responsibility\nprocess_workflow = WorkflowBuilder(\"process-orders\")\nreport_workflow = WorkflowBuilder(\"generate-reports\")\n# Too many responsibilities\neverything_workflow = WorkflowBuilder(\"do-everything\")","see-also#See Also":"Your First Agent - Complete workflow example\nNodeBuilder API - All node options\nValidation - Workflow validation rules"}},"/v1/advanced/system-context":{"title":"System Context","data":{"":"Understanding where the Ainalyn SDK fits in the overall system architecture.","application-architecture#Application Architecture":"","sdk-as-a-compiler#SDK as a Compiler":"The most important concept to understand: The SDK is a compiler, not a runtime.","key-boundaries#Key Boundaries":"","what-the-sdk-does#What the SDK Does":"Responsibility\tDescription\tDefine\tProvides builders to define Agent structure\tValidate\tChecks definition correctness before submission\tExport\tProduces platform-compatible YAML format\tCompile\tComplete workflow: validate → serialize → output","what-the-sdk-does-not-do#What the SDK Does NOT Do":"NOT Responsibility\tWhy\tExecute agents\tPlatform Core handles execution\tCall LLMs\tPlatform Core manages LLM interactions\tManage state\tPlatform Core handles runtime state\tHandle I/O\tPlatform Core manages external integrations","the-compilation-analogy#The Compilation Analogy":"Think of Ainalyn SDK like a programming language compiler:\n┌─────────────────────────────────────────────────────────────────────┐\n│                        Traditional Compiler                          │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│   Source Code (.py)  ──▶  Compiler  ──▶  Bytecode (.pyc)           │\n│                                                                     │\n│   The compiler doesn't run your program;                            │\n│   it produces something that can be run later.                      │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│                          Ainalyn SDK                                 │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│   Python Builders  ──▶  SDK  ──▶  Agent Definition (YAML)          │\n│                                                                     │\n│   The SDK doesn't run your agent;                                   │\n│   it produces a definition that Platform Core executes.             │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘","data-flow-overview#Data Flow Overview":"Developer                    SDK                         Platform\n────────                    ───                         ────────\n  │                          │                             │\n  │  1. Write Python code    │                             │\n  │  using builders          │                             │\n  │                          │                             │\n  ├─────────────────────────▶│                             │\n  │                          │                             │\n  │                          │  2. Validate structure      │\n  │                          │     Check references        │\n  │                          │     Detect cycles           │\n  │                          │                             │\n  │                          │  3. Serialize to YAML       │\n  │                          │                             │\n  │◀─────────────────────────┤                             │\n  │  4. Return YAML / errors │                             │\n  │                          │                             │\n  │                          │                             │\n  ├──────────────────────────┼────────────────────────────▶│\n  │  5. Submit YAML to platform                            │\n  │                          │                             │\n  │                          │                             │  6. Parse YAML\n  │                          │                             │  7. Execute agent\n  │                          │                             │  8. Call LLMs\n  │                          │                             │  9. Return results\n  │                          │                             │","why-this-separation#Why This Separation?":"","benefits-of-compiler-pattern#Benefits of Compiler Pattern":"Offline Validation\nCatch errors before deployment\nNo network calls needed for validation\nFast feedback loop for developers\nPlatform Independence\nSDK produces a standard format (YAML)\nPlatform can evolve independently\nMultiple platforms could consume the same format\nClear Responsibility\nSDK: definition correctness\nPlatform: execution correctness\nNo confusion about where bugs originate\nTestability\nTest definitions without running agents\nMock-free unit tests for SDK\nIntegration tests only at platform level","what-gets-compiled#What Gets Compiled":"The SDK compiles your Python builder calls into an Agent Definition:Input (Python):\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"customer-support\")\n    .version(\"1.0.0\")\n    .description(\"Handles customer inquiries\")\n    .add_workflow(\n        WorkflowBuilder(\"handle-inquiry\")\n        .add_node(NodeBuilder(\"classify\").type(\"llm\").build())\n        .add_node(NodeBuilder(\"respond\").type(\"llm\").build())\n        .add_edge(\"classify\", \"respond\")\n        .build()\n    )\n    .build()\n)\nOutput (YAML):\nname: customer-support\nversion: 1.0.0\ndescription: Handles customer inquiries\nworkflows:\n  - name: handle-inquiry\n    nodes:\n      - id: classify\n        type: llm\n      - id: respond\n        type: llm\n    edges:\n      - from: classify\n        to: respond","related-pages#Related Pages":"Hexagonal Architecture - Internal SDK architecture\nCompilation Flow - Detailed compilation process"}},"/v1/concepts/how-the-sdk-works":{"title":"How the SDK Works","data":{"":"The Ainalyn SDK has one job: help you describe your Agent clearly so the platform can execute it reliably.Think of it as a specialized compiler—you write Python code that describes what your Agent does, and the SDK transforms that into a format the platform understands.","the-core-concept#The Core Concept":"You describe, the platform executes.The SDK doesn't run your Agent. It helps you define it precisely so the platform can run it perfectly.","why-this-separation-matters#Why This Separation Matters":"When you build traditional software, description and execution are tangled together:\n# Traditional code: describes AND executes\ndef process_data(input):\n    # This code runs directly\n    result = do_processing(input)\n    return result\nWith Ainalyn, they're separate:\n# Agent definition: describes WHAT to do\nagent = (\n    AgentBuilder(\"DataProcessor\")\n    .description(\"Process user data and return results\")\n    .add_workflow(processing_workflow)\n    .build()  # ← This creates a description, not an execution\n)\nWhy? Because the platform needs to:\nSchedule executions fairly\nBill accurately\nHandle failures gracefully\nScale automatically\nEnforce security\nYou shouldn't have to worry about any of that.","your-development-flow#Your Development Flow":"Here's what actually happens when you build an Agent:","step-1-you-write-python-code#Step 1: You Write Python Code":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\n# Define what your Agent does\nmy_workflow = (\n    WorkflowBuilder(\"main\")\n    .description(\"Process the user's request\")\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Do the actual processing\")\n        .build()\n    )\n    .entry_node(\"process\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .description(\"Solves a specific problem\")\n    .version(\"1.0.0\")\n    .add_workflow(my_workflow)\n    .build()\n)\nAt this point, you have a Python object that describes your Agent. Nothing has executed.","step-2-sdk-validates-your-description#Step 2: SDK Validates Your Description":"from ainalyn.api import validate\nvalidate(agent)  # SDK checks your description makes sense\nThe SDK verifies:\n✅ Names follow conventions\n✅ Versions are valid\n✅ Workflows are properly connected\n✅ No circular dependencies\n✅ All references exist\nStill no execution. Just validation.","step-3-sdk-exports-to-yaml#Step 3: SDK Exports to YAML":"from ainalyn.api import export_yaml\nyaml_definition = export_yaml(agent)\nprint(yaml_definition)\nOutput:\nname: MyAgent\nversion: 1.0.0\ndescription: Solves a specific problem\nworkflows:\n  - name: main\n    description: Process the user's request\n    entry_node: process\n    nodes:\n      - name: process\n        description: Do the actual processing\nThis YAML is what you submit to the platform. It's a description, not executable code.","step-4-platform-takes-over#Step 4: Platform Takes Over":"You upload YAML to platform\n    ↓\nPlatform reviews and approves\n    ↓\nAgent appears in marketplace\n    ↓\nUser requests execution\n    ↓\nPlatform creates Execution\n    ↓\nPlatform runs your Agent\n    ↓\nPlatform returns results\n    ↓\nPlatform bills user\n    ↓\nPlatform pays you\nThe SDK's job ended at step 3. Everything else is the platform's responsibility.","what-the-sdk-actually-does#What the SDK Actually Does":"","for-you-the-developer#For You (The Developer)":"Provides a clean API:\nagent = (\n    AgentBuilder(\"MyAgent\")  # Clear, fluent interface\n    .description(\"What it does\")\n    .version(\"1.0.0\")\n    .build()  # Type-safe construction\n)\nCatches errors early:\nvalidate(agent)  # Immediate feedback\n# ValidationError: Node 'missing' referenced but not defined\nGenerates correct output:\nyaml = export_yaml(agent)  # Platform-compatible format\nOffers great IDE support:\nbuilder: AgentBuilder = AgentBuilder(\"MyAgent\")\n# ↑ Your IDE knows what methods are available","for-the-platform#For the Platform":"Ensures definitions are valid:\nAll required fields present\nNo invalid references\nProper structure\nSemantic correctness\nProvides consistent format:\nStandardized YAML schema\nPredictable structure\nEasy to parse and validate\nEnables governance:\nVersion tracking\nDependency analysis\nSecurity scanning\nPolicy enforcement","what-the-sdk-does-not-do#What the SDK Does NOT Do":"Let's be crystal clear about what the SDK doesn't handle:\nThe SDK Does NOT:\nExecute your Agent\nRun workflows or nodes\nMake network requests (for your Agent)\nCalculate execution costs\nManage user authentication\nHandle billing\nStore execution results\nRetry failed operations\nDecide when to run your Agent\nAll of that is the platform's job.","why-this-matters#Why This Matters":"You might think: \"Why can't I just test my Agent locally?\"Here's the thing—execution involves:\nUser authentication\n  ↓\nQuota checking\n  ↓\nResource allocation\n  ↓\nSecure sandboxing\n  ↓\nActual execution\n  ↓\nResult storage\n  ↓\nUsage tracking\n  ↓\nBilling calculation\n  ↓\nPayment processing\nThe SDK can't replicate this. Nor should it try.What the SDK CAN do:\nvalidate(agent)  # Check structure is valid\nexport_yaml(agent)  # Generate correct description\nThat's focused. That's reliable. That's what you need.","the-analogy-building-blueprints#The Analogy: Building Blueprints":"Think of it like architecture:","architect-you-with-sdk#Architect (You with SDK)":"# You create a blueprint\nbuilding = (\n    BuildingBuilder(\"MyBuilding\")\n    .floors(10)\n    .add_room(\"Office\", square_feet=500)\n    .build()\n)\n# SDK validates it makes sense\nvalidate(building)  # Are 10 floors structurally sound?\n# SDK produces construction documents\nblueprints = export_blueprints(building)\nYou're not constructing the building. You're describing it precisely.","construction-company-platform#Construction Company (Platform)":"Reads your blueprints\nOrders materials\nHires workers\nBuilds the actual building\nHandles inspections\nManages costs\nThe platform handles execution details.","why-separation-works#Why Separation Works":"You focus on design (what the building should be)\nPlatform focuses on execution (how to build it reliably)\nNo confusion about responsibilities\nNo duplication of effort\nSame with Agents.","understanding-the-workflow#Understanding the Workflow":"Let's trace a complete example from your perspective:","1-you-have-an-idea#1. You Have an Idea":"\"I want to build an Agent that extracts email addresses from documents.\"","2-you-define-it#2. You Define It":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nextraction_workflow = (\n    WorkflowBuilder(\"extract\")\n    .description(\"Extract emails from document\")\n    .add_node(\n        NodeBuilder(\"parse_document\")\n        .description(\"Parse the document\")\n        .outputs(\"parsed_text\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"extract_emails\")\n        .description(\"Find email addresses in text\")\n        .depends_on(\"parse_document\")\n        .outputs(\"email_list\")\n        .build()\n    )\n    .entry_node(\"parse_document\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"EmailExtractor\")\n    .description(\"Extract email addresses from documents\")\n    .version(\"1.0.0\")\n    .add_workflow(extraction_workflow)\n    .build()\n)\nYou've described the logic. The SDK ensures this description is valid.","3-you-validate#3. You Validate":"from ainalyn.api import validate\nvalidate(agent)  # ✓ Structure is valid\nThe SDK checks:\n✅ Workflow has entry node\n✅ All dependencies exist\n✅ No circular references\n✅ Names are valid","4-you-export#4. You Export":"from ainalyn.api import export_yaml\nyaml = export_yaml(agent)\nThe SDK generates a platform-compatible YAML description.","5-you-deploy#5. You Deploy":"# Upload to platform (exact mechanism TBD)\nainalyn deploy email_extractor.yaml\nThe SDK's job is done.","6-platform-takes-over#6. Platform Takes Over":"When a user requests your Agent:\nPlatform receives request\n    ↓\nCreates Execution (with unique executionId)\n    ↓\nAllocates resources\n    ↓\nRuns your workflow logic\n    ↓\n  • Parses document\n    ↓\n  • Extracts emails\n    ↓\nReturns results to user\n    ↓\nCalculates cost\n    ↓\nBills user, pays you\nYou didn't have to implement any of that.","development-best-practices#Development Best Practices":"","start-simple#Start Simple":"Don't overcomplicate your first Agent:\n# Good first Agent\nagent = (\n    AgentBuilder(\"SimpleExtractor\")\n    .description(\"Extract emails from text\")\n    .version(\"1.0.0\")\n    .add_workflow(simple_workflow)\n    .build()\n)\nGet the basics working, then iterate.","validate-often#Validate Often":"# After every significant change\nvalidate(agent)\nCatch issues immediately, not during deployment.","read-the-generated-yaml#Read the Generated YAML":"yaml = export_yaml(agent)\nprint(yaml)  # Review what you're actually submitting\nThe YAML is the source of truth. Make sure it matches your intent.","use-version-control#Use Version Control":"# Track your Agent definitions in git\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")  # ← Semantic versioning\n    .build()\n)\nVersion your Agents like you version your code.","common-questions#Common Questions":"","can-i-test-my-agent-locally-before-deploying#\"Can I test my Agent locally before deploying?\"":"You can validate the structure:\nvalidate(agent)  # ✓ Structure is correct\nBut you can't test the behavior locally, because behavior depends on platform execution, which includes:\nUser authentication context\nResource allocation\nActual tool integrations\nLLM interactions\nBilling calculations\nDeploy to a test environment on the platform instead.","what-if-my-agent-needs-external-apis#\"What if my Agent needs external APIs?\"":"You declare them in your definition:\ntool = (\n    ToolBuilder(\"weather_api\")\n    .description(\"Fetches weather data\")\n    .add_parameter(\"location\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"WeatherAgent\")\n    .add_tool(tool)  # ← SDK records this requirement\n    .build()\n)\nThe platform handles the actual API calls during execution.","how-do-i-debug-if-something-goes-wrong#\"How do I debug if something goes wrong?\"":"First, validate your definition:\nvalidate(agent)  # SDK catches structural issues\nThen, review the YAML:\nprint(export_yaml(agent))  # Is this what you intended?\nFinally, check platform execution logs:\nThe platform provides execution logs for runtime issues.","can-i-simulate-execution-to-estimate-costs#\"Can I simulate execution to estimate costs?\"":"No, because costs depend on:\nActual LLM token usage\nActual tool calls made\nActual execution time\nActual resource usage\nYou can't predict these from a static definition.The platform provides cost estimates based on historical data.","the-mental-model#The Mental Model":"Keep this mental model in mind:\n┌─────────────────────────────────────────┐\n│          YOUR WORLD (SDK)               │\n│                                         │\n│  Define → Validate → Export             │\n│                                         │\n│  Focus: WHAT the Agent does             │\n└─────────────────────────────────────────┘\n                  │\n                  │ YAML Description\n                  ↓\n┌─────────────────────────────────────────┐\n│       PLATFORM WORLD (Runtime)          │\n│                                         │\n│  Schedule → Execute → Bill → Pay        │\n│                                         │\n│  Focus: HOW to run reliably             │\n└─────────────────────────────────────────┘\nYou describe. Platform executes.Clean separation. Clear responsibilities.","why-youll-love-this-approach#Why You'll Love This Approach":"","focus-on-your-expertise#Focus on Your Expertise":"You're good at solving problems, not managing infrastructure.With the SDK, you just describe the solution.","rapid-iteration#Rapid Iteration":"# Change your definition\nagent = agent_builder.version(\"1.0.1\").build()\n# Validate\nvalidate(agent)\n# Deploy\nexport_yaml(agent)\nNo infrastructure changes needed.","confidence-in-correctness#Confidence in Correctness":"validate(agent)  # ✓ If this passes, your definition is solid\nNo surprises during deployment.","let-the-platform-handle-complexity#Let the Platform Handle Complexity":"You don't debug:\nScaling issues\nAuthentication failures\nBilling errors\nNetwork timeouts\nResource exhaustion\nThe platform handles all of that.","next-steps#Next Steps":"Now that you understand how the SDK works:\nReady to Build?\nInstall the SDK - 60 second setup\nYour First Agent - Build something real\nAgent Definition Reference - Deep dive into structure\nYou're just describing Agents. The platform does the heavy lifting.\nRemember: The SDK is a specialized compiler, not a runtime engine.Your job: Describe your Agent clearly.Platform's job: Execute it reliably.That's how great software gets built."}},"/v1/getting-started":{"title":"Ainalyn SDK","data":{"":"Build task-oriented agents with Python. The Ainalyn SDK is a compiler that turns your Python code into platform-ready agent definitions.\nSDK = Compiler, Not RuntimeThe SDK creates agent descriptions. The Ainalyn Platform executes them.","user-flow#User Flow":"","what-it-does#What it does":"Define agents with a Python API\nValidate definitions before deployment\nExport to YAML for the platform","features#Features":"Type-safe API - Full type hints and IDE autocomplete\nFluent builders - Chainable, intuitive API\nValidation - Catch errors before deployment\nYAML export - One command to platform-ready format","example#Example":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate, export_yaml\n# Define a prompt\ngreeting_prompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a personalized greeting\")\n    .template(\"Generate a personalized greeting for {{user_name}}\")\n    .variables(\"user_name\")\n    .build()\n)\n# Define an agent\nagent = (\n    AgentBuilder(\"greeting-agent\")\n    .description(\"Generates personalized greetings\")\n    .version(\"1.0.0\")\n    .add_prompt(greeting_prompt)\n    .add_workflow(\n        WorkflowBuilder(\"greet-user\")\n        .description(\"Main greeting workflow\")\n        .add_node(\n            NodeBuilder(\"generate-greeting\")\n            .description(\"Generate a personalized greeting\")\n            .uses_prompt(\"greeting-prompt\")\n            .outputs(\"greeting\")\n            .build()\n        )\n        .entry_node(\"generate-greeting\")\n        .build()\n    )\n    .build()\n)\n# Validate and export\nvalidate(agent)\nyaml_output = export_yaml(agent)","getting-started#Getting Started":"New to the SDK?\nInstall the SDK\nTry the 5-minute quickstart\nBuild your first agent\nUnderstanding the SDK\nPlatform Boundaries - What the SDK can and cannot do\nCompiler vs Runtime - Why the SDK is a compiler\nArchitecture - How it's built\nAgent Definitions - What you're creating","important-sdk-boundaries#Important: SDK Boundaries":"The SDK creates descriptions. The platform runs them.What the SDK does:\nDefine agent structures\nValidate definitions\nExport to YAML\nWhat the SDK does NOT do:\nExecute agents\nHandle billing\nManage retries or timeouts\nLearn more about platform boundaries","support#Support":"Report issues\nAsk questions\nView source"}},"/v1/guides/prompts":{"title":"Prompts","data":{"":"How to create reusable LLM prompt templates for your agents.","what-is-a-prompt#What is a Prompt?":"A prompt is a template that defines how to interact with Language Models. It supports:\nTemplate text with variable placeholders\nVariable interpolation using {{variable}} syntax\nReusability across multiple workflows\nImportant: The SDK defines the prompt template. The platform handles LLM invocation.","creating-a-prompt#Creating a Prompt":"from ainalyn import PromptBuilder\nprompt = (\n    PromptBuilder(\"data-analyzer\")\n    .description(\"Analyzes data and provides insights\")\n    .template(\"\"\"\nPlease analyze the following data:\n{{data}}\nFocus on: {{focus_areas}}\nProvide detailed insights and recommendations.\n\"\"\")\n    .variables([\"data\", \"focus_areas\"])\n    .build()\n)","variable-syntax#Variable Syntax":"Use {{variable_name}} to mark placeholders in your template.\ntemplate = \"\"\"\nHello {{name}},\nYour order {{order_id}} has been {{status}}.\nThank you!\n\"\"\"\nprompt = (\n    PromptBuilder(\"order-notification\")\n    .template(template)\n    .variables([\"name\", \"order_id\", \"status\"])\n    .build()\n)\nAt runtime:\nPlatform replaces {{name}} with actual value\nVariables come from node inputs or previous outputs","using-prompts-in-workflows#Using Prompts in Workflows":"Step 1: Define the prompt\nanalyzer = (\n    PromptBuilder(\"analyzer\")\n    .description(\"Analyzes text content\")\n    .template(\"Analyze this: {{content}}\")\n    .variables([\"content\"])\n    .build()\n)\nStep 2: Add prompt to agent\nagent = (\n    AgentBuilder(\"text-agent\")\n    .version(\"1.0.0\")\n    .add_prompt(analyzer)  # Register prompt\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"analyze\")\n    .description(\"Analyze content\")\n    .uses_prompt(\"analyzer\")  # References the prompt\n    .inputs(\"content\")\n    .outputs(\"analysis\")\n    .build()\n)","common-prompt-patterns#Common Prompt Patterns":"","text-analysis#Text Analysis":"analyzer = (\n    PromptBuilder(\"text-analyzer\")\n    .description(\"Analyzes text for sentiment and key points\")\n    .template(\"\"\"\nAnalyze the following text:\n{{text}}\nProvide:\n1. Sentiment (positive/negative/neutral)\n2. Key points (3-5 bullet points)\n3. Summary (1-2 sentences)\n\"\"\")\n    .variables([\"text\"])\n    .build()\n)","data-summarization#Data Summarization":"summarizer = (\n    PromptBuilder(\"data-summarizer\")\n    .description(\"Summarizes structured data\")\n    .template(\"\"\"\nSummarize this data:\n{{data}}\nFormat: {{format}}\nInclude statistics and key findings.\n\"\"\")\n    .variables([\"data\", \"format\"])\n    .build()\n)","content-generation#Content Generation":"generator = (\n    PromptBuilder(\"content-generator\")\n    .description(\"Generates content based on topic\")\n    .template(\"\"\"\nWrite a {{content_type}} about {{topic}}.\nTone: {{tone}}\nLength: {{length}} words\nRequirements:\n{{requirements}}\n\"\"\")\n    .variables([\"content_type\", \"topic\", \"tone\", \"length\", \"requirements\"])\n    .build()\n)","translation#Translation":"translator = (\n    PromptBuilder(\"translator\")\n    .description(\"Translates text between languages\")\n    .template(\"\"\"\nTranslate the following text from {{source_lang}} to {{target_lang}}:\n{{text}}\nMaintain the original tone and style.\n\"\"\")\n    .variables([\"source_lang\", \"target_lang\", \"text\"])\n    .build()\n)","qa-assistant#Q&A Assistant":"qa = (\n    PromptBuilder(\"qa-assistant\")\n    .description(\"Answers questions based on context\")\n    .template(\"\"\"\nContext:\n{{context}}\nQuestion: {{question}}\nProvide a clear, concise answer based only on the context provided.\n\"\"\")\n    .variables([\"context\", \"question\"])\n    .build()\n)","multiline-templates#Multiline Templates":"Use Python triple quotes for readable templates:\n# Readable multiline template\ntemplate = \"\"\"\nAnalyze the following report:\nTitle: {{title}}\nDate: {{date}}\nAuthor: {{author}}\nContent:\n{{content}}\nProvide a summary and key takeaways.\n\"\"\"\n# Avoid hard to read single line\n# template = \"Analyze: {{title}} Date: {{date}}...\"","variables-best-practices#Variables Best Practices":"1. List all variables used\n# All variables declared\nPromptBuilder(\"analyzer\")\n    .template(\"Analyze {{data}} focusing on {{aspect}}\")\n    .variables([\"data\", \"aspect\"])\n# Missing variable declaration - avoid this\nPromptBuilder(\"analyzer\")\n    .template(\"Analyze {{data}} focusing on {{aspect}}\")\n    .variables([\"data\"])  # Missing \"aspect\"\n2. Use descriptive variable names\n# Clear variable names\n.variables([\"user_email\", \"order_id\", \"delivery_date\"])\n# Unclear - avoid\n.variables([\"e\", \"id\", \"d\"])\n3. Keep variable count manageable\n# Focused prompt with 2-4 variables\n.variables([\"topic\", \"tone\", \"length\"])\n# Too many variables - consider splitting\n# .variables([\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\"])","prompt-naming#Prompt Naming":"Valid names:\n\"text-analyzer\"       # Lowercase with hyphens\n\"data-summarizer\"     # Descriptive\n\"qa-assistant-v2\"     # With version\nInvalid names:\n\"TextAnalyzer\"        # Must be lowercase\n\"text_analyzer\"       # No underscores\n\"my prompt\"           # No spaces","prompt-design-tips#Prompt Design Tips":"1. Be specific\n# Specific instructions\ntemplate = \"\"\"\nAnalyze the sentiment of this customer review:\n{{review}}\nClassify as: positive, negative, or neutral\nProvide reasoning in 1-2 sentences\n\"\"\"\n# Vague - avoid\n# template = \"What do you think about {{review}}?\"\n2. Structure the output\n# Structured output request\ntemplate = \"\"\"\nSummarize: {{article}}\nFormat:\n- Main idea: [1 sentence]\n- Key points: [3-5 bullets]\n- Conclusion: [1 sentence]\n\"\"\"\n# Unstructured - may give inconsistent results\n# template = \"Summarize {{article}}\"\n3. Provide context\n# With context\ntemplate = \"\"\"\nYou are a technical documentation expert.\nReview this code documentation:\n{{documentation}}\nSuggest improvements for clarity and completeness.\n\"\"\"\n# No context - less effective\n# template = \"Review {{documentation}}\"","complete-example#Complete Example":"from ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    PromptBuilder,\n    NodeType\n)\n# Define prompt\nreview_prompt = (\n    PromptBuilder(\"code-reviewer\")\n    .description(\"Reviews code for quality and best practices\")\n    .template(\"\"\"\nReview the following code:\nLanguage: {{language}}\nCode:\n{{code}}\nProvide:\n1. Overall quality assessment\n2. Potential issues or bugs\n3. Suggestions for improvement\n4. Best practice recommendations\n\"\"\")\n    .variables([\"language\", \"code\"])\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"code-review\")\n    .entry_node(\"review\")\n    .add_node(\n        NodeBuilder(\"review\")\n        .description(\"Review submitted code\")\n        .uses_prompt(\"code-reviewer\")\n        .inputs(\"language\", \"code\")\n        .outputs(\"review_result\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"code-review-agent\")\n    .version(\"1.0.0\")\n    .description(\"Automated code review assistant\")\n    .add_prompt(review_prompt)\n    .add_workflow(workflow)\n    .build()\n)","prompt-vs-module-vs-tool#Prompt vs Module vs Tool":"Use Prompt when:\nYou need LLM-based reasoning\nTask involves text understanding or generation\nOutput is natural language\nUse Module when:\nYou need deterministic logic\nTask is computation or data processing\nSee Modules Guide\nUse Tool when:\nYou need external services\nTask involves APIs or databases\nSee Tools Guide","see-also#See Also":"PromptBuilder API - Full API reference\nModules Guide - Custom business logic\nTools Guide - External integrations\nWorkflows - Using prompts in workflows"}},"/v1/guides/yaml-export":{"title":"YAML Export","data":{"":"Convert agent definitions to platform-ready YAML format.","what-is-yaml-export#What is YAML Export?":"YAML export transforms your Python agent definition into a YAML file that the Ainalyn Platform can execute.Key points:\nYAML is the platform's input format\nExport does NOT execute your agent\nThe platform reads YAML files to run agents\nSDK is a compiler, not a runtime","using-export_yaml#Using export_yaml()":"from ainalyn import AgentBuilder, export_yaml\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Process data\")\n    .add_workflow(workflow)\n    .build()\n)\n# Export to YAML string\nyaml_output = export_yaml(agent)\nprint(yaml_output)\nOutput:\nname: my-agent\nversion: 1.0.0\ndescription: Process data\nworkflows:\n  - name: main-workflow\n    description: Main processing workflow\n    entry_node: start\n    nodes:\n      - name: start\n        description: Start processing\n        type: prompt\n        reference: data-processor","saving-to-file#Saving to File":"from ainalyn import export_yaml\n# Export to string\nyaml_output = export_yaml(agent)\n# Save to file\nwith open(\"agent.yaml\", \"w\") as f:\n    f.write(yaml_output)\nprint(\"Saved to agent.yaml\")","using-compile_agent#Using compile_agent()":"Recommended: Use compile_agent() for automatic validation and export.\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Validates and exports in one step\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\n    print(result.yaml_content)\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.message}\")\nAdvantages:\nValidates before exporting\nPrevents invalid YAML files\nReturns detailed error messages\nCreates parent directories automatically","yaml-structure#YAML Structure":"The exported YAML follows this structure:\n# Required fields\nname: agent-name\nversion: 1.0.0\ndescription: What the agent does\n# Workflows (required, at least one)\nworkflows:\n  - name: workflow-name\n    description: What this workflow does\n    entry_node: first-node\n    nodes:\n      - name: node-name\n        description: What this node does\n        type: prompt|module|tool\n        reference: resource-name\n        next_nodes:\n          - next-node-name\n        inputs:\n          - input-name\n        outputs:\n          - output-name\n# Resources (optional)\nmodules:\n  - name: module-name\n    description: What the module does\n    input_schema: {}\n    output_schema: {}\nprompts:\n  - name: prompt-name\n    description: What the prompt does\n    template: \"Prompt text with {variables}\"\n    variables:\n      - variable-name\ntools:\n  - name: tool-name\n    description: What the tool does\n    input_schema: {}\n    output_schema: {}","export-features#Export Features":"Unicode Support:\nagent = (\n    AgentBuilder(\"translator\")\n    .version(\"1.0.0\")\n    .description(\"翻譯助手\")  # Unicode supported\n    .build()\n)\nyaml_output = export_yaml(agent)\n# Output preserves Unicode characters\nDeterministic Ordering:\nKeys appear in consistent order\nWorkflows, modules, prompts, tools grouped logically\nReadable and version-control friendly\nHuman-Readable:\n# Indentation: 2 spaces\n# Flow style: False (multiline)\n# Sort keys: False (manual ordering)","export-vs-validation#Export vs Validation":"export_yaml() - No validation\n# Exports without checking validity\nyaml_output = export_yaml(agent)\n# May produce invalid YAML if agent is malformed\ncompile_agent() - Validates first\n# Validates before exporting\nresult = compile_agent(agent)\nif result.is_successful:\n    yaml_output = result.yaml_content\n# Only exports if valid","common-patterns#Common Patterns":"","export-to-string#Export to String":"from ainalyn import export_yaml\nyaml_string = export_yaml(agent)\nprint(yaml_string)","export-to-file#Export to File":"from ainalyn import export_yaml\nyaml_output = export_yaml(agent)\nwith open(\"agent.yaml\", \"w\", encoding=\"utf-8\") as f:\n    f.write(yaml_output)","validate-and-export#Validate and Export":"from ainalyn import validate, export_yaml\n# Validate first\nresult = validate(agent)\nif result.is_valid:\n    # Then export\n    yaml_output = export_yaml(agent)\n    with open(\"agent.yaml\", \"w\") as f:\n        f.write(yaml_output)\nelse:\n    print(\"Cannot export: validation failed\")","safe-compilation#Safe Compilation":"from ainalyn.api import compile_agent\nfrom pathlib import Path\n# All-in-one: validate + export + save\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(\"Ready for platform deployment\")\nelse:\n    print(f\"Fix these errors first:\")\n    for error in result.validation_result.errors:\n        print(f\"  - {error.message}\")","file-output#File Output":"Creating parent directories:\nfrom pathlib import Path\nfrom ainalyn.api import compile_agent\n# Creates 'output/' directory if it doesn't exist\nresult = compile_agent(agent, Path(\"output/agent.yaml\"))\nUTF-8 encoding:All files are written with UTF-8 encoding to support Unicode content.","what-happens-next#What Happens Next?":"After exporting your agent:\nYou created: YAML definition file\nPlatform reads: YAML to understand agent structure\nPlatform executes: Agent based on definition\nSDK's job is done: No runtime involvement\nSee Platform Boundaries for the SDK's role.","see-also#See Also":"Validation - Validate before export\ncompile_agent() API - Full API reference\nPlatform Boundaries - SDK vs Platform roles"}}}