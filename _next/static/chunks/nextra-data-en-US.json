{"/":{"title":"Ainalyn Documentation","data":{"":"Welcome to the Ainalyn SDK documentation.\nRedirecting to documentation...If you are not redirected, click here."}},"/v1/api-reference/api":{"title":"API Reference","data":{"":"The main API functions for validating and exporting agents.","validate#validate()":"Validates an agent definition.\nfrom ainalyn.api import validate\nresult = validate(agent)\nParameters:\ndefinition (AgentDefinition) - The agent to validate\nReturns:\nValidationResult - Contains validation errors and warnings\nresult.is_valid (bool) - True if no errors found\nresult.has_warnings (bool) - True if warnings found\nresult.errors (tuple[ValidationError, ...]) - All errors and warnings\nValidation Steps:\nSchema validation (structural correctness)\nStatic analysis (logical consistency, circular dependencies, unreachable nodes)\nExample:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate\nprompt = PromptBuilder(\"my-prompt\").description(\"Test prompt\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test workflow\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node 1\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\nresult = validate(agent)\nif result.is_valid:\n    print(\"Valid!\")\nelse:\n    for error in result.errors:\n        print(f\"{error.severity.value}: {error.code} - {error.message}\")","export_yaml#export_yaml()":"Exports an agent definition to YAML.\nfrom ainalyn.api import export_yaml\nyaml_output = export_yaml(agent)\nParameters:\ndefinition (AgentDefinition) - The agent to export\nReturns:\nstr - YAML-formatted string with header comments\nImportant:\nThis function does NOT validate before exporting\nFor a complete workflow with validation, use compile_agent() instead\nExample:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import export_yaml\nprompt = PromptBuilder(\"my-prompt\").description(\"Test\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\nyaml_str = export_yaml(agent)\nprint(yaml_str)","compile_agent#compile_agent()":"Validates and exports an agent definition (recommended workflow).\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nParameters:\ndefinition (AgentDefinition) - The agent to compile\noutput_path (Path | None) - Optional file path to save YAML. If None, returns YAML without writing.\nReturns:\nCompilationResult - Contains:\nvalidation_result (ValidationResult) - Validation results\nyaml_content (str | None) - YAML string if successful\noutput_path (Path | None) - File path if written\nis_successful (bool) - True if validation passed\nWorkflow:\nValidates the definition (schema + static analysis)\nExports to YAML (only if validation passes)\nWrites to file (if output_path provided)\nImportant: Local compilation does NOT equal platform execution. This creates a description for platform submission.Example:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Build agent\nprompt = PromptBuilder(\"my-prompt\").description(\"Test\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\n# Compile to file\nresult = compile_agent(agent, Path(\"output.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\nelse:\n    print(\"Validation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.code}: {error.message}\")"}},"/v1/api-reference/builders":{"title":"Builders API","data":{"":"Builders provide a fluent API for creating agent definitions.","agentbuilder#AgentBuilder":"Creates an agent definition.\nfrom ainalyn import AgentBuilder\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .description(\"What the agent does\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)\nMethods:\n.description(text) - Set agent description (required)\n.version(version) - Set semantic version like \"1.0.0\" (required)\n.add_workflow(workflow) - Add a workflow (at least one required)\n.workflows(*workflows) - Add multiple workflows at once\n.add_module(module) - Add a reusable module (optional)\n.modules(*modules) - Add multiple modules at once\n.add_prompt(prompt) - Add a prompt template (optional)\n.prompts(*prompts) - Add multiple prompts at once\n.add_tool(tool) - Add a tool definition (optional)\n.tools(*tools) - Add multiple tools at once\n.build() - Create the immutable AgentDefinition\nNaming Convention: Agent names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens (e.g., \"my-agent\", \"data-processor\")","workflowbuilder#WorkflowBuilder":"Creates a workflow.\nfrom ainalyn import WorkflowBuilder, NodeBuilder, PromptBuilder\nprompt = PromptBuilder(\"task-prompt\").description(\"Task prompt\").template(\"Do task\").build()\nworkflow = (\n    WorkflowBuilder(\"main-flow\")\n    .description(\"Main workflow\")\n    .add_node(\n        NodeBuilder(\"task1\")\n        .description(\"Complete task 1\")\n        .uses_prompt(\"task-prompt\")\n        .build()\n    )\n    .entry_node(\"task1\")\n    .build()\n)\nMethods:\n.description(text) - Set workflow description (required)\n.add_node(node) - Add a node to this workflow\n.nodes(*nodes) - Add multiple nodes at once\n.entry_node(name) - Set which node starts the workflow (required)\n.build() - Create the immutable Workflow\nNaming Convention: Workflow names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","nodebuilder#NodeBuilder":"Creates a node (workflow processing step).\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"my-task\")\n    .description(\"What this task accomplishes\")\n    .uses_prompt(\"my-prompt\")  # or uses_module() or uses_tool()\n    .inputs(\"input_data\")\n    .outputs(\"result_data\")\n    .next_nodes(\"next-task\")\n    .build()\n)\nMethods:\n.description(text) - Set the node description (required)\n.uses_module(name) - Set this node to use a module (choose one of uses_*)\n.uses_prompt(name) - Set this node to use a prompt (choose one of uses_*)\n.uses_tool(name) - Set this node to use a tool (choose one of uses_*)\n.inputs(*names) - Define input parameter names (optional)\n.outputs(*names) - Define output parameter names (optional)\n.next_nodes(*names) - Specify which nodes follow this one (optional)\n.build() - Create the immutable Node\nNode Types: Nodes must reference either a module, prompt, or tool. The type is automatically set based on which .uses_*() method you call.Naming Convention: Node names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","modulebuilder#ModuleBuilder":"Creates a reusable module.\nfrom ainalyn import ModuleBuilder\nmodule = (\n    ModuleBuilder(\"http-client\")\n    .description(\"HTTP request module\")\n    .input_schema({\"type\": \"object\", \"properties\": {...}})\n    .output_schema({\"type\": \"object\", \"properties\": {...}})\n    .build()\n)\nMethods:\n.description(text) - Set module description\n.input_schema(schema) - Define input JSON Schema\n.output_schema(schema) - Define output JSON Schema\n.build() - Create the Module","promptbuilder#PromptBuilder":"Creates an LLM prompt template.\nfrom ainalyn import PromptBuilder\nprompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a greeting message\")\n    .template(\"Hello {{name}}! Welcome to {{location}}.\")\n    .variables(\"name\", \"location\")\n    .build()\n)\nMethods:\n.description(text) - Set prompt description (required)\n.template(text) - Set prompt template with {{variable}} placeholders (required)\n.variables(*names) - List variable names used in template (optional)\n.build() - Create the immutable Prompt\nTemplate Syntax: Use double curly braces {{variable}} for placeholders in the template.Naming Convention: Prompt names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","toolbuilder#ToolBuilder":"Creates a tool definition.\nfrom ainalyn import ToolBuilder\ntool = (\n    ToolBuilder(\"calculator-tool\")\n    .description(\"Performs mathematical calculations\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"expression\": {\"type\": \"string\"}\n        },\n        \"required\": [\"expression\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"result\": {\"type\": \"number\"}\n        }\n    })\n    .build()\n)\nMethods:\n.description(text) - Set tool description (required)\n.input_schema(schema) - Define input JSON Schema (optional)\n.output_schema(schema) - Define output JSON Schema (optional)\n.build() - Create the immutable Tool\nNaming Convention: Tool names must start with lowercase letter and contain only lowercase letters, numbers, and hyphens","common-patterns#Common Patterns":"Always call .build()\n# Correct\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\").build()\n# Wrong - missing .build()\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\")\nChain methods\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_workflow(workflow)\n    .build()\n)\nSequential workflow with next_nodes\nprompt1 = PromptBuilder(\"prompt1\").description(\"First\").template(\"Step 1\").build()\nprompt2 = PromptBuilder(\"prompt2\").description(\"Second\").template(\"Step 2\").build()\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Sequential processing\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First step\")\n        .uses_prompt(\"prompt1\")\n        .next_nodes(\"step2\")  # Points to next step\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second step\")\n        .uses_prompt(\"prompt2\")\n        .build()\n    )\n    .entry_node(\"step1\")  # Start at step1\n    .build()\n)\nBranching workflow\n# Node that splits into multiple paths\nworkflow = (\n    WorkflowBuilder(\"branching\")\n    .description(\"Branching workflow\")\n    .add_node(\n        NodeBuilder(\"analyze\")\n        .description(\"Analyze input\")\n        .uses_module(\"analyzer\")\n        .next_nodes(\"path-a\", \"path-b\")  # Multiple next nodes\n        .build()\n    )\n    .add_node(NodeBuilder(\"path-a\").description(\"Path A\").uses_prompt(\"prompt-a\").build())\n    .add_node(NodeBuilder(\"path-b\").description(\"Path B\").uses_prompt(\"prompt-b\").build())\n    .entry_node(\"analyze\")\n    .build()\n)"}},"/v1/api-reference/cli":{"title":"Command Line Interface","data":{"":"The ainalyn CLI provides commands for validating and compiling agents.","installation#Installation":"The CLI is installed automatically with the SDK:\npip install ainalyn-sdk","commands#Commands":"","validate#validate":"Validates an agent definition file.\nainalyn validate agent.py\nArguments:\nfile - Path to Python file containing an AgentDefinition\nExample:\n# agent.py\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nprompt = PromptBuilder(\"my-prompt\").description(\"Test\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\n$ ainalyn validate agent.py\nValidation successful","compile#compile":"Compiles an agent definition to YAML.\nainalyn compile agent.py -o output.yaml\nArguments:\nfile - Path to Python file\n-o, --output - Output YAML file path (required)\nExample:\n$ ainalyn compile agent.py -o my_agent.yaml\nCompiled successfully to my_agent.yaml","--version#--version":"Shows the SDK version.\nainalyn --version","exit-codes#Exit Codes":"0 - Success\n1 - Validation or compilation failed\n2 - File not found or invalid","common-workflows#Common Workflows":"Validate before deploying:\nainalyn validate agent.py && echo \"Ready to deploy!\"\nCompile multiple agents:\nainalyn compile agent1.py -o agent1.yaml\nainalyn compile agent2.py -o agent2.yaml"}},"/v1/api-reference/entities":{"title":"Entities","data":{"":"Core domain entities represent the structure of agent definitions.","agentdefinition#AgentDefinition":"The complete agent specification.Attributes:\nname (str) - Unique agent identifier (lowercase, hyphens only)\nversion (str) - Version string (e.g., \"1.0.0\")\ndescription (str) - What the agent does\nworkflows (tuple) - List of workflows (required, at least one)\nmodules (tuple) - Reusable modules (optional)\nprompts (tuple) - LLM prompt templates (optional)\ntools (tuple) - External tool definitions (optional)\nExample:\nfrom ainalyn.domain.entities import AgentDefinition\nagent = AgentDefinition(\n    name=\"my-agent\",\n    version=\"1.0.0\",\n    description=\"Does something useful\",\n    workflows=(workflow,),\n    modules=(),\n    prompts=(),\n    tools=()\n)\nNote: Usually created via AgentBuilder, not directly.","workflow#Workflow":"A task execution flow.Attributes:\nname (str) - Workflow identifier\ndescription (str) - What this workflow does (optional)\nentry_node (str) - Which node starts the workflow\nnodes (tuple) - List of nodes in this workflow\nExample:\nfrom ainalyn.domain.entities import Workflow\nworkflow = Workflow(\n    name=\"main\",\n    description=\"Main workflow\",\n    entry_node=\"start\",\n    nodes=(node1, node2)\n)","node#Node":"A single task unit within a workflow.Attributes:\nname (str) - Node identifier\ngoal (str) - What this node should accomplish\ndescription (str) - Additional details (optional)\nnode_type (NodeType) - Type: TASK, MODULE, or SUBWORKFLOW\noutputs (tuple) - Output variable names (optional)\ndependencies (tuple) - Names of nodes this depends on (optional)\nreference (str) - Reference to module/workflow (optional)\nExample:\nfrom ainalyn.domain.entities import Node, NodeType\nnode = Node(\n    name=\"process-data\",\n    goal=\"Process the input data\",\n    description=\"Cleans and validates data\",\n    node_type=NodeType.TASK,\n    outputs=(\"cleaned_data\",),\n    dependencies=(\"load-data\",),\n    reference=None\n)","nodetype#NodeType":"Enum for node types.Values:\nNodeType.TASK - A task node\nNodeType.MODULE - References a module\nNodeType.SUBWORKFLOW - References another workflow\nExample:\nfrom ainalyn.domain.entities import NodeType\n# Use in node creation\nnode_type = NodeType.TASK","module#Module":"A reusable capability unit.Attributes:\nname (str) - Module identifier\ndescription (str) - What this module does\ninput_schema (dict) - JSON Schema for inputs (optional)\noutput_schema (dict) - JSON Schema for outputs (optional)\nExample:\nfrom ainalyn.domain.entities import Module\nmodule = Module(\n    name=\"http-client\",\n    description=\"Makes HTTP requests\",\n    input_schema={\"type\": \"object\", \"properties\": {\"url\": {\"type\": \"string\"}}},\n    output_schema={\"type\": \"object\", \"properties\": {\"body\": {\"type\": \"string\"}}}\n)","prompt#Prompt":"An LLM prompt template.Attributes:\nname (str) - Prompt identifier\ntemplate (str) - Prompt text with placeholders\nExample:\nfrom ainalyn.domain.entities import Prompt\nprompt = Prompt(\n    name=\"greeting\",\n    template=\"Hello {name}, welcome to {place}!\"\n)","tool#Tool":"An external tool definition.Attributes:\nname (str) - Tool identifier\ndescription (str) - What this tool does\nExample:\nfrom ainalyn.domain.entities import Tool\ntool = Tool(\n    name=\"calculator\",\n    description=\"Performs mathematical operations\"\n)","immutability#Immutability":"All entities are frozen dataclasses - they cannot be modified after creation.\n# Create new entity\nagent = AgentDefinition(name=\"my-agent\", ...)\n# Cannot modify\nagent.name = \"new-name\"  # Error!\n# Create new version instead\nagent_v2 = AgentDefinition(name=\"new-name\", ...)","creating-entities#Creating Entities":"Direct creation (advanced):\nfrom ainalyn.domain.entities import AgentDefinition, Workflow, Node\nagent = AgentDefinition(...)\nUsing builders (recommended):\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_workflow(...)\n    .build()\n)\nBuilders are easier and include validation."}},"/v1/getting-started/installation":{"title":"Installation","data":{"requirements#Requirements":"Python 3.11, 3.12, or 3.13\npip","install-from-pypi#Install from PyPI":"pip install ainalyn-sdk","install-from-source#Install from Source":"For development:\ngit clone https://github.com/CoreNovus/ainalyn-sdk.git\ncd ainalyn-sdk\npip install -e \".[dev]\"","verify-installation#Verify Installation":"Check the SDK is installed:\nainalyn --version\nTest Python import:\npython -c \"import ainalyn; print('OK')\"","next-steps#Next Steps":"Quickstart - 5-minute tutorial\nYour First Agent - Detailed walkthrough","need-help#Need Help?":"Report issues\nAsk questions"}},"/v1/getting-started/quickstart":{"title":"Quickstart","data":{"":"Build your first agent in 5 minutes.","install#Install":"pip install ainalyn-sdk","create-an-agent#Create an Agent":"Create my_agent.py:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate, export_yaml\n# Define a prompt\ngreeting_prompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a personalized greeting\")\n    .template(\"Generate a personalized greeting for {{user_name}}\")\n    .variables(\"user_name\")\n    .build()\n)\n# Define the agent\nagent = (\n    AgentBuilder(\"greeting-agent\")\n    .description(\"Generates personalized greetings\")\n    .version(\"1.0.0\")\n    .add_prompt(greeting_prompt)\n    .add_workflow(\n        WorkflowBuilder(\"greet-user\")\n        .description(\"Main greeting workflow\")\n        .add_node(\n            NodeBuilder(\"generate-greeting\")\n            .description(\"Generate a personalized greeting\")\n            .uses_prompt(\"greeting-prompt\")\n            .outputs(\"greeting\")\n            .build()\n        )\n        .entry_node(\"generate-greeting\")\n        .build()\n    )\n    .build()\n)\n# Validate\nvalidate(agent)\nprint(\"Valid!\")\n# Export to YAML\nyaml_output = export_yaml(agent)\nprint(yaml_output)","run#Run":"python my_agent.py\nOutput:\nValid!\n# Ainalyn Agent Definition\n# This file is a description submitted to Platform Core for review.\n# It does NOT execute by itself. Execution is handled by Platform Core.\n#\n# Local compilation does NOT equal platform execution.\nname: greeting-agent\nversion: 1.0.0\ndescription: Generates personalized greetings\nworkflows:\n- name: greet-user\n  description: Main greeting workflow\n  entry_node: generate-greeting\n  nodes:\n  - name: generate-greeting\n    description: Generate a personalized greeting\n    type: prompt\n    reference: greeting-prompt\n    outputs:\n    - greeting\nprompts:\n- name: greeting-prompt\n  description: Generates a personalized greeting\n  template: Generate a personalized greeting for {{user_name}}\n  variables:\n  - user_name","whats-happening#What's Happening":"PromptBuilder creates a prompt template\nAgentBuilder creates an agent\nWorkflowBuilder adds a workflow with entry_node\nNodeBuilder adds a task node that uses the prompt\nvalidate() checks the definition\nexport_yaml() converts to YAML","next-steps#Next Steps":"Build a more complex agent\nUnderstand platform boundaries\nExplore the API","using-the-cli#Using the CLI":"You can also use the command line:\n# Validate\nainalyn validate my_agent.py\n# Compile to YAML\nainalyn compile my_agent.py -o output.yaml","common-patterns#Common Patterns":"Multiple nodes with flow:\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Sequential processing workflow\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First step\")\n        .uses_prompt(\"step1-prompt\")\n        .next_nodes(\"step2\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second step\")\n        .uses_prompt(\"step2-prompt\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)\nMultiple workflows:\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow1)\n    .add_workflow(workflow2)\n    .build()\n)","need-help#Need Help?":"Full tutorial\nAPI reference\nReport issues"}},"/v1/getting-started/your-first-agent":{"title":"Your First Agent","data":{"":"Build a complete agent step by step.","what-well-build#What We'll Build":"A research assistant that:\nSearches for information\nAnalyzes findings\nGenerates a report","step-1-create-the-prompts-and-modules#Step 1: Create the Prompts and Modules":"from ainalyn import ModuleBuilder, PromptBuilder\n# Module for search\nsearch_module = (\n    ModuleBuilder(\"search-module\")\n    .description(\"Searches for relevant information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\"query\": {\"type\": \"string\"}},\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\"results\": {\"type\": \"array\"}},\n    })\n    .build()\n)\n# Prompt for analysis\nanalyze_prompt = (\n    PromptBuilder(\"analyze-prompt\")\n    .description(\"Analyzes collected information\")\n    .template(\"Analyze the following information: {{search_results}}\")\n    .variables(\"search_results\")\n    .build()\n)\n# Prompt for report generation\nreport_prompt = (\n    PromptBuilder(\"report-prompt\")\n    .description(\"Generates a structured research report\")\n    .template(\"Create a report based on: {{analysis}}\")\n    .variables(\"analysis\")\n    .build()\n)","step-2-create-the-nodes#Step 2: Create the Nodes":"from ainalyn import NodeBuilder\n# Node 1: Search\nsearch_node = (\n    NodeBuilder(\"search-information\")\n    .description(\"Search and collect relevant information\")\n    .uses_module(\"search-module\")\n    .inputs(\"query\")\n    .outputs(\"search_results\")\n    .next_nodes(\"analyze-findings\")\n    .build()\n)\n# Node 2: Analyze (follows search)\nanalyze_node = (\n    NodeBuilder(\"analyze-findings\")\n    .description(\"Analyze the collected information\")\n    .uses_prompt(\"analyze-prompt\")\n    .inputs(\"search_results\")\n    .outputs(\"analysis\")\n    .next_nodes(\"generate-report\")\n    .build()\n)\n# Node 3: Report (follows analyze)\nreport_node = (\n    NodeBuilder(\"generate-report\")\n    .description(\"Create a structured research report\")\n    .uses_prompt(\"report-prompt\")\n    .inputs(\"analysis\")\n    .outputs(\"report\")\n    .build()\n)\nFlow: search → analyze → report","step-3-create-the-workflow#Step 3: Create the Workflow":"from ainalyn import WorkflowBuilder\nresearch_workflow = (\n    WorkflowBuilder(\"conduct-research\")\n    .description(\"Research and reporting workflow\")\n    .add_node(search_node)\n    .add_node(analyze_node)\n    .add_node(report_node)\n    .entry_node(\"search-information\")\n    .build()\n)","step-4-create-the-agent#Step 4: Create the Agent":"from ainalyn import AgentBuilder\nresearch_agent = (\n    AgentBuilder(\"research-assistant\")\n    .description(\"Searches, analyzes, and reports on topics\")\n    .version(\"1.0.0\")\n    .add_module(search_module)\n    .add_prompt(analyze_prompt)\n    .add_prompt(report_prompt)\n    .add_workflow(research_workflow)\n    .build()\n)","step-5-validate-and-export#Step 5: Validate and Export":"from ainalyn.api import validate, export_yaml\n# Validate\nresult = validate(research_agent)\nif result.is_valid:\n    print(\"Valid!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error.message}\")\n# Export\nyaml_output = export_yaml(research_agent)\n# Save to file\nwith open(\"research_assistant.yaml\", \"w\", encoding=\"utf-8\") as f:\n    f.write(yaml_output)","complete-code#Complete Code":"research_agent.py:\nfrom ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    ModuleBuilder,\n    PromptBuilder,\n)\nfrom ainalyn.api import validate, export_yaml\n# Create resources\nsearch_module = (\n    ModuleBuilder(\"search-module\")\n    .description(\"Searches for relevant information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\"query\": {\"type\": \"string\"}},\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\"results\": {\"type\": \"array\"}},\n    })\n    .build()\n)\nanalyze_prompt = (\n    PromptBuilder(\"analyze-prompt\")\n    .description(\"Analyzes collected information\")\n    .template(\"Analyze the following information: {{search_results}}\")\n    .variables(\"search_results\")\n    .build()\n)\nreport_prompt = (\n    PromptBuilder(\"report-prompt\")\n    .description(\"Generates a structured research report\")\n    .template(\"Create a report based on: {{analysis}}\")\n    .variables(\"analysis\")\n    .build()\n)\n# Create nodes\nsearch_node = (\n    NodeBuilder(\"search-information\")\n    .description(\"Search and collect relevant information\")\n    .uses_module(\"search-module\")\n    .inputs(\"query\")\n    .outputs(\"search_results\")\n    .next_nodes(\"analyze-findings\")\n    .build()\n)\nanalyze_node = (\n    NodeBuilder(\"analyze-findings\")\n    .description(\"Analyze the collected information\")\n    .uses_prompt(\"analyze-prompt\")\n    .inputs(\"search_results\")\n    .outputs(\"analysis\")\n    .next_nodes(\"generate-report\")\n    .build()\n)\nreport_node = (\n    NodeBuilder(\"generate-report\")\n    .description(\"Create a structured research report\")\n    .uses_prompt(\"report-prompt\")\n    .inputs(\"analysis\")\n    .outputs(\"report\")\n    .build()\n)\n# Create workflow\nresearch_workflow = (\n    WorkflowBuilder(\"conduct-research\")\n    .description(\"Research and reporting workflow\")\n    .add_node(search_node)\n    .add_node(analyze_node)\n    .add_node(report_node)\n    .entry_node(\"search-information\")\n    .build()\n)\n# Create agent\nresearch_agent = (\n    AgentBuilder(\"research-assistant\")\n    .description(\"Searches, analyzes, and reports on topics\")\n    .version(\"1.0.0\")\n    .add_module(search_module)\n    .add_prompt(analyze_prompt)\n    .add_prompt(report_prompt)\n    .add_workflow(research_workflow)\n    .build()\n)\n# Validate and export\nresult = validate(research_agent)\nif result.is_valid:\n    yaml_output = export_yaml(research_agent)\n    with open(\"research_assistant.yaml\", \"w\", encoding=\"utf-8\") as f:\n        f.write(yaml_output)\n    print(\"Agent created and saved!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error.message}\")","run-it#Run It":"python research_agent.py","the-generated-yaml#The Generated YAML":"name: research-assistant\nversion: 1.0.0\ndescription: Searches, analyzes, and reports on topics\nworkflows:\n- name: conduct-research\n  description: Research and reporting workflow\n  entry_node: search-information\n  nodes:\n  - name: search-information\n    description: Search and collect relevant information\n    type: module\n    reference: search-module\n    next_nodes:\n    - analyze-findings\n    inputs:\n    - query\n    outputs:\n    - search_results\n  - name: analyze-findings\n    description: Analyze the collected information\n    type: prompt\n    reference: analyze-prompt\n    next_nodes:\n    - generate-report\n    inputs:\n    - search_results\n    outputs:\n    - analysis\n  - name: generate-report\n    description: Create a structured research report\n    type: prompt\n    reference: report-prompt\n    inputs:\n    - analysis\n    outputs:\n    - report\nmodules:\n- name: search-module\n  description: Searches for relevant information\n  input_schema:\n    type: object\n    properties:\n      query:\n        type: string\n    required:\n    - query\n  output_schema:\n    type: object\n    properties:\n      results:\n        type: array\nprompts:\n- name: analyze-prompt\n  description: Analyzes collected information\n  template: 'Analyze the following information: {{search_results}}'\n  variables:\n  - search_results\n- name: report-prompt\n  description: Generates a structured research report\n  template: 'Create a report based on: {{analysis}}'\n  variables:\n  - analysis","key-concepts#Key Concepts":"Workflow Flow\nUse .next_nodes() to define the next steps in the flow\nSet .entry_node() on the workflow to specify where it starts\nNodes reference resources (modules, prompts, tools) via .uses_*()\nBuilder Pattern\nAlways call .build() at the end\nMethods return self for chaining\nImmutable entities created on .build()\nBottom-Up Construction\nBuild resources first (modules, prompts, tools)\nBuild nodes that reference those resources\nAdd nodes to workflow with entry_node\nAdd resources and workflows to agent","common-mistakes#Common Mistakes":"Forgetting .build()\n# Wrong\nnode = NodeBuilder(\"task\").description(\"Do something\")\n# Correct\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\").build()\nCircular flow\n# Wrong (A points to B, B points to A)\nnode_a = NodeBuilder(\"a\").description(\"A\").uses_prompt(\"prompt-a\").next_nodes(\"b\").build()\nnode_b = NodeBuilder(\"b\").description(\"B\").uses_prompt(\"prompt-b\").next_nodes(\"a\").build()\nNot setting entry_node\n# Wrong\nworkflow = WorkflowBuilder(\"main\").add_node(node).build()\n# Correct\nworkflow = WorkflowBuilder(\"main\").add_node(node).entry_node(\"node-name\").build()\nInvalid names\n# Wrong\nAgentBuilder(\"My Agent\")   # No spaces\nAgentBuilder(\"MyAgent\")    # Must start with lowercase\n# Correct (use lowercase with hyphens)\nAgentBuilder(\"my-agent\")\nAgentBuilder(\"research-assistant\")","next-steps#Next Steps":"Platform Boundaries - What the SDK can/cannot do\nAPI Reference - All builder methods\nWorkflows - Advanced workflow patterns\nModules - Create custom modules","need-help#Need Help?":"Quickstart - Simpler example\nAPI docs - Function reference\nIssues - Report bugs"}},"/v1/guides/errors":{"title":"Error Handling","data":{"":"Common errors when building agents and how to fix them.","builder-errors#Builder Errors":"","missingrequiredfielderror#MissingRequiredFieldError":"What it means: You forgot to set a required field before calling .build().\n# Error\nagent = AgentBuilder(\"MyAgent\").build()\n# MissingRequiredFieldError: Required field 'version' is not set\n# Fix\nagent = AgentBuilder(\"MyAgent\").version(\"1.0.0\").build()\nRequired fields:\nAgentBuilder: name, version\nWorkflowBuilder: name\nNodeBuilder: name, goal","invalidvalueerror#InvalidValueError":"What it means: The value doesn't meet the requirements.\n# Error - invalid name format\nagent = AgentBuilder(\"My Agent\").build()\n# InvalidValueError: Invalid value for 'name': 'My Agent'\n# Fix - use valid format\nagent = AgentBuilder(\"MyAgent\").build()\nNaming rules:\nStart with lowercase letter or uppercase letter\nUse letters, numbers, underscores, or hyphens\nNo spaces, no special characters\nValid names:\n\"MyAgent\"        # CamelCase\n\"my_agent\"       # snake_case\n\"agent-v2\"       # With hyphens\n\"agent123\"       # With numbers\nInvalid names:\n\"my agent\"       # Space\n\"my@agent\"       # Special char\n\"123agent\"       # Starts with number","invalidreferenceerror#InvalidReferenceError":"What it means: A node references a module/prompt/tool that doesn't exist.\n# Error\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .description(\"Main workflow\")\n    .add_node(\n        NodeBuilder(\"task1\")\n        .description(\"Task 1\")\n        .uses_module(\"http-client\")  # Module doesn't exist!\n        .build()\n    )\n    .entry_node(\"task1\")\n    .build()\n)\n# Fix - define the module first\nmodule = ModuleBuilder(\"http-client\").build()\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")\n    .add_module(module)  # Add module to agent\n    .add_workflow(workflow)\n    .build()\n)","duplicatenameerror#DuplicateNameError":"What it means: Two items have the same name in the same scope.\n# Error - duplicate node names\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task\").goal(\"First\").build())\n    .add_node(NodeBuilder(\"task\").goal(\"Second\").build())  # Duplicate!\n    .build()\n)\n# Fix - use unique names\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task1\").goal(\"First\").build())\n    .add_node(NodeBuilder(\"task2\").goal(\"Second\").build())\n    .build()\n)","emptycollectionerror#EmptyCollectionError":"What it means: A required collection is empty.\n# Error - workflow has no nodes\nworkflow = WorkflowBuilder(\"main\").build()\n# EmptyCollectionError: Workflow 'main' has no nodes\n# Fix - add at least one node\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task1\").goal(\"Do something\").build())\n    .build()\n)","validation-errors#Validation Errors":"","circulardependencyerror#CircularDependencyError":"What it means: Nodes depend on each other in a loop.\n# Error - A depends on B, B depends on A\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"A\").goal(\"Task A\").depends_on(\"B\").build())\n    .add_node(NodeBuilder(\"B\").goal(\"Task B\").depends_on(\"A\").build())\n    .build()\n)\n# ValidationError: Circular dependency detected: A → B → A\n# Fix - remove the circular dependency\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"A\").goal(\"Task A\").build())\n    .add_node(NodeBuilder(\"B\").goal(\"Task B\").depends_on(\"A\").build())\n    .build()\n)","invaliddependencyerror#InvalidDependencyError":"What it means: A node depends on a non-existent node.\n# Error\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(\n        NodeBuilder(\"task1\")\n        .goal(\"Do something\")\n        .depends_on(\"task0\")  # task0 doesn't exist!\n        .build()\n    )\n    .build()\n)\n# Fix - ensure dependency exists\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task0\").goal(\"First task\").build())\n    .add_node(\n        NodeBuilder(\"task1\")\n        .goal(\"Do something\")\n        .depends_on(\"task0\")  # Now it exists\n        .build()\n    )\n    .build()\n)","catching-errors#Catching Errors":"","try-catch-pattern#Try-Catch Pattern":"from ainalyn import AgentBuilder, BuilderError\nfrom ainalyn.api import validate\ntry:\n    agent = (\n        AgentBuilder(\"MyAgent\")\n        .version(\"1.0.0\")\n        .build()\n    )\n    validate(agent)\n    print(\"Success!\")\nexcept BuilderError as e:\n    print(f\"Build error: {e.message}\")\nexcept Exception as e:\n    print(f\"Error: {e}\")","specific-error-types#Specific Error Types":"from ainalyn import (\n    MissingRequiredFieldError,\n    InvalidValueError,\n    DuplicateNameError\n)\ntry:\n    agent = AgentBuilder(\"MyAgent\").build()\nexcept MissingRequiredFieldError as e:\n    print(f\"Missing: {e.field_name}\")\n    print(f\"In: {e.builder_type}\")\nexcept InvalidValueError as e:\n    print(f\"Invalid {e.field_name}: {e.value}\")\n    print(f\"Rule: {e.constraint}\")\nexcept DuplicateNameError as e:\n    print(f\"Duplicate {e.entity_type}: {e.name}\")","common-patterns#Common Patterns":"","progressive-building#Progressive Building":"Build complex agents step-by-step to catch errors early:\n# Create nodes first\nnode1 = NodeBuilder(\"task1\").goal(\"First task\").build()\nnode2 = NodeBuilder(\"task2\").goal(\"Second task\").depends_on(\"task1\").build()\n# Create workflow\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(node1)\n    .add_node(node2)\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nvalidate(agent)","validation-before-export#Validation Before Export":"Always validate before exporting:\nfrom ainalyn.api import validate, export_yaml\ntry:\n    # Validate first\n    validate(agent)\n    # Then export\n    yaml_output = export_yaml(agent)\n    # Save to file\n    with open(\"agent.yaml\", \"w\") as f:\n        f.write(yaml_output)\n    print(\"Exported successfully!\")\nexcept Exception as e:\n    print(f\"Failed: {e}\")","quick-reference#Quick Reference":"Error\tCause\tFix\tMissingRequiredFieldError\tForgot to set field\tCall .field(value)\tInvalidValueError\tWrong value format\tUse valid format\tInvalidReferenceError\tReference doesn't exist\tDefine the resource first\tDuplicateNameError\tSame name used twice\tUse unique names\tEmptyCollectionError\tEmpty nodes/workflows\tAdd at least one item\tCircularDependencyError\tCircular dependencies\tRemove the loop","getting-help#Getting Help":"If you encounter an error not listed here:\nRead the error message carefully\nCheck the API reference\nReview the validation guide\nReport an issue"}},"/v1/guides/modules":{"title":"Modules","data":{"":"How to define reusable capability units for your agents.","what-is-a-module#What is a Module?":"A module is a self-contained functional component that can perform specific tasks. It defines:\nWhat it does (description)\nWhat input it expects (input schema)\nWhat output it produces (output schema)\nImportant: The SDK only defines the module's contract. The actual implementation is provided by the platform.","creating-a-module#Creating a Module":"from ainalyn import ModuleBuilder\nmodule = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Fetches data from HTTP endpoints\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\"]}\n        },\n        \"required\": [\"url\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\"type\": \"integer\"},\n            \"body\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","using-modules-in-workflows#Using Modules in Workflows":"Step 1: Define the module\nhttp_module = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Fetches data from HTTP endpoints\")\n    .input_schema({...})\n    .output_schema({...})\n    .build()\n)\nStep 2: Add module to agent\nagent = (\n    AgentBuilder(\"data-agent\")\n    .version(\"1.0.0\")\n    .add_module(http_module)  # Register module\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"fetch-data\")\n    .description(\"Fetch user data\")\n    .uses_module(\"http-client\")  # References the module\n    .inputs(\"url\")\n    .outputs(\"response\")\n    .build()\n)","json-schema#JSON Schema":"Modules use JSON Schema to define input/output contracts.Basic types:\n# String\n{\"type\": \"string\"}\n# Number\n{\"type\": \"number\"}\n# Integer\n{\"type\": \"integer\"}\n# Boolean\n{\"type\": \"boolean\"}\n# Array\n{\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n# Object\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}\nRequired fields:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"url\": {\"type\": \"string\"},\n        \"timeout\": {\"type\": \"integer\"}\n    },\n    \"required\": [\"url\"]  # url is required, timeout is optional\n}\nDefault values:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"method\": {\n            \"type\": \"string\",\n            \"default\": \"GET\"  # Default if not provided\n        }\n    }\n}\nEnums:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"enum\": [\"active\", \"inactive\", \"pending\"]\n        }\n    }\n}","common-module-patterns#Common Module Patterns":"","http-client#HTTP Client":"http_module = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Makes HTTP requests\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"string\"}\n        },\n        \"required\": [\"url\", \"method\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\"type\": \"integer\"},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","data-processor#Data Processor":"processor = (\n    ModuleBuilder(\"data-processor\")\n    .description(\"Processes and transforms data\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"data\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n            \"operation\": {\"type\": \"string\", \"enum\": [\"filter\", \"map\", \"reduce\"]}\n        },\n        \"required\": [\"data\", \"operation\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"result\": {\"type\": \"array\"},\n            \"count\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","file-operations#File Operations":"file_module = (\n    ModuleBuilder(\"file-handler\")\n    .description(\"Reads and writes files\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"path\": {\"type\": \"string\"},\n            \"operation\": {\"type\": \"string\", \"enum\": [\"read\", \"write\"]},\n            \"content\": {\"type\": \"string\"}\n        },\n        \"required\": [\"path\", \"operation\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"success\": {\"type\": \"boolean\"},\n            \"content\": {\"type\": \"string\"},\n            \"size\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","module-naming#Module Naming":"Valid names:\n\"http-client\"        # Lowercase with hyphens\n\"data-processor\"     # Descriptive\n\"file-handler-v2\"    # With version suffix\nInvalid names:\n\"HttpClient\"         # Must be lowercase\n\"data_processor\"     # No underscores\n\"my module\"          # No spaces","best-practices#Best Practices":"1. Keep schemas simple\n# Simple, focused schema\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"url\": {\"type\": \"string\"}\n    },\n    \"required\": [\"url\"]\n}\n# Avoid overly complex nested schemas\n2. Use descriptive property names\n# Clear property names\n{\n    \"properties\": {\n        \"user_id\": {\"type\": \"string\"},\n        \"email_address\": {\"type\": \"string\"}\n    }\n}\n# Avoid unclear names like \"id\" or \"data\"\n3. Document expected formats\n# Specify format\n{\n    \"properties\": {\n        \"email\": {\"type\": \"string\", \"format\": \"email\"},\n        \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n        \"date\": {\"type\": \"string\", \"format\": \"date\"}\n    }\n}\n4. Define required fields\n# Explicit required fields\n{\n    \"properties\": {\n        \"id\": {\"type\": \"string\"},\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    },\n    \"required\": [\"id\", \"name\"]  # age is optional\n}","module-vs-prompt-vs-tool#Module vs Prompt vs Tool":"Use Module when:\nYou need custom business logic\nPlatform provides the implementation\nInput/output are structured data\nUse Prompt when:\nYou need LLM-based reasoning\nInput/output are text-based\nSee Prompts Guide\nUse Tool when:\nYou need external services (APIs, databases)\nPlatform provides the integration\nSee Tools Guide","complete-example#Complete Example":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, ModuleBuilder, NodeType\n# Define module\nemail_module = (\n    ModuleBuilder(\"email-sender\")\n    .description(\"Sends emails via SMTP\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"to\": {\"type\": \"string\", \"format\": \"email\"},\n            \"subject\": {\"type\": \"string\"},\n            \"body\": {\"type\": \"string\"}\n        },\n        \"required\": [\"to\", \"subject\", \"body\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"sent\": {\"type\": \"boolean\"},\n            \"message_id\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"send-notification\")\n    .entry_node(\"send\")\n    .add_node(\n        NodeBuilder(\"send\")\n        .description(\"Send email notification\")\n        .uses_module(\"email-sender\")  # Reference module\n        .inputs(\"to\", \"subject\", \"body\")\n        .outputs(\"sent\", \"message_id\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"notification-agent\")\n    .version(\"1.0.0\")\n    .description(\"Sends email notifications\")\n    .add_module(email_module)  # Register module\n    .add_workflow(workflow)\n    .build()\n)","see-also#See Also":"ModuleBuilder API - Full API reference\nPrompts Guide - Using prompt templates\nTools Guide - External tool integration\nWorkflows - Using modules in workflows"}},"/v1/guides/tools":{"title":"Tools","data":{"":"How to define external tool interfaces for your agents.","what-is-a-tool#What is a Tool?":"A tool represents an external capability that your agent can invoke. It defines:\nWhat it does (description)\nWhat input it expects (input schema)\nWhat output it produces (output schema)\nImportant: The SDK only defines the tool's interface contract. The platform provides the actual implementation.","creating-a-tool#Creating a Tool":"from ainalyn import ToolBuilder\ntool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"max_results\": {\"type\": \"integer\", \"default\": 10}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"title\": {\"type\": \"string\"},\n                        \"url\": {\"type\": \"string\"},\n                        \"snippet\": {\"type\": \"string\"}\n                    }\n                }\n            }\n        }\n    })\n    .build()\n)","using-tools-in-workflows#Using Tools in Workflows":"Step 1: Define the tool\nsearch_tool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web\")\n    .input_schema({...})\n    .output_schema({...})\n    .build()\n)\nStep 2: Add tool to agent\nagent = (\n    AgentBuilder(\"research-agent\")\n    .version(\"1.0.0\")\n    .add_tool(search_tool)  # Register tool\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"search\")\n    .description(\"Search for information\")\n    .uses_tool(\"web-search\")  # References the tool\n    .inputs(\"query\")\n    .outputs(\"results\")\n    .build()\n)","common-tool-patterns#Common Tool Patterns":"","web-search#Web Search":"search = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"language\": {\"type\": \"string\", \"default\": \"en\"},\n            \"safe_search\": {\"type\": \"boolean\", \"default\": True}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n            \"total_count\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","database-query#Database Query":"db_query = (\n    ToolBuilder(\"database-query\")\n    .description(\"Executes SQL queries on database\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"parameters\": {\"type\": \"array\"},\n            \"timeout\": {\"type\": \"integer\", \"default\": 30}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"rows\": {\"type\": \"array\"},\n            \"row_count\": {\"type\": \"integer\"},\n            \"execution_time\": {\"type\": \"number\"}\n        }\n    })\n    .build()\n)","file-operations#File Operations":"file_writer = (\n    ToolBuilder(\"file-writer\")\n    .description(\"Writes content to files\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"path\": {\"type\": \"string\"},\n            \"content\": {\"type\": \"string\"},\n            \"encoding\": {\"type\": \"string\", \"default\": \"utf-8\"},\n            \"append\": {\"type\": \"boolean\", \"default\": False}\n        },\n        \"required\": [\"path\", \"content\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"success\": {\"type\": \"boolean\"},\n            \"bytes_written\": {\"type\": \"integer\"},\n            \"file_path\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","email-sender#Email Sender":"email_sender = (\n    ToolBuilder(\"email-sender\")\n    .description(\"Sends emails via SMTP\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"to\": {\"type\": \"array\", \"items\": {\"type\": \"string\", \"format\": \"email\"}},\n            \"subject\": {\"type\": \"string\"},\n            \"body\": {\"type\": \"string\"},\n            \"attachments\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n        },\n        \"required\": [\"to\", \"subject\", \"body\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"sent\": {\"type\": \"boolean\"},\n            \"message_id\": {\"type\": \"string\"},\n            \"recipients\": {\"type\": \"array\"}\n        }\n    })\n    .build()\n)","api-client#API Client":"api_client = (\n    ToolBuilder(\"rest-api-client\")\n    .description(\"Makes REST API calls\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"endpoint\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"object\"}\n        },\n        \"required\": [\"endpoint\", \"method\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status_code\": {\"type\": \"integer\"},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"object\"}\n        }\n    })\n    .build()\n)","tool-naming#Tool Naming":"Valid names:\n\"web-search\"          # Lowercase with hyphens\n\"file-writer\"         # Descriptive\n\"api-client-v2\"       # With version\nInvalid names:\n\"WebSearch\"           # Must be lowercase\n\"file_writer\"         # No underscores\n\"my tool\"             # No spaces","best-practices#Best Practices":"1. Use descriptive schemas\n# Clear input contract\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"search_query\": {\"type\": \"string\"},\n        \"result_limit\": {\"type\": \"integer\", \"minimum\": 1, \"maximum\": 100}\n    },\n    \"required\": [\"search_query\"]\n}\n2. Provide defaults for optional parameters\n{\n    \"properties\": {\n        \"timeout\": {\"type\": \"integer\", \"default\": 30},\n        \"retry_count\": {\"type\": \"integer\", \"default\": 3},\n        \"encoding\": {\"type\": \"string\", \"default\": \"utf-8\"}\n    }\n}\n3. Use appropriate constraints\n{\n    \"properties\": {\n        \"page_size\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 100,\n            \"default\": 20\n        },\n        \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\"\n        },\n        \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        }\n    }\n}\n4. Document expected behavior\n# Clear description\nToolBuilder(\"cache-manager\")\n    .description(\"Manages in-memory cache with TTL support\")","tool-vs-module-vs-prompt#Tool vs Module vs Prompt":"Use Tool when:\nYou need external services (APIs, databases, web search)\nPlatform provides the integration\nTask involves I/O operations\nUse Module when:\nYou need custom business logic\nTask is computation or data processing\nSee Modules Guide\nUse Prompt when:\nYou need LLM-based reasoning\nTask involves text understanding/generation\nSee Prompts Guide","complete-example#Complete Example":"from ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    ToolBuilder,\n    NodeType\n)\n# Define tool\nsearch_tool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"max_results\": {\"type\": \"integer\", \"default\": 10}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\"type\": \"array\"},\n            \"total_found\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"research\")\n    .entry_node(\"search\")\n    .add_node(\n        NodeBuilder(\"search\")\n        .description(\"Search for research topic\")\n        .uses_tool(\"web-search\")\n        .inputs(\"query\")\n        .outputs(\"results\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"research-agent\")\n    .version(\"1.0.0\")\n    .description(\"Web research assistant\")\n    .add_tool(search_tool)\n    .add_workflow(workflow)\n    .build()\n)","see-also#See Also":"ToolBuilder API - Full API reference\nModules Guide - Custom business logic\nPrompts Guide - LLM templates\nWorkflows - Using tools in workflows"}},"/v1/guides/validation":{"title":"Validation","data":{"":"How validation works and what gets checked.","what-gets-validated#What Gets Validated":"The SDK validates your agent definition before export to ensure it's ready for the platform.Schema Validation:\nRequired fields are present\nNaming conventions are correct\nVersion format is valid (semantic versioning)\nReferences are defined\nStructural Validation:\nWorkflows have at least one node\nEntry nodes exist\nNode references point to valid resources\nAll dependencies are defined","using-validate#Using validate()":"from ainalyn import AgentBuilder, validate\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")\n    .description(\"My first agent\")\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nresult = validate(agent)\nif result.is_valid:\n    print(\"Validation passed!\")\nelse:\n    print(\"Validation failed:\")\n    for error in result.errors:\n        print(f\"  {error.code}: {error.message}\")","validation-results#Validation Results":"The ValidationResult object contains:Properties:\nis_valid - Boolean indicating if validation passed\nerrors - List of validation errors\nwarnings - List of warnings (optional issues)\nError Details:\nEach error contains:\ncode - Error code (e.g., \"MISSING_AGENT_VERSION\")\npath - Location in the definition (e.g., \"agent.version\")\nmessage - Human-readable description\nseverity - ERROR or WARNING","naming-rules#Naming Rules":"Valid names:\n\"my-agent\"           # Lowercase with hyphens\n\"data-processor-v2\"  # Letters, numbers, hyphens\n\"fetch-data\"         # Starts with letter\nInvalid names:\n\"MyAgent\"      # Must be lowercase\n\"my_agent\"     # No underscores\n\"my agent\"     # No spaces\n\"2-agent\"      # Must start with letter","version-format#Version Format":"Valid versions:\n\"1.0.0\"        # Semantic versioning\n\"2.1.3\"        # Major.minor.patch\n\"0.1.0\"        # Pre-release\nInvalid versions:\n\"1.0\"          # Must have three parts\n\"v1.0.0\"       # No 'v' prefix\n\"1.0.0-beta\"   # No pre-release tags (yet)","common-validation-errors#Common Validation Errors":"","missing_agent_version#MISSING_AGENT_VERSION":"Cause: Forgot to set agent version.\n# Error\nagent = AgentBuilder(\"my-agent\").build()\n# Fix\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()","invalid_workflow_name#INVALID_WORKFLOW_NAME":"Cause: Workflow name doesn't follow naming rules.\n# Error\nworkflow = WorkflowBuilder(\"MyWorkflow\").build()\n# Fix\nworkflow = WorkflowBuilder(\"my-workflow\").build()","missing_workflows#MISSING_WORKFLOWS":"Cause: Agent has no workflows.\n# Error\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\n# Fix\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)","undefined_resource_reference#UNDEFINED_RESOURCE_REFERENCE":"Cause: Node references a resource that doesn't exist.\n# Error - prompt not defined\nnode = (\n    NodeBuilder(\"task\")\n    .description(\"Task node\")\n    .uses_prompt(\"analyzer\")  # No prompt named \"analyzer\"\n    .build()\n)\n# Fix - define the prompt first\nprompt = PromptBuilder(\"analyzer\").template(\"Analyze: {data}\").build()\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_prompt(prompt)  # Add prompt to agent\n    .add_workflow(workflow)\n    .build()\n)","invalid_entry_node#INVALID_ENTRY_NODE":"Cause: Workflow entry_node doesn't exist in nodes.\n# Error\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .entry_node(\"start\")  # No node named \"start\"\n    .add_node(NodeBuilder(\"step1\").goal(\"Do something\").build())\n    .build()\n)\n# Fix\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .entry_node(\"step1\")  # Valid node name\n    .add_node(NodeBuilder(\"step1\").goal(\"Do something\").build())\n    .build()\n)","best-practices#Best Practices":"1. Validate early and often\n# Build progressively, validate at each step\nnode = NodeBuilder(\"task\").goal(\"Process data\").build()\nworkflow = WorkflowBuilder(\"main\").add_node(node).build()\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").add_workflow(workflow).build()\n# Validate before export\nresult = validate(agent)\nif not result.is_valid:\n    print(\"Fix these errors before exporting:\")\n    for error in result.errors:\n        print(f\"  - {error.message}\")\n2. Check validation results\nresult = validate(agent)\n# Don't ignore validation!\nif not result.is_valid:\n    raise ValueError(f\"Invalid agent: {result.errors[0].message}\")\n# Now safe to export\nyaml_output = export_yaml(agent)\n3. Use compile_agent() for safety\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Automatically validates before exporting\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.message}\")","when-validation-happens#When Validation Happens":"Builder validation:\nHappens during .build() call\nChecks required fields\nValidates value formats\nThrows exceptions immediately\nSchema validation:\nHappens when you call validate()\nChecks structural correctness\nReturns ValidationResult\nDoes not throw exceptions\nExample:\n# Builder validation - throws exception\ntry:\n    agent = AgentBuilder(\"Invalid Name!\").build()  # Throws exception\nexcept InvalidValueError as e:\n    print(f\"Builder error: {e.message}\")\n# Schema validation - returns result\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\nresult = validate(agent)  # Returns ValidationResult\nif not result.is_valid:\n    print(f\"Schema error: {result.errors[0].message}\")","see-also#See Also":"Error Handling - Builder errors and how to fix them\nAPI Reference - validate() function details\nBuilders - Builder validation rules"}},"/v1/guides/workflows":{"title":"Workflows","data":{"":"How to structure task flows with nodes and dependencies.","what-is-a-workflow#What is a Workflow?":"A workflow defines the execution flow of tasks in your agent. It's a directed graph where:\nNodes are processing steps\nnext_nodes define execution order\nentry_node is where execution starts","basic-workflow#Basic Workflow":"from ainalyn import WorkflowBuilder, NodeBuilder\nworkflow = (\n    WorkflowBuilder(\"process-data\")\n    .description(\"Fetch and process data\")\n    .add_node(\n        NodeBuilder(\"fetch\")\n        .description(\"Fetch raw data\")\n        .uses_module(\"http-client\")\n        .outputs(\"raw_data\")\n        .next_nodes(\"process\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process the data\")\n        .uses_prompt(\"analyzer\")\n        .inputs(\"raw_data\")\n        .build()\n    )\n    .entry_node(\"fetch\")\n    .build()\n)\nExecution flow: fetch → process","node-dependencies#Node Dependencies":"Dependencies define execution order through next_nodes.Linear flow:\n# A → B → C\nnode_a = (\n    NodeBuilder(\"step-a\")\n    .description(\"First step\")\n    .uses_prompt(\"prompt-a\")\n    .next_nodes(\"step-b\")\n    .build()\n)\nnode_b = (\n    NodeBuilder(\"step-b\")\n    .description(\"Second step\")\n    .uses_prompt(\"prompt-b\")\n    .next_nodes(\"step-c\")\n    .build()\n)\nnode_c = (\n    NodeBuilder(\"step-c\")\n    .description(\"Final step\")\n    .uses_prompt(\"prompt-c\")\n    .build()\n)\nParallel execution:\n# A → [B, C] → D\nnode_a = (\n    NodeBuilder(\"start\")\n    .description(\"Start processing\")\n    .uses_prompt(\"start-prompt\")\n    .next_nodes(\"process-1\", \"process-2\")  # Both run in parallel\n    .build()\n)\nnode_b = (\n    NodeBuilder(\"process-1\")\n    .description(\"First parallel task\")\n    .uses_prompt(\"process-prompt-1\")\n    .next_nodes(\"merge\")\n    .build()\n)\nnode_c = (\n    NodeBuilder(\"process-2\")\n    .description(\"Second parallel task\")\n    .uses_prompt(\"process-prompt-2\")\n    .next_nodes(\"merge\")\n    .build()\n)\nnode_d = (\n    NodeBuilder(\"merge\")\n    .description(\"Merge results\")\n    .uses_prompt(\"merge-prompt\")\n    .build()\n)\nConditional branching:\n# A → [B or C] (decided by platform)\nnode_a = (\n    NodeBuilder(\"analyze\")\n    .description(\"Analyze input\")\n    .uses_module(\"analyzer\")\n    .next_nodes(\"path-a\", \"path-b\")  # Platform decides which path\n    .build()\n)","entry-node#Entry Node":"Every workflow must specify where execution starts.\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .entry_node(\"start\")  # Execution begins here\n    .add_node(\n        NodeBuilder(\"start\")\n        .description(\"Starting point\")\n        .build()\n    )\n    .build()\n)\nRules:\nEntry node must exist in the workflow's nodes\nOnly one entry node per workflow\nEntry node name must match exactly","data-flow#Data Flow":"Nodes pass data using inputs and outputs.\n# Node 1: Produces data\nproducer = (\n    NodeBuilder(\"fetch-user\")\n    .description(\"Fetch user data\")\n    .outputs([\"user_id\", \"user_name\"])  # Outputs these values\n    .next_nodes([\"process\"])\n    .build()\n)\n# Node 2: Consumes data\nconsumer = (\n    NodeBuilder(\"process\")\n    .description(\"Process user data\")\n    .inputs([\"user_id\", \"user_name\"])  # Uses these inputs\n    .outputs([\"result\"])\n    .build()\n)\nNotes:\nInput/output names are descriptive\nPlatform handles actual data passing\nSDK just defines the structure","multiple-workflows#Multiple Workflows":"Agents can have multiple workflows for different tasks.\nfrom ainalyn import AgentBuilder\n# Workflow 1: Data processing\nprocessing_workflow = WorkflowBuilder(\"process-data\").build()\n# Workflow 2: Reporting\nreporting_workflow = WorkflowBuilder(\"generate-report\").build()\n# Agent with both workflows\nagent = (\n    AgentBuilder(\"data-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(processing_workflow)\n    .add_workflow(reporting_workflow)\n    .build()\n)\nEach workflow is independent and can be invoked separately by the platform.","node-types#Node Types":"Uses Prompt - Uses a prompt template\nNodeBuilder(\"analyze\")\n    .description(\"Analyze data\")\n    .uses_prompt(\"analyzer-prompt\")  # References a Prompt\nUses Module - Executes custom logic\nNodeBuilder(\"fetch\")\n    .description(\"Fetch data\")\n    .uses_module(\"http-client\")  # References a Module\nUses Tool - Calls an external tool\nNodeBuilder(\"search\")\n    .description(\"Search web\")\n    .uses_tool(\"web-search\")  # References a Tool\nNote: The node type is automatically determined by which .uses_*() method you call.","common-patterns#Common Patterns":"","sequential-processing#Sequential Processing":"# Step 1 → Step 2 → Step 3\nworkflow = (\n    WorkflowBuilder(\"sequential\")\n    .description(\"Sequential workflow\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First\")\n        .uses_prompt(\"prompt1\")\n        .next_nodes(\"step2\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second\")\n        .uses_prompt(\"prompt2\")\n        .next_nodes(\"step3\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step3\")\n        .description(\"Final\")\n        .uses_prompt(\"prompt3\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)","fan-out-fan-in#Fan-Out, Fan-In":"# One node → Multiple parallel nodes → Merge\nworkflow = (\n    WorkflowBuilder(\"parallel\")\n    .description(\"Parallel workflow\")\n    .add_node(\n        NodeBuilder(\"split\")\n        .description(\"Split work\")\n        .uses_prompt(\"split-prompt\")\n        .next_nodes(\"work1\", \"work2\", \"work3\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work1\")\n        .description(\"Work 1\")\n        .uses_prompt(\"work-prompt-1\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work2\")\n        .description(\"Work 2\")\n        .uses_prompt(\"work-prompt-2\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work3\")\n        .description(\"Work 3\")\n        .uses_prompt(\"work-prompt-3\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"merge\")\n        .description(\"Combine results\")\n        .uses_prompt(\"merge-prompt\")\n        .build()\n    )\n    .entry_node(\"split\")\n    .build()\n)","pipeline-processing#Pipeline Processing":"# Input → Transform → Filter → Output\nworkflow = (\n    WorkflowBuilder(\"pipeline\")\n    .description(\"Pipeline workflow\")\n    .add_node(\n        NodeBuilder(\"input\")\n        .description(\"Read input\")\n        .uses_module(\"input-reader\")\n        .next_nodes(\"transform\")\n        .outputs(\"raw_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"transform\")\n        .description(\"Transform data\")\n        .uses_prompt(\"transform-prompt\")\n        .inputs(\"raw_data\")\n        .next_nodes(\"filter\")\n        .outputs(\"transformed_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"filter\")\n        .description(\"Filter data\")\n        .uses_prompt(\"filter-prompt\")\n        .inputs(\"transformed_data\")\n        .next_nodes(\"output\")\n        .outputs(\"filtered_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"output\")\n        .description(\"Write output\")\n        .uses_module(\"output-writer\")\n        .inputs(\"filtered_data\")\n        .build()\n    )\n    .entry_node(\"input\")\n    .build()\n)","validation-rules#Validation Rules":"Valid workflows:\nAt least one node\nEntry node exists in nodes\nAll next_nodes references exist\nNo circular dependencies (A → B → A)\nInvalid workflows:\n# No nodes\nworkflow = WorkflowBuilder(\"empty\").build()\n# Entry node doesn't exist\nworkflow = (\n    WorkflowBuilder(\"bad\")\n    .entry_node(\"missing\")  # No node named \"missing\"\n    .add_node(NodeBuilder(\"actual\").build())\n    .build()\n)\n# Undefined next_node reference\nnode = (\n    NodeBuilder(\"broken\")\n    .next_nodes([\"nonexistent\"])  # No node named \"nonexistent\"\n    .build()\n)","best-practices#Best Practices":"1. Use descriptive names\n# Clear names\nNodeBuilder(\"fetch-user-data\")\nNodeBuilder(\"validate-email\")\nNodeBuilder(\"send-notification\")\n# Unclear names\nNodeBuilder(\"step1\")\nNodeBuilder(\"process\")\nNodeBuilder(\"do-stuff\")\n2. Define clear data flow\n# Explicit inputs/outputs\nNodeBuilder(\"transform\")\n    .inputs([\"raw_data\"])\n    .outputs([\"clean_data\"])\n# No data flow specified\nNodeBuilder(\"transform\")\n    # Where does data come from?\n3. Keep workflows focused\n# Single responsibility\nprocess_workflow = WorkflowBuilder(\"process-orders\")\nreport_workflow = WorkflowBuilder(\"generate-reports\")\n# Too many responsibilities\neverything_workflow = WorkflowBuilder(\"do-everything\")","see-also#See Also":"Your First Agent - Complete workflow example\nNodeBuilder API - All node options\nValidation - Workflow validation rules"}},"/v1/concepts/architecture-overview":{"title":"Architecture Overview","data":{"":"The Ainalyn SDK is built on Hexagonal Architecture (also known as Ports and Adapters), ensuring clean separation of concerns and maintainability.","high-level-architecture#High-Level Architecture":"┌─────────────────────────────────────────────────────────────┐\n│                     Ainalyn SDK                             │\n│                                                             │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │         Layer 5: Public API & CLI                    │  │\n│  │  api.py, cli.py, __init__.py                         │  │\n│  └──────────────────┬───────────────────────────────────┘  │\n│                     │                                       │\n│  ┌──────────────────▼───────────────────────────────────┐  │\n│  │         Layer 4: Application                         │  │\n│  │  Use Cases, Services                                 │  │\n│  └──────────────────┬───────────────────────────────────┘  │\n│                     │                                       │\n│  ┌──────────────────▼───────────────────────────────────┐  │\n│  │         Layer 3: Adapters                            │  │\n│  │  Primary: Builders, Errors                           │  │\n│  │  Secondary: Validators, Exporters, Analyzers         │  │\n│  └──────────────────┬───────────────────────────────────┘  │\n│                     │                                       │\n│  ┌──────────────────▼───────────────────────────────────┐  │\n│  │         Layer 2: Ports                               │  │\n│  │  Inbound: Builder, Validator, Exporter Protocols     │  │\n│  │  Outbound: Writer, SchemaValidator Protocols         │  │\n│  └──────────────────┬───────────────────────────────────┘  │\n│                     │                                       │\n│  ┌──────────────────▼───────────────────────────────────┐  │\n│  │         Layer 1: Domain                              │  │\n│  │  Entities: AgentDefinition, Workflow, Node, etc.     │  │\n│  │  Rules: DefinitionRules, Validators                  │  │\n│  └──────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘","the-five-layers#The Five Layers":"","layer-1-domain-core-business-logic#Layer 1: Domain (Core Business Logic)":"Location: ainalyn/domain/Purpose: Pure business entities and rules with NO external dependenciesComponents:\nEntities (entities/): Immutable frozen dataclasses\nAgentDefinition - The aggregate root\nWorkflow, Node, Module, Prompt, Tool\nRules (rules/): Domain validation logic\nNaming conventions\nCircular dependency detection\nPlatform boundary enforcement\nKey Characteristics:\nFrozen dataclasses (immutable)\nNo external dependencies\nPure Python types\n100% type-safe\nExample:\n@dataclass(frozen=True)\nclass AgentDefinition:\n    \"\"\"Agent Definition - The aggregate root.\n    NOTE: This is a DESCRIPTION entity, not a runtime implementation.\n    \"\"\"\n    name: str\n    version: str\n    description: str\n    workflows: tuple[Workflow, ...]\n    modules: tuple[Module, ...]\n    prompts: tuple[Prompt, ...]\n    tools: tuple[Tool, ...]","layer-2-ports-interface-definitions#Layer 2: Ports (Interface Definitions)":"Location: ainalyn/ports/Purpose: Define contracts between layers using Python ProtocolsComponents:\nInbound Ports (inbound/): How external world uses the SDK\nBuilder - Interface for building entities\nValidator - Interface for validation\nExporter - Interface for export\nOutbound Ports (outbound/): How SDK uses external services\nWriter - File writing interface\nSchemaValidator - Schema validation interface\nKey Characteristics:\nProtocol-based (duck typing)\nNo implementations\nDependency Inversion Principle\nExample:\nclass Builder(Protocol[T]):\n    \"\"\"Protocol for builder pattern.\"\"\"\n    def build(self) -> T:\n        \"\"\"Build and return the entity.\"\"\"\n        ...","layer-3-adapters-implementations#Layer 3: Adapters (Implementations)":"Location: ainalyn/adapters/Purpose: Implement the port interfacesComponents:\nPrimary Adapters (primary/): Entry points\nAgentBuilder, WorkflowBuilder, NodeBuilder, etc.\nBuilderError, ValidationError\nSecondary Adapters (secondary/): Infrastructure\nYamlExporter - YAML export implementation\nSchemaValidator - JSON Schema validation\nStaticAnalyzer - Code analysis\nKey Characteristics:\nImplements Protocol interfaces\nHandles external interactions\nConverts between layers\nExample:\nclass AgentBuilder:\n    \"\"\"Fluent builder for AgentDefinition.\"\"\"\n    def __init__(self, name: str) -> None:\n        self._name = name\n        self._workflows: list[Workflow] = []\n        # ...\n    def add_workflow(self, workflow: Workflow) -> AgentBuilder:\n        \"\"\"Add a workflow (fluent interface).\"\"\"\n        self._workflows.append(workflow)\n        return self\n    def build(self) -> AgentDefinition:\n        \"\"\"Build the AgentDefinition.\"\"\"\n        return AgentDefinition(\n            name=self._name,\n            workflows=tuple(self._workflows),\n            # ...\n        )","layer-4-application-use-cases--services#Layer 4: Application (Use Cases & Services)":"Location: ainalyn/application/Purpose: Orchestrate domain logic and adaptersComponents:\nDefinitionService - Core service coordinating operations\nUse Cases (use_cases/):\nValidateDefinitionUseCase\nExportDefinitionUseCase\nCompileDefinitionUseCase\nKey Characteristics:\nOrchestrates workflows\nNo business logic (delegates to domain)\nDependency injection\nExample:\nclass DefinitionService:\n    \"\"\"Service for agent definition operations.\"\"\"\n    def __init__(\n        self,\n        validator: Validator,\n        exporter: Exporter,\n    ) -> None:\n        self._validator = validator\n        self._exporter = exporter\n    def compile(self, definition: AgentDefinition) -> str:\n        \"\"\"Validate and export definition.\"\"\"\n        self._validator.validate(definition)\n        return self._exporter.export(definition)","layer-5-public-api--cli#Layer 5: Public API & CLI":"Location: ainalyn/api.py, ainalyn/cli.py, ainalyn/__init__.pyPurpose: Provide convenient entry points for usersComponents:\napi.py - High-level functions (validate(), export_yaml())\ncli.py - Command-line interface\n__init__.py - Public exports\nKey Characteristics:\nUser-friendly interfaces\nMinimal logic (delegates to layers below)\nClear public API\nExample:\n# api.py\ndef validate(definition: AgentDefinition) -> None:\n    \"\"\"Validate an agent definition.\"\"\"\n    service = _get_service()\n    service.validate(definition)\ndef export_yaml(definition: AgentDefinition) -> str:\n    \"\"\"Export definition to YAML.\"\"\"\n    service = _get_service()\n    return service.export_yaml(definition)","dependency-flow#Dependency Flow":"Dependencies always point inward:\nAPI/CLI\n  ↓\nApplication\n  ↓\nAdapters\n  ↓\nPorts (interfaces)\n  ↓\nDomain (pure logic)\nWhy?: The domain layer has zero dependencies, making it:\nEasy to test\nEasy to understand\nEasy to change\nStable and reliable","design-patterns#Design Patterns":"","1-builder-pattern#1. Builder Pattern":"Used for entity construction:\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .description(\"...\")\n    .version(\"1.0.0\")\n    .add_workflow(...)\n    .build()\n)","2-protocol-pattern-interface-segregation#2. Protocol Pattern (Interface Segregation)":"Used for defining interfaces:\nclass Validator(Protocol):\n    def validate(self, definition: AgentDefinition) -> None: ...","3-singleton-pattern#3. Singleton Pattern":"Used for the main service:\n# Module-level singleton\n_service: DefinitionService | None = None\ndef _get_service() -> DefinitionService:\n    global _service\n    if _service is None:\n        _service = DefinitionService(...)\n    return _service","4-immutability-pattern#4. Immutability Pattern":"All entities are frozen:\n@dataclass(frozen=True)\nclass Workflow:\n    name: str\n    nodes: tuple[Node, ...]  # Immutable tuple","5-use-case-pattern#5. Use Case Pattern":"Encapsulates application logic:\nclass ValidateDefinitionUseCase:\n    def execute(self, definition: AgentDefinition) -> None:\n        # Validation logic\n        ...","solid-principles#SOLID Principles":"","single-responsibility-principle-srp#Single Responsibility Principle (SRP)":"Each class/module has one reason to change:\nAgentBuilder: Build agents\nYamlExporter: Export YAML\nDefinitionRules: Validate rules","openclosed-principle-ocp#Open/Closed Principle (OCP)":"Entities are frozen (closed for modification):\n@dataclass(frozen=True)  # Cannot be modified\nclass AgentDefinition:\n    ...","liskov-substitution-principle-lsp#Liskov Substitution Principle (LSP)":"Any Validator implementation works:\ndef validate_agent(validator: Validator, agent: AgentDefinition) -> None:\n    validator.validate(agent)  # Any validator works","interface-segregation-principle-isp#Interface Segregation Principle (ISP)":"Small, focused protocols:\nclass Builder(Protocol[T]):\n    def build(self) -> T: ...\nclass Validator(Protocol):\n    def validate(self, definition: AgentDefinition) -> None: ...","dependency-inversion-principle-dip#Dependency Inversion Principle (DIP)":"Depend on abstractions (Protocols), not concretions:\nclass DefinitionService:\n    def __init__(self, validator: Validator, exporter: Exporter):\n        # Depends on protocols, not concrete classes\n        ...","why-hexagonal-architecture#Why Hexagonal Architecture?":"","benefits#Benefits":"Testability: Each layer can be tested independently\nMaintainability: Changes in one layer don't cascade\nFlexibility: Easy to swap implementations\nClarity: Clear separation of concerns","example-swapping-exporters#Example: Swapping Exporters":"Want to add JSON export? Just implement the Exporter protocol:\nclass JsonExporter:\n    \"\"\"JSON export implementation.\"\"\"\n    def export(self, definition: AgentDefinition) -> str:\n        # JSON export logic\n        ...\nNo changes needed to:\nDomain layer\nApplication layer\nAPI layer","package-structure#Package Structure":"ainalyn/\n├── domain/                    # Layer 1: Pure business logic\n│   ├── entities/\n│   │   ├── agent_definition.py\n│   │   ├── workflow.py\n│   │   ├── node.py\n│   │   └── ...\n│   └── rules/\n│       └── definition_rules.py\n│\n├── ports/                     # Layer 2: Interfaces\n│   ├── inbound/\n│   │   ├── builder.py\n│   │   ├── validator.py\n│   │   └── exporter.py\n│   └── outbound/\n│       ├── writer.py\n│       └── schema_validator.py\n│\n├── adapters/                  # Layer 3: Implementations\n│   ├── primary/\n│   │   ├── builders.py\n│   │   └── errors.py\n│   └── secondary/\n│       ├── validators.py\n│       ├── exporters.py\n│       └── analyzers.py\n│\n├── application/               # Layer 4: Use cases\n│   ├── services.py\n│   └── use_cases/\n│       ├── validate_definition.py\n│       ├── export_definition.py\n│       └── compile_definition.py\n│\n├── api.py                     # Layer 5: Public API\n├── cli.py                     # Layer 5: CLI\n└── __init__.py               # Layer 5: Exports","data-flow-example#Data Flow Example":"","building-and-exporting-an-agent#Building and Exporting an Agent":"1. User calls AgentBuilder()           [Layer 5: API]\n         ↓\n2. AgentBuilder constructs             [Layer 3: Adapter]\n         ↓\n3. .build() creates AgentDefinition    [Layer 1: Domain]\n         ↓\n4. User calls export_yaml()            [Layer 5: API]\n         ↓\n5. DefinitionService orchestrates      [Layer 4: Application]\n         ↓\n6. YamlExporter exports                [Layer 3: Adapter]\n         ↓\n7. YAML string returned to user        [Layer 5: API]","further-reading#Further Reading":"For detailed architecture and contribution guidelines, see the CONTRIBUTING.md file in the repository root.The architecture ensures the SDK remains a focused, reliable compiler for agent definitions!"}},"/v1/concepts/agent-definition":{"title":"Agent Definition","data":{"":"An Agent Definition is the complete specification of a task-oriented agent for the Ainalyn Platform. This document explains what an Agent Definition is, what it contains, and how to create one.","what-is-an-agent-definition#What is an Agent Definition?":"An Agent Definition is a description of an agent's structure, capabilities, and workflows. It is NOT an executing system—it's a blueprint that the platform uses to create executions.\nagent_definition = AgentDefinition(\n    name=\"MyAgent\",\n    version=\"1.0.0\",\n    description=\"What the agent does\",\n    workflows=(...),   # How the agent works\n    modules=(...),     # Reusable capabilities\n    prompts=(...),     # LLM guidance\n    tools=(...),       # External integrations\n)","core-components#Core Components":"","1-agent-metadata#1. Agent Metadata":"Every agent has basic metadata:\nagent = (\n    AgentBuilder(\"TaskAgent\")\n    .description(\"Automates repetitive tasks efficiently\")\n    .version(\"2.1.0\")\n    .build()\n)\nFields:\nname (required): Unique identifier (valid Python identifier)\nversion (required): Semantic version (e.g., \"1.0.0\", \"2.3.1\")\ndescription (required): Human-readable description","2-workflows#2. Workflows":"Workflows define the task execution logic:\nworkflow = WorkflowBuilder(\"main_flow\")\n    .description(\"Primary task workflow\")\n    .add_node(...)\n    .add_node(...)\n    .build()\nPurpose: Organize nodes into logical execution flowsSee: Workflows Guide","3-nodes#3. Nodes":"Nodes are the smallest units of work:\nnode = NodeBuilder(\"process_data\")\n    .goal(\"Process and clean the input data\")\n    .description(\"Additional context...\")\n    .depends_on(\"load_data\")\n    .build()\nPurpose: Represent individual sub-tasks","4-modules#4. Modules":"Modules provide reusable capabilities:\nmodule = ModuleBuilder(\"DataProcessor\")\n    .description(\"Reusable data processing capabilities\")\n    .add_capability(\"parse_csv\")\n    .add_capability(\"validate_schema\")\n    .build()\nPurpose: Share common functionality across workflowsSee: Modules Guide","5-prompts#5. Prompts":"Prompts guide LLM behavior:\nprompt = PromptBuilder(\"analysis_prompt\")\n    .template(\"Analyze the following data: {data}\")\n    .build()\nPurpose: Define LLM interaction templates","6-tools#6. Tools":"Tools specify external integrations:\ntool = ToolBuilder(\"api_caller\")\n    .description(\"Calls external REST APIs\")\n    .add_parameter(\"url\")\n    .add_parameter(\"method\")\n    .build()\nPurpose: Declare external capabilities needed","minimal-valid-agent#Minimal Valid Agent":"The absolute minimum agent definition:\nagent = (\n    AgentBuilder(\"MinimalAgent\")\n    .description(\"A minimal agent\")\n    .version(\"1.0.0\")\n    .build()\n)\nNote: While valid, a useful agent needs at least one workflow!","complete-example#Complete Example":"A realistic agent with all components:\nfrom ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    ModuleBuilder,\n    PromptBuilder,\n    ToolBuilder,\n)\n# Define a reusable module\ncsv_module = (\n    ModuleBuilder(\"CSVProcessor\")\n    .description(\"CSV file processing capabilities\")\n    .add_capability(\"read_csv\")\n    .add_capability(\"validate_csv\")\n    .build()\n)\n# Define a prompt\nanalysis_prompt = (\n    PromptBuilder(\"data_analysis\")\n    .template(\"Analyze this data and provide insights: {data}\")\n    .build()\n)\n# Define a tool\napi_tool = (\n    ToolBuilder(\"rest_api\")\n    .description(\"REST API integration\")\n    .add_parameter(\"endpoint\")\n    .build()\n)\n# Define workflow nodes\nload_node = (\n    NodeBuilder(\"load_data\")\n    .goal(\"Load data from CSV file\")\n    .build()\n)\nanalyze_node = (\n    NodeBuilder(\"analyze_data\")\n    .goal(\"Perform statistical analysis\")\n    .depends_on(\"load_data\")\n    .build()\n)\nreport_node = (\n    NodeBuilder(\"generate_report\")\n    .goal(\"Create analysis report\")\n    .depends_on(\"analyze_data\")\n    .build()\n)\n# Define workflow\nanalysis_workflow = (\n    WorkflowBuilder(\"analyze_csv\")\n    .description(\"Load, analyze, and report on CSV data\")\n    .add_node(load_node)\n    .add_node(analyze_node)\n    .add_node(report_node)\n    .build()\n)\n# Create complete agent\ndata_analyst = (\n    AgentBuilder(\"DataAnalyst\")\n    .description(\"Automated CSV data analysis and reporting\")\n    .version(\"1.0.0\")\n    .add_workflow(analysis_workflow)\n    .add_module(csv_module)\n    .add_prompt(analysis_prompt)\n    .add_tool(api_tool)\n    .build()\n)","yaml-representation#YAML Representation":"When exported, the agent definition becomes:\nname: DataAnalyst\nversion: 1.0.0\ndescription: Automated CSV data analysis and reporting\nworkflows:\n  - name: analyze_csv\n    description: Load, analyze, and report on CSV data\n    nodes:\n      - name: load_data\n        goal: Load data from CSV file\n        dependencies: []\n      - name: analyze_data\n        goal: Perform statistical analysis\n        dependencies: [load_data]\n      - name: generate_report\n        goal: Create analysis report\n        dependencies: [analyze_data]\nmodules:\n  - name: CSVProcessor\n    description: CSV file processing capabilities\n    capabilities: [read_csv, validate_csv]\nprompts:\n  - name: data_analysis\n    template: \"Analyze this data and provide insights: {data}\"\ntools:\n  - name: rest_api\n    description: REST API integration\n    parameters: [endpoint]","what-an-agent-definition-is-not#What an Agent Definition is NOT":"An Agent Definition is NOT:\nAn executing process\nA runtime system\nAn autonomous agent\nA service or API\nA workflow engine\nIt IS:\nA specification\nA description\nA blueprint\nA configuration\nA deployment artifact","requirements-for-valid-definitions#Requirements for Valid Definitions":"","1-naming-rules#1. Naming Rules":"All names must be valid Python identifiers:\n# Valid names\n\"MyAgent\"\n\"data_processor\"\n\"agent_v2\"\n# Invalid names\n\"my-agent\"       # No hyphens\n\"my agent\"       # No spaces\n\"123agent\"       # Cannot start with digit","2-semantic-versioning#2. Semantic Versioning":"Versions must follow semantic versioning:\n# Valid versions\n\"1.0.0\"\n\"2.3.1\"\n\"0.1.0-beta\"\n# Invalid versions\n\"1.0\"            # Must have three parts\n\"v1.0.0\"         # No 'v' prefix\n\"latest\"         # Must be specific","3-no-circular-dependencies#3. No Circular Dependencies":"Workflow nodes cannot have circular dependencies:\n# Invalid (circular)\nworkflow = (\n    WorkflowBuilder(\"circular\")\n    .add_node(NodeBuilder(\"A\").depends_on(\"B\").build())\n    .add_node(NodeBuilder(\"B\").depends_on(\"A\").build())  # A→B→A\n    .build()\n)\n# Valid (acyclic)\nworkflow = (\n    WorkflowBuilder(\"linear\")\n    .add_node(NodeBuilder(\"A\").build())\n    .add_node(NodeBuilder(\"B\").depends_on(\"A\").build())  # A→B\n    .build()\n)","the-agent-as-a-product#The Agent as a Product":"On the Ainalyn Platform, agents are marketplace products:\nDiscoverable: Users can find your agent\nSchedulable: Users can request execution\nBillable: Platform charges for executions\nGoverned: Platform enforces policies\nYour Agent Definition becomes a product listing!","immutability#Immutability":"All agent definitions are immutable (frozen dataclasses):\nagent = AgentBuilder(\"MyAgent\")....build()\n# Cannot modify\nagent.name = \"NewName\"  # Error: frozen dataclass\n# Create new version\nagent_v2 = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"2.0.0\")  # New version\n    .build()\n)\nWhy?: Immutability ensures definitions are stable and reproducible.","validation#Validation":"Always validate before deployment:\nfrom ainalyn.api import validate\ntry:\n    validate(agent)\n    print(\"Valid agent definition\")\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\nValidation checks:\nName format\nVersion format\nNo circular dependencies\nRequired fields present\nPlatform boundary compliance","best-practices#Best Practices":"","1-clear-goals#1. Clear Goals":"Every node should have a specific, measurable goal:\n# Good goal\n.goal(\"Extract all email addresses from the input text\")\n# Vague goal\n.goal(\"Process data\")","2-semantic-versioning-1#2. Semantic Versioning":"Update versions meaningfully:\nMajor (1.0.0 → 2.0.0): Breaking changes\nMinor (1.0.0 → 1.1.0): New features\nPatch (1.0.0 → 1.0.1): Bug fixes","3-descriptive-names#3. Descriptive Names":"Use self-documenting names:\n# Clear names\nNodeBuilder(\"validate_email_format\")\nWorkflowBuilder(\"process_customer_orders\")\n# Unclear names\nNodeBuilder(\"step1\")\nWorkflowBuilder(\"main\")","4-modular-design#4. Modular Design":"Reuse modules across workflows:\nauth_module = ModuleBuilder(\"Authentication\")....build()\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .add_module(auth_module)  # Reusable!\n    .add_workflow(workflow1)\n    .add_workflow(workflow2)  # Both can use auth_module\n    .build()\n)","5-include-documentation#5. Include Documentation":"Add descriptions everywhere:\nworkflow = (\n    WorkflowBuilder(\"data_pipeline\")\n    .description(\"ETL pipeline for customer data\")  # Helpful!\n    .add_node(...)\n    .build()\n)","further-reading#Further Reading":"Builders API - How to build definitions\nValidation - Validating definitions\nPlatform Boundaries - What definitions cannot include\nYour First Agent - Complete tutorial\nAn Agent Definition is your blueprint for success on the Ainalyn Platform!"}},"/v1/concepts/compiler-not-runtime":{"title":"Compiler vs Runtime","data":{"":"The Ainalyn SDK is fundamentally a compiler, not a runtime engine. Understanding this distinction is essential for effective agent development.","the-compiler-paradigm#The Compiler Paradigm":"","what-is-a-compiler#What is a Compiler?":"A compiler transforms source code from one form to another without executing it:\nSource Code → [Compiler] → Target Format","the-ainalyn-sdk-as-a-compiler#The Ainalyn SDK as a Compiler":"Python API → [Ainalyn SDK] → YAML Definition\nThe SDK takes your Python-based agent descriptions and compiles them into YAML that the platform can deploy and execute.","analogy-terraform#Analogy: Terraform":"The Ainalyn SDK is similar to Terraform:","terraform#Terraform":"# Terraform describes infrastructure\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-123456\"\n  instance_type = \"t2.micro\"\n}\nTerraform does NOT: Create AWS instances itself\nTerraform DOES: Generate a plan that AWS can execute\nAWS does: Actually create and manage resources","ainalyn-sdk#Ainalyn SDK":"# Ainalyn SDK describes agents\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .add_workflow(...)\n    .build()\n)\nSDK does NOT: Execute agents\nSDK DOES: Generate YAML that the platform can execute\nPlatform does: Actually run agents and manage executions","compiler-vs-runtime-comparison#Compiler vs Runtime Comparison":"Aspect\tCompiler (SDK)\tRuntime (Platform)\tPurpose\tTransform definitions\tExecute tasks\tInput\tPython API calls\tYAML definitions\tOutput\tYAML files\tExecution results\tWhen\tDevelopment time\tProduction time\tWhere\tDeveloper's machine\tCloud platform\tAuthority\tStructure validation\tExecution control","what-this-means-for-you#What This Means for You":"","as-an-sdk-user#As an SDK User":"You CAN:\nDefine agent structures\nValidate definitions\nExport to YAML\nTest definition structure locally\nYou CANNOT:\nExecute agents\nSee execution results\nControl retry/timeout\nCalculate actual costs","the-development-flow#The Development Flow":"1. Write Python code using SDK  ──────┐\n                                      │\n2. SDK validates structure      ◄─────┘\n                                      │\n3. SDK compiles to YAML         ◄─────┘\n                                      │\n4. Upload YAML to platform      ──────┐\n                                      │\n5. Platform validates definition ◄────┘\n                                      │\n6. User requests execution      ──────┐\n                                      │\n7. Platform creates Execution   ◄─────┘\n                                      │\n8. Platform runs agent logic    ◄─────┘\n                                      │\n9. Platform bills for execution ◄─────┘\nSDK involvement: Steps 1-3 only!","examples#Examples":"","example-1-defining-vs-executing#Example 1: Defining vs Executing":"Wrong Mental Model:\n# Wrong thinking: \"The SDK will run this\"\nagent = AgentBuilder(\"MyAgent\").add_workflow(...).build()\nagent.execute()  # Does not exist!\nCorrect Mental Model:\n# Correct thinking: \"The SDK compiles this for the platform\"\nagent = AgentBuilder(\"MyAgent\").add_workflow(...).build()\nyaml_output = export_yaml(agent)  # Compile to YAML\n# Now upload YAML to platform for execution","example-2-local-testing#Example 2: Local Testing":"Wrong Approach:\n# Wrong: Trying to \"run\" the agent locally\nresult = agent.run_workflow(\"my_workflow\")  # Not possible\nCorrect Approach:\n# Correct: Validate the structure\nfrom ainalyn.api import validate\nvalidate(agent)  # Structural validation only\nprint(\"Agent definition is valid!\")\n# Actual execution happens on the platform","why-this-design#Why This Design?":"","1-separation-of-concerns#1. Separation of Concerns":"SDK: Focuses on definition quality\nPlatform: Focuses on execution reliability","2-platform-flexibility#2. Platform Flexibility":"Platform can improve execution without SDK changes\nPlatform can add new execution strategies\nPlatform can optimize resource usage","3-developer-simplicity#3. Developer Simplicity":"You don't manage infrastructure\nYou don't implement retry logic\nYou don't handle billing","4-security-and-governance#4. Security and Governance":"Platform controls execution environment\nPlatform enforces resource limits\nPlatform ensures billing accuracy","local-development-vs-production#Local Development vs Production":"","local-development#Local Development":"# Development: Create and validate definitions\nagent = AgentBuilder(\"MyAgent\")....build()\nvalidate(agent)\nyaml = export_yaml(agent)\nprint(yaml)  # Review the output\nPurpose: Ensure your definition is valid and complete","production#Production":"# Production: Platform executes the definition\n# (After you upload the YAML)\n# Platform parses YAML\n# Platform creates Execution\n# Platform runs agent logic\n# Platform returns results\n# Platform bills user\nPurpose: Actual task completion","common-questions#Common Questions":"","q-can-i-test-my-agent-locally-before-deploying#Q: Can I test my agent locally before deploying?":"A: You can validate the structure of your agent definition locally using validate(). However, actual agent behavior can only be tested on the platform, as the SDK cannot execute agents.","q-how-do-i-debug-my-agent#Q: How do I debug my agent?":"A:\nUse validate() to catch structural errors\nReview the generated YAML for correctness\nDeploy to platform and check execution logs\nPlatform provides execution debugging tools","q-can-i-simulate-execution-locally#Q: Can I simulate execution locally?":"A: The SDK may provide structural validation utilities for development, but these are NOT simulations of actual platform execution. Real execution behavior depends on platform runtime, which the SDK cannot replicate.","q-why-not-include-a-runtime-in-the-sdk#Q: Why not include a runtime in the SDK?":"A: Including a runtime would:\nViolate platform boundaries\nCreate inconsistency between local and platform behavior\nRequire duplicating platform logic\nMake the SDK unnecessarily complex\nConfuse responsibility (who handles errors, billing, etc.)","compiler-benefits#Compiler Benefits":"","1-fast-feedback#1. Fast Feedback":"Validation happens instantly:\nvalidate(agent)  # Immediate structural feedback","2-type-safety#2. Type Safety":"Python type hints catch errors at development time:\nbuilder: AgentBuilder = AgentBuilder(\"MyAgent\")\n# IDE helps you avoid mistakes","3-version-control#3. Version Control":"Agent definitions are just code:\ngit add my_agent.py\ngit commit -m \"Add new agent definition\"\ngit push","4-reproducibility#4. Reproducibility":"Same Python code always produces same YAML:\n# Deterministic compilation\nyaml1 = export_yaml(agent)\nyaml2 = export_yaml(agent)\nassert yaml1 == yaml2  # Always true","the-compilation-process#The Compilation Process":"","step-1-builder-api#Step 1: Builder API":"from ainalyn import AgentBuilder\nagent = AgentBuilder(\"MyAgent\").description(\"...\").build()\nWhat happens: Python objects created in memory","step-2-validation#Step 2: Validation":"from ainalyn.api import validate\nvalidate(agent)\nWhat happens: Rules engine checks compliance","step-3-compilation#Step 3: Compilation":"from ainalyn.api import export_yaml\nyaml_output = export_yaml(agent)\nWhat happens: Python objects transformed to YAML","step-4-deployment#Step 4: Deployment":"# Upload YAML to platform (via CLI, web UI, or API)\nainalyn deploy my_agent.yaml\nWhat happens: Platform ingests and prepares for execution","sdk-as-a-language#SDK as a Language":"Think of the SDK as a Domain-Specific Language (DSL) for agent definitions:\n# This is a language for describing agents\nagent = (\n    AgentBuilder(\"DataAnalyzer\")\n    .version(\"1.0.0\")\n    .add_workflow(\n        WorkflowBuilder(\"analyze\")\n        .add_node(\n            NodeBuilder(\"load_data\")\n            .goal(\"Load CSV data\")\n            .build()\n        )\n        .build()\n    )\n    .build()\n)\nJust like:\nSQL describes queries (database executes)\nHTML describes pages (browser renders)\nTerraform describes infrastructure (cloud executes)\nAinalyn SDK describes agents (platform executes)","further-reading#Further Reading":"Platform Boundaries - What the SDK cannot do\nAgent Definition - What you're building\nArchitecture Overview - How the SDK works\nValidation - Validating definitions\nYAML Export - Compiling to YAML\nRemember: You're not writing an execution engine. You're defining what should be executed. The platform handles the rest!"}},"/v1/concepts/platform-boundaries":{"title":"Platform Boundaries","data":{"":"Understanding the boundaries between the Ainalyn SDK and the Ainalyn Platform is critical for successful agent development. This document defines what the SDK can and cannot do.\nMost Important ConceptThe SDK is a compiler, NOT a runtime. Everything you build with the SDK is a description of an agent, not an executing system. Execution authority belongs solely to the Ainalyn Platform.","the-four-core-concepts#The Four Core Concepts":"The Ainalyn ecosystem is built on four foundational concepts:","1-agent-marketplace-contract-entity#1. Agent (Marketplace Contract Entity)":"What it is: A task-oriented product entity that can be scheduled, governed, and billed\nSDK role: Define the agent's structure and capabilities\nPlatform role: Host, manage, and enable execution of agents\nAn Agent is NOT:\nNot a workflow\nNot a node or module\nNot an LLM or autonomous system\nNot a runtime process","2-agent-definition-description-layer-only#2. Agent Definition (Description Layer Only)":"What it is: The specification of an agent's structure, workflows, and capabilities\nSDK role: Compile valid agent definitions to YAML\nPlatform role: Parse and validate definitions for deployment\nSDK Creates Agent DefinitionsThis is the entire scope of the SDK: creating valid AgentDefinition objects and exporting them to YAML.","3-execution-platform-core-only#3. Execution (Platform Core Only)":"What it is: The runtime instance of an agent performing a task\nSDK role: NONE - The SDK cannot execute anything\nPlatform role: Create, manage, and complete executions\nCritical Distinction\nAgentDefinition (SDK) ≠ Execution (Platform)\nYou define agents, the platform executes them\nSDK has ZERO authority over execution","4-billing-execution-based-only#4. Billing (Execution-Based Only)":"What it is: Charges based on completed executions\nSDK role: NONE - The SDK cannot calculate billing\nPlatform role: Track execution costs and bill users","what-the-sdk-can-do#What the SDK CAN Do":"The SDK is authorized to:","define-agent-structures#Define Agent Structures":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .description(\"What the agent does\")\n    .version(\"1.0.0\")\n    .add_workflow(...)\n    .build()\n)","validate-definitions#Validate Definitions":"from ainalyn.api import validate\nvalidate(agent)  # Ensures compliance with platform rules","export-to-yaml#Export to YAML":"from ainalyn.api import export_yaml\nyaml_output = export_yaml(agent)  # Platform-compatible format","provide-local-development-tools#Provide Local Development Tools":"# Testing utilities (for development only)\nfrom ainalyn.adapters.secondary import StaticAnalyzer\nanalyzer = StaticAnalyzer()\nissues = analyzer.analyze(agent)  # Find potential problems","offer-type-safe-apis#Offer Type-Safe APIs":"# Full type hints for IDE support\nfrom ainalyn import AgentBuilder\nbuilder: AgentBuilder = AgentBuilder(\"MyAgent\")  # Type-safe!","what-the-sdk-cannot-do-forbidden-zone#What the SDK CANNOT Do (Forbidden Zone)":"The SDK is explicitly forbidden from:","execution-semantics#Execution Semantics":"NO execution methods:\n# FORBIDDEN - These methods do NOT exist\nagent.execute()\nagent.run()\nagent.start()\nworkflow.execute()\nnode.run()\nWhy? Execution is the platform's exclusive responsibility. The SDK only describes what should be executed, not how or when.","execution-authority#Execution Authority":"NO decisions about:\nRetry strategies\nTimeout policies\nFallback mechanisms\nSuccess/failure determination\nExecution scheduling\nResource allocation\nWhy? The platform must have sole authority over these operational decisions to ensure consistency, reliability, and governance.","billing-and-pricing-logic#Billing and Pricing Logic":"NO billing calculations:\n# FORBIDDEN - Cannot exist in SDK\nagent.calculate_cost()\nexecution.get_price()\nagent.set_pricing(...)\nWhy? Billing is based on platform-managed executions, not agent definitions. The SDK cannot know execution costs.","autonomous-agent-patterns#Autonomous Agent Patterns":"NO autonomous behaviors:\nSelf-triggered executions\nContinuous running loops\nIndependent decision-making\nState persistence across executions\nWhy? Agents on the Ainalyn Platform are task-oriented, not autonomous. They execute specific tasks on demand, then complete.","execution-id-generation#Execution ID Generation":"NO execution tracking:\n# FORBIDDEN\nagent.create_execution_id()\nagent.track_execution(...)\nWhy? Only the platform can create and manage executionIds, which are used for billing, tracking, and governance.","platform-authority#Platform Authority":"NO platform-level operations:\nAgent marketplace operations\nUser authentication/authorization\nPlatform configuration\nInfrastructure management\nWhy? These are platform responsibilities, far beyond the SDK's scope as a compiler.","the-sdkplatform-contract#The SDK/Platform Contract":"","sdk-responsibilities#SDK Responsibilities":"Define: Provide APIs for defining agents\nValidate: Ensure definitions comply with rules\nCompile: Export to platform-compatible YAML\nDocument: Help developers understand boundaries","platform-responsibilities#Platform Responsibilities":"Execute: Run agent definitions as executions\nBill: Charge for execution completion\nGovern: Enforce policies and limits\nHost: Provide infrastructure and marketplace","clear-separation#Clear Separation":"┌─────────────────────────────────────────────────────────┐\n│                    DEVELOPER                            │\n│                        │                                │\n│                        ▼                                │\n│              ┌──────────────────┐                       │\n│              │  Ainalyn SDK     │                       │\n│              │  (Compiler)      │                       │\n│              └────────┬─────────┘                       │\n│                       │                                 │\n│                       │ YAML                            │\n│                       ▼                                 │\n│              ┌──────────────────┐                       │\n│              │ Ainalyn Platform │                       │\n│              │  (Runtime)       │                       │\n│              └────────┬─────────┘                       │\n│                       │                                 │\n│                       ▼                                 │\n│              ┌──────────────────┐                       │\n│              │   Execution      │                       │\n│              │  (Runtime        │                       │\n│              │   Instance)      │                       │\n│              └──────────────────┘                       │\n└─────────────────────────────────────────────────────────┘","execution-lifecycle-platform-only#Execution Lifecycle (Platform Only)":"The platform manages this lifecycle (SDK has no role):\nREQUESTED → VALIDATED → SCHEDULED → RUNNING → COMPLETED/FAILED/ABORTED\nREQUESTED: User requests task execution\nVALIDATED: Platform validates request\nSCHEDULED: Platform schedules execution\nRUNNING: Platform executes agent logic\nCOMPLETED/FAILED/ABORTED: Platform finalizes execution\nSDK involvement: NONE. The SDK's work ends at agent definition compilation.","boundary-compliance-checklist#Boundary Compliance Checklist":"When developing with the SDK, ensure:\nNo execution-related methods (execute(), run(), start())\nNo state management across executions\nNo billing/pricing calculations\nNo executionId generation or tracking\nNo platform authority operations\nAll agent definitions include disclaimer comments\nDocumentation emphasizes \"compiler, not runtime\"","why-these-boundaries-matter#Why These Boundaries Matter":"","1-clear-responsibility#1. Clear Responsibility":"SDK: Definition quality\nPlatform: Execution reliability\nNo confusion about who handles what","2-platform-governance#2. Platform Governance":"Platform can enforce policies consistently\nPlatform can evolve execution strategies\nPlatform can ensure billing accuracy","3-developer-focus#3. Developer Focus":"Developers focus on agent logic\nDevelopers don't manage infrastructure\nDevelopers don't implement execution engines","4-security-and-trust#4. Security and Trust":"Platform controls resource access\nPlatform prevents malicious execution\nPlatform ensures fair billing","common-misconceptions#Common Misconceptions":"","the-sdk-runs-my-agent-locally#\"The SDK runs my agent locally\"":"Wrong. The SDK defines your agent. Local testing (if provided) is structural validation only, not actual execution.","i-can-optimize-execution-with-sdk-settings#\"I can optimize execution with SDK settings\"":"Wrong. Execution optimization is the platform's job. Your agent definition describes WHAT, not HOW.","my-agent-will-retry-automatically#\"My agent will retry automatically\"":"Wrong. Retry logic is a platform decision, not defined in your agent. The platform determines retry strategies.","i-can-estimate-costs-in-the-sdk#\"I can estimate costs in the SDK\"":"Wrong. Costs depend on platform execution, which varies based on actual runtime behavior, not static definitions.","further-reading#Further Reading":"Compiler vs Runtime - Deep dive into the paradigm\nAgent Definition - What you're actually building\nArchitecture Overview - How the SDK is designed\nRemember: The SDK is a powerful compiler for agent definitions. Stay within the boundaries, and you'll build amazing agents for the Ainalyn Platform!"}},"/v1/getting-started":{"title":"Ainalyn SDK","data":{"":"Build task-oriented agents with Python. The Ainalyn SDK is a compiler that turns your Python code into platform-ready agent definitions.\nSDK = Compiler, Not RuntimeThe SDK creates agent descriptions. The Ainalyn Platform executes them.","what-it-does#What it does":"Define agents with a Python API\nValidate definitions before deployment\nExport to YAML for the platform","features#Features":"Type-safe API - Full type hints and IDE autocomplete\nFluent builders - Chainable, intuitive API\nValidation - Catch errors before deployment\nYAML export - One command to platform-ready format","example#Example":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate, export_yaml\n# Define a prompt\ngreeting_prompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a personalized greeting\")\n    .template(\"Generate a personalized greeting for {{user_name}}\")\n    .variables(\"user_name\")\n    .build()\n)\n# Define an agent\nagent = (\n    AgentBuilder(\"greeting-agent\")\n    .description(\"Generates personalized greetings\")\n    .version(\"1.0.0\")\n    .add_prompt(greeting_prompt)\n    .add_workflow(\n        WorkflowBuilder(\"greet-user\")\n        .description(\"Main greeting workflow\")\n        .add_node(\n            NodeBuilder(\"generate-greeting\")\n            .description(\"Generate a personalized greeting\")\n            .uses_prompt(\"greeting-prompt\")\n            .outputs(\"greeting\")\n            .build()\n        )\n        .entry_node(\"generate-greeting\")\n        .build()\n    )\n    .build()\n)\n# Validate and export\nvalidate(agent)\nyaml_output = export_yaml(agent)","getting-started#Getting Started":"New to the SDK?\nInstall the SDK\nTry the 5-minute quickstart\nBuild your first agent\nUnderstanding the SDK\nPlatform Boundaries - What the SDK can and cannot do\nCompiler vs Runtime - Why the SDK is a compiler\nArchitecture - How it's built\nAgent Definitions - What you're creating","important-sdk-boundaries#Important: SDK Boundaries":"The SDK creates descriptions. The platform runs them.What the SDK does:\nDefine agent structures\nValidate definitions\nExport to YAML\nWhat the SDK does NOT do:\nExecute agents\nHandle billing\nManage retries or timeouts\nLearn more about platform boundaries","support#Support":"Report issues\nAsk questions\nView source"}},"/v1/guides/prompts":{"title":"Prompts","data":{"":"How to create reusable LLM prompt templates for your agents.","what-is-a-prompt#What is a Prompt?":"A prompt is a template that defines how to interact with Language Models. It supports:\nTemplate text with variable placeholders\nVariable interpolation using {{variable}} syntax\nReusability across multiple workflows\nImportant: The SDK defines the prompt template. The platform handles LLM invocation.","creating-a-prompt#Creating a Prompt":"from ainalyn import PromptBuilder\nprompt = (\n    PromptBuilder(\"data-analyzer\")\n    .description(\"Analyzes data and provides insights\")\n    .template(\"\"\"\nPlease analyze the following data:\n{{data}}\nFocus on: {{focus_areas}}\nProvide detailed insights and recommendations.\n\"\"\")\n    .variables([\"data\", \"focus_areas\"])\n    .build()\n)","variable-syntax#Variable Syntax":"Use {{variable_name}} to mark placeholders in your template.\ntemplate = \"\"\"\nHello {{name}},\nYour order {{order_id}} has been {{status}}.\nThank you!\n\"\"\"\nprompt = (\n    PromptBuilder(\"order-notification\")\n    .template(template)\n    .variables([\"name\", \"order_id\", \"status\"])\n    .build()\n)\nAt runtime:\nPlatform replaces {{name}} with actual value\nVariables come from node inputs or previous outputs","using-prompts-in-workflows#Using Prompts in Workflows":"Step 1: Define the prompt\nanalyzer = (\n    PromptBuilder(\"analyzer\")\n    .description(\"Analyzes text content\")\n    .template(\"Analyze this: {{content}}\")\n    .variables([\"content\"])\n    .build()\n)\nStep 2: Add prompt to agent\nagent = (\n    AgentBuilder(\"text-agent\")\n    .version(\"1.0.0\")\n    .add_prompt(analyzer)  # Register prompt\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"analyze\")\n    .description(\"Analyze content\")\n    .uses_prompt(\"analyzer\")  # References the prompt\n    .inputs(\"content\")\n    .outputs(\"analysis\")\n    .build()\n)","common-prompt-patterns#Common Prompt Patterns":"","text-analysis#Text Analysis":"analyzer = (\n    PromptBuilder(\"text-analyzer\")\n    .description(\"Analyzes text for sentiment and key points\")\n    .template(\"\"\"\nAnalyze the following text:\n{{text}}\nProvide:\n1. Sentiment (positive/negative/neutral)\n2. Key points (3-5 bullet points)\n3. Summary (1-2 sentences)\n\"\"\")\n    .variables([\"text\"])\n    .build()\n)","data-summarization#Data Summarization":"summarizer = (\n    PromptBuilder(\"data-summarizer\")\n    .description(\"Summarizes structured data\")\n    .template(\"\"\"\nSummarize this data:\n{{data}}\nFormat: {{format}}\nInclude statistics and key findings.\n\"\"\")\n    .variables([\"data\", \"format\"])\n    .build()\n)","content-generation#Content Generation":"generator = (\n    PromptBuilder(\"content-generator\")\n    .description(\"Generates content based on topic\")\n    .template(\"\"\"\nWrite a {{content_type}} about {{topic}}.\nTone: {{tone}}\nLength: {{length}} words\nRequirements:\n{{requirements}}\n\"\"\")\n    .variables([\"content_type\", \"topic\", \"tone\", \"length\", \"requirements\"])\n    .build()\n)","translation#Translation":"translator = (\n    PromptBuilder(\"translator\")\n    .description(\"Translates text between languages\")\n    .template(\"\"\"\nTranslate the following text from {{source_lang}} to {{target_lang}}:\n{{text}}\nMaintain the original tone and style.\n\"\"\")\n    .variables([\"source_lang\", \"target_lang\", \"text\"])\n    .build()\n)","qa-assistant#Q&A Assistant":"qa = (\n    PromptBuilder(\"qa-assistant\")\n    .description(\"Answers questions based on context\")\n    .template(\"\"\"\nContext:\n{{context}}\nQuestion: {{question}}\nProvide a clear, concise answer based only on the context provided.\n\"\"\")\n    .variables([\"context\", \"question\"])\n    .build()\n)","multiline-templates#Multiline Templates":"Use Python triple quotes for readable templates:\n# Readable multiline template\ntemplate = \"\"\"\nAnalyze the following report:\nTitle: {{title}}\nDate: {{date}}\nAuthor: {{author}}\nContent:\n{{content}}\nProvide a summary and key takeaways.\n\"\"\"\n# Avoid hard to read single line\n# template = \"Analyze: {{title}} Date: {{date}}...\"","variables-best-practices#Variables Best Practices":"1. List all variables used\n# All variables declared\nPromptBuilder(\"analyzer\")\n    .template(\"Analyze {{data}} focusing on {{aspect}}\")\n    .variables([\"data\", \"aspect\"])\n# Missing variable declaration - avoid this\nPromptBuilder(\"analyzer\")\n    .template(\"Analyze {{data}} focusing on {{aspect}}\")\n    .variables([\"data\"])  # Missing \"aspect\"\n2. Use descriptive variable names\n# Clear variable names\n.variables([\"user_email\", \"order_id\", \"delivery_date\"])\n# Unclear - avoid\n.variables([\"e\", \"id\", \"d\"])\n3. Keep variable count manageable\n# Focused prompt with 2-4 variables\n.variables([\"topic\", \"tone\", \"length\"])\n# Too many variables - consider splitting\n# .variables([\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\"])","prompt-naming#Prompt Naming":"Valid names:\n\"text-analyzer\"       # Lowercase with hyphens\n\"data-summarizer\"     # Descriptive\n\"qa-assistant-v2\"     # With version\nInvalid names:\n\"TextAnalyzer\"        # Must be lowercase\n\"text_analyzer\"       # No underscores\n\"my prompt\"           # No spaces","prompt-design-tips#Prompt Design Tips":"1. Be specific\n# Specific instructions\ntemplate = \"\"\"\nAnalyze the sentiment of this customer review:\n{{review}}\nClassify as: positive, negative, or neutral\nProvide reasoning in 1-2 sentences\n\"\"\"\n# Vague - avoid\n# template = \"What do you think about {{review}}?\"\n2. Structure the output\n# Structured output request\ntemplate = \"\"\"\nSummarize: {{article}}\nFormat:\n- Main idea: [1 sentence]\n- Key points: [3-5 bullets]\n- Conclusion: [1 sentence]\n\"\"\"\n# Unstructured - may give inconsistent results\n# template = \"Summarize {{article}}\"\n3. Provide context\n# With context\ntemplate = \"\"\"\nYou are a technical documentation expert.\nReview this code documentation:\n{{documentation}}\nSuggest improvements for clarity and completeness.\n\"\"\"\n# No context - less effective\n# template = \"Review {{documentation}}\"","complete-example#Complete Example":"from ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    PromptBuilder,\n    NodeType\n)\n# Define prompt\nreview_prompt = (\n    PromptBuilder(\"code-reviewer\")\n    .description(\"Reviews code for quality and best practices\")\n    .template(\"\"\"\nReview the following code:\nLanguage: {{language}}\nCode:\n{{code}}\nProvide:\n1. Overall quality assessment\n2. Potential issues or bugs\n3. Suggestions for improvement\n4. Best practice recommendations\n\"\"\")\n    .variables([\"language\", \"code\"])\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"code-review\")\n    .entry_node(\"review\")\n    .add_node(\n        NodeBuilder(\"review\")\n        .description(\"Review submitted code\")\n        .uses_prompt(\"code-reviewer\")\n        .inputs(\"language\", \"code\")\n        .outputs(\"review_result\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"code-review-agent\")\n    .version(\"1.0.0\")\n    .description(\"Automated code review assistant\")\n    .add_prompt(review_prompt)\n    .add_workflow(workflow)\n    .build()\n)","prompt-vs-module-vs-tool#Prompt vs Module vs Tool":"Use Prompt when:\nYou need LLM-based reasoning\nTask involves text understanding or generation\nOutput is natural language\nUse Module when:\nYou need deterministic logic\nTask is computation or data processing\nSee Modules Guide\nUse Tool when:\nYou need external services\nTask involves APIs or databases\nSee Tools Guide","see-also#See Also":"PromptBuilder API - Full API reference\nModules Guide - Custom business logic\nTools Guide - External integrations\nWorkflows - Using prompts in workflows"}},"/v1/guides/yaml-export":{"title":"YAML Export","data":{"":"Convert agent definitions to platform-ready YAML format.","what-is-yaml-export#What is YAML Export?":"YAML export transforms your Python agent definition into a YAML file that the Ainalyn Platform can execute.Key points:\nYAML is the platform's input format\nExport does NOT execute your agent\nThe platform reads YAML files to run agents\nSDK is a compiler, not a runtime","using-export_yaml#Using export_yaml()":"from ainalyn import AgentBuilder, export_yaml\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Process data\")\n    .add_workflow(workflow)\n    .build()\n)\n# Export to YAML string\nyaml_output = export_yaml(agent)\nprint(yaml_output)\nOutput:\nname: my-agent\nversion: 1.0.0\ndescription: Process data\nworkflows:\n  - name: main-workflow\n    description: Main processing workflow\n    entry_node: start\n    nodes:\n      - name: start\n        description: Start processing\n        type: prompt\n        reference: data-processor","saving-to-file#Saving to File":"from ainalyn import export_yaml\n# Export to string\nyaml_output = export_yaml(agent)\n# Save to file\nwith open(\"agent.yaml\", \"w\") as f:\n    f.write(yaml_output)\nprint(\"Saved to agent.yaml\")","using-compile_agent#Using compile_agent()":"Recommended: Use compile_agent() for automatic validation and export.\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Validates and exports in one step\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\n    print(result.yaml_content)\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.message}\")\nAdvantages:\nValidates before exporting\nPrevents invalid YAML files\nReturns detailed error messages\nCreates parent directories automatically","yaml-structure#YAML Structure":"The exported YAML follows this structure:\n# Required fields\nname: agent-name\nversion: 1.0.0\ndescription: What the agent does\n# Workflows (required, at least one)\nworkflows:\n  - name: workflow-name\n    description: What this workflow does\n    entry_node: first-node\n    nodes:\n      - name: node-name\n        description: What this node does\n        type: prompt|module|tool\n        reference: resource-name\n        next_nodes:\n          - next-node-name\n        inputs:\n          - input-name\n        outputs:\n          - output-name\n# Resources (optional)\nmodules:\n  - name: module-name\n    description: What the module does\n    input_schema: {}\n    output_schema: {}\nprompts:\n  - name: prompt-name\n    description: What the prompt does\n    template: \"Prompt text with {variables}\"\n    variables:\n      - variable-name\ntools:\n  - name: tool-name\n    description: What the tool does\n    input_schema: {}\n    output_schema: {}","export-features#Export Features":"Unicode Support:\nagent = (\n    AgentBuilder(\"translator\")\n    .version(\"1.0.0\")\n    .description(\"翻譯助手\")  # Unicode supported\n    .build()\n)\nyaml_output = export_yaml(agent)\n# Output preserves Unicode characters\nDeterministic Ordering:\nKeys appear in consistent order\nWorkflows, modules, prompts, tools grouped logically\nReadable and version-control friendly\nHuman-Readable:\n# Indentation: 2 spaces\n# Flow style: False (multiline)\n# Sort keys: False (manual ordering)","export-vs-validation#Export vs Validation":"export_yaml() - No validation\n# Exports without checking validity\nyaml_output = export_yaml(agent)\n# May produce invalid YAML if agent is malformed\ncompile_agent() - Validates first\n# Validates before exporting\nresult = compile_agent(agent)\nif result.is_successful:\n    yaml_output = result.yaml_content\n# Only exports if valid","common-patterns#Common Patterns":"","export-to-string#Export to String":"from ainalyn import export_yaml\nyaml_string = export_yaml(agent)\nprint(yaml_string)","export-to-file#Export to File":"from ainalyn import export_yaml\nyaml_output = export_yaml(agent)\nwith open(\"agent.yaml\", \"w\", encoding=\"utf-8\") as f:\n    f.write(yaml_output)","validate-and-export#Validate and Export":"from ainalyn import validate, export_yaml\n# Validate first\nresult = validate(agent)\nif result.is_valid:\n    # Then export\n    yaml_output = export_yaml(agent)\n    with open(\"agent.yaml\", \"w\") as f:\n        f.write(yaml_output)\nelse:\n    print(\"Cannot export: validation failed\")","safe-compilation#Safe Compilation":"from ainalyn.api import compile_agent\nfrom pathlib import Path\n# All-in-one: validate + export + save\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(\"Ready for platform deployment\")\nelse:\n    print(f\"Fix these errors first:\")\n    for error in result.validation_result.errors:\n        print(f\"  - {error.message}\")","file-output#File Output":"Creating parent directories:\nfrom pathlib import Path\nfrom ainalyn.api import compile_agent\n# Creates 'output/' directory if it doesn't exist\nresult = compile_agent(agent, Path(\"output/agent.yaml\"))\nUTF-8 encoding:All files are written with UTF-8 encoding to support Unicode content.","what-happens-next#What Happens Next?":"After exporting your agent:\nYou created: YAML definition file\nPlatform reads: YAML to understand agent structure\nPlatform executes: Agent based on definition\nSDK's job is done: No runtime involvement\nSee Platform Boundaries for the SDK's role.","see-also#See Also":"Validation - Validate before export\ncompile_agent() API - Full API reference\nPlatform Boundaries - SDK vs Platform roles"}}}