{"/":{"title":"Ainalyn Documentation","data":{"":"Welcome to the Ainalyn SDK documentation.\nRedirecting to documentation...If you are not redirected, click here."}},"/v1/advanced/architecture-overview":{"title":"Architecture & Code Guide","data":{"":"The Ainalyn SDK is built on Hexagonal Architecture (Ports & Adapters), ensuring clean separation of concerns, testability, and maintainability.\nNote: This section is for contributors who want to understand or modify the SDK's internal architecture. If you're using the SDK to build Agents, see the Concepts section instead.","core-principles#Core Principles":"Compiler, Not Runtime - The SDK creates Agent Definitions; execution belongs to the platform\nDependency Inversion - Core business logic depends on abstractions, not implementations\nClean Boundaries - Each component has a single, well-defined responsibility\nImmutability - Domain entities are immutable by design","architecture-diagram#Architecture Diagram":"┌─────────────────────┐\n                              │    CLI (cli.py)     │\n                              │   Inbound Adapter   │\n                              └──────────┬──────────┘\n                                         │\n    ┌──────────────────┐                 │                 ┌──────────────────┐\n    │  Python API      │                 │                 │  YAML Serializer │\n    │  (api.py)        │                 │                 │  Outbound Adapter│\n    │  Inbound Adapter │                 │                 └────────┬─────────┘\n    └────────┬─────────┘                 │                          │\n             │                           │                          │\n             │         ╔═════════════════╧══════════════════╗       │\n             │         ║                                    ║       │\n             └────────▶║       APPLICATION CORE             ║◀──────┘\n                       ║  ┌──────────────────────────────┐  ║\n    ┌──────────────┐   ║  │         Application          │  ║   ┌──────────────┐\n    │   Builders   │   ║  │  ┌────────────────────────┐  │  ║   │   Schema     │\n    │   (inbound/  │──▶║  │  │  Services & Use Cases  │  │  ║◀──│   Validator  │\n    │   builders/) │   ║  │  │  (Orchestration)       │  │  ║   │   (outbound/)│\n    └──────────────┘   ║  │  └───────────┬────────────┘  │  ║   └──────────────┘\n                       ║  │              │               │  ║\n                       ║  │    Ports     │    Ports      │  ║\n                       ║  │   (inbound)  │   (outbound)  │  ║\n                       ║  │              │               │  ║\n                       ║  │  ┌───────────▼────────────┐  │  ║   ┌──────────────┐\n                       ║  │  │        Domain          │  │  ║   │   Static     │\n                       ║  │  │  ┌──────────────────┐  │  │  ║◀──│   Analyzer   │\n                       ║  │  │  │ Entities, Rules  │  │  │  ║   │   (outbound/)│\n                       ║  │  │  │ (Business Logic) │  │  │  ║   └──────────────┘\n                       ║  │  │  └──────────────────┘  │  │  ║\n                       ║  │  └────────────────────────┘  │  ║\n                       ║  └──────────────────────────────┘  ║\n                       ║                                    ║\n                       ╚════════════════════════════════════╝\n                                         │\n                              ┌──────────┴──────────┐\n                              │    Infrastructure   │\n                              │  (service_factory)  │\n                              │    Wiring/DI        │\n                              └─────────────────────┘\nUnlike layered/onion architecture where layers wrap around each other, hexagonal architecture places the Application Core at the center with Ports defining boundaries and Adapters connecting to the outside world.","key-concepts#Key Concepts":"Concept\tDescription\tLocation\tApplication Core\tBusiness logic that never depends on external systems\tdomain/ + application/\tInbound Ports\tInterfaces for use cases (what the core offers)\tapplication/ports/inbound/\tOutbound Ports\tInterfaces for external capabilities the core needs\tapplication/ports/outbound/\tInbound Adapters\tEntry points that drive the application (CLI, API, Builders)\tadapters/inbound/, api.py, cli.py\tOutbound Adapters\tImplementations of external capabilities (validators, serializers)\tadapters/outbound/\tInfrastructure\tDependency injection and wiring\tinfrastructure/","dependency-rules#Dependency Rules":"Dependencies always point inward toward the Application Core:\n                         Inbound Adapters\n                    (api.py, cli.py, builders/)\n                                │\n                                │ calls\n                                ▼\n                    ┌───────────────────────┐\n                    │   Application Layer   │\n                    │   (services, use_cases)│\n                    │           │           │\n                    │     defines ports     │\n                    │           │           │\n                    └───────────┼───────────┘\n                                │\n        ┌───────────────────────┼───────────────────────┐\n        │                       │                       │\n        ▼                       ▼                       ▼\n   Outbound Ports          Domain Layer           Infrastructure\n   (interfaces)         (entities, rules)         (wiring/DI)\n        ▲                                              │\n        │                                              │\n        └──────────────────────────────────────────────┘\n                    implements ports with\n                     Outbound Adapters\n               (schema_validator, yaml_serializer)\nComponent\tCan Depend On\tCannot Depend On\tDomain\tNothing (pure Python)\tAny outer layer\tApplication (ports)\tDomain\tAdapters, Infrastructure\tApplication (services)\tDomain, Ports (interfaces)\tConcrete Adapters\tInbound Adapters\tApplication (via services), Domain\tOutbound Adapters\tOutbound Adapters\tDomain, implements Outbound Ports\tApplication internals\tInfrastructure\tEverything (for wiring)\t-","layer-details#Layer Details":"","domain-layer#Domain Layer":"Location: ainalyn/domain/Pure business logic with zero external dependencies.\n@dataclass(frozen=True)\nclass AgentDefinition:\n    \"\"\"Immutable domain entity.\"\"\"\n    name: str\n    version: str\n    workflows: tuple[Workflow, ...]\n    def __post_init__(self) -> None:\n        if not DefinitionRules.is_valid_name(self.name):\n            raise InvalidFormatError(f\"Invalid name: {self.name}\")\nDomain Errors:\nclass DefinitionError(Exception):\n    \"\"\"Base error for Agent Definition issues.\"\"\"\nclass InvalidFormatError(DefinitionError):\n    \"\"\"Field format validation error.\"\"\"\nclass CyclicDependencyError(DefinitionError):\n    \"\"\"Workflow contains cycles.\"\"\"","application-layer#Application Layer":"Location: ainalyn/application/Orchestrates domain logic via port interfaces.Ports - Define contracts:\nclass IDefinitionSchemaValidator(Protocol):\n    \"\"\"Port for schema validation capability.\"\"\"\n    def validate_schema(self, definition: AgentDefinition) -> tuple[ValidationError, ...]: ...\nServices - Orchestrate via dependency injection:\nclass DefinitionService:\n    def __init__(\n        self,\n        schema_validator: IDefinitionSchemaValidator,  # Port, not concrete\n        static_analyzer: IDefinitionAnalyzer,\n        serializer: IDefinitionSerializer,\n    ):\n        self._schema_validator = schema_validator\n        # ...","adapters-layer#Adapters Layer":"Location: ainalyn/adapters/Inbound - Entry points (Builders):\nclass AgentBuilder:\n    \"\"\"Fluent builder for Agent Definitions.\"\"\"\n    def version(self, version: str) -> AgentBuilder:\n        self._version = version\n        return self\n    def build(self) -> AgentDefinition:\n        return AgentDefinition(name=self._name, ...)\nOutbound - External capabilities:\nclass YamlSerializer:\n    \"\"\"Implements IDefinitionSerializer port.\"\"\"\n    def serialize(self, definition: AgentDefinition) -> str:\n        return yaml.dump(self._to_dict(definition))","infrastructure-layer#Infrastructure Layer":"Location: ainalyn/infrastructure/Wires concrete adapters to ports:\ndef create_default_service() -> DefinitionService:\n    return DefinitionService(\n        schema_validator=SchemaValidator(),  # Concrete adapter\n        static_analyzer=StaticAnalyzer(),\n        serializer=YamlSerializer(),\n    )","related-pages#Related Pages":"System Context - SDK's role in the overall system\nCompilation Flow - How data flows through the SDK","further-reading#Further Reading":"Hexagonal Architecture - Original concept by Alistair Cockburn\nCONTRIBUTING.md - Contribution guidelines"}},"/v1/advanced/compilation-flow":{"title":"Compilation Flow","data":{"":"This page explains how data flows through the SDK when compiling an Agent Definition.","overview#Overview":"The compilation process follows a clear pipeline:\n┌──────────────────────────────────────────────────────────────────────────────┐\n│                           SDK User (Developer)                                │\n└──────────────────────────────────┬───────────────────────────────────────────┘\n                                   │\n                                   ▼\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ 1. BUILD                                                                      │\n│    ┌────────────────┐                                                        │\n│    │  AgentBuilder  │  (Inbound Adapter)                                     │\n│    │  .version()    │                                                        │\n│    │  .add_workflow()                                                        │\n│    │  .build()      │────────────────────────────────────────────────────┐   │\n│    └────────────────┘                                                    │   │\n└──────────────────────────────────────────────────────────────────────────┼───┘\n                                                                           │\n                                   ▼                                       │\n┌──────────────────────────────────────────────────────────────────────────┼───┐\n│ 2. CREATE DOMAIN ENTITY                                                  │   │\n│    ┌────────────────────────────────────────────────────────────────┐    │   │\n│    │  AgentDefinition (Domain Entity)                               │◀───┘   │\n│    │  - Immutable (frozen dataclass)                                │        │\n│    │  - Self-validating via __post_init__                           │        │\n│    │  - Contains: workflows, prompts, tools, modules                │        │\n│    └────────────────────────────────────────────────────────────────┘        │\n└──────────────────────────────────┬───────────────────────────────────────────┘\n                                   │\n                                   ▼\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ 3. COMPILE via API                                                            │\n│    ┌────────────────┐      ┌───────────────────────────────────────────┐     │\n│    │ compile_agent()│─────▶│  DefinitionService (Application Service)  │     │\n│    │ (api.py)       │      │                                           │     │\n│    └────────────────┘      │  Orchestrates via Outbound Ports:         │     │\n│                            │  - IDefinitionSchemaValidator             │     │\n│                            │  - IDefinitionAnalyzer                    │     │\n│                            │  - IDefinitionSerializer                  │     │\n│                            └───────────────────┬───────────────────────┘     │\n└────────────────────────────────────────────────┼─────────────────────────────┘\n                                                 │\n            ┌────────────────────────────────────┼────────────────────────────┐\n            │                                    │                            │\n            ▼                                    ▼                            ▼\n┌───────────────────────┐         ┌───────────────────────┐    ┌─────────────────────┐\n│ 4a. VALIDATE          │         │ 4b. ANALYZE           │    │ 4c. SERIALIZE       │\n│ ┌───────────────────┐ │         │ ┌───────────────────┐ │    │ ┌─────────────────┐ │\n│ │ SchemaValidator   │ │         │ │ StaticAnalyzer    │ │    │ │ YamlExporter    │ │\n│ │ (Outbound Adapter)│ │         │ │ (Outbound Adapter)│ │    │ │ (Outbound       │ │\n│ └───────────────────┘ │         │ └───────────────────┘ │    │ │  Adapter)       │ │\n│ - Structure checks    │         │ - DAG validation      │    │ └─────────────────┘ │\n│ - Required fields     │         │ - Reference integrity │    │ - Domain → YAML     │\n│ - Type validation     │         │ - Unused detection    │    │ - Platform format   │\n└───────────────────────┘         └───────────────────────┘    └─────────────────────┘\n            │                                    │                            │\n            └────────────────────────────────────┼────────────────────────────┘\n                                                 │\n                                                 ▼\n┌──────────────────────────────────────────────────────────────────────────────┐\n│ 5. OUTPUT                                                                     │\n│    ┌────────────────────────────────────────────────────────────────────┐    │\n│    │  CompilationResult                                                 │    │\n│    │  - validation_result: ValidationResult (errors, warnings)          │    │\n│    │  - yaml_content: str | None (only if valid)                        │    │\n│    │  - is_successful: bool                                             │    │\n│    └────────────────────────────────────────────────────────────────────┘    │\n│                                         │                                     │\n│                                         ▼                                     │\n│                              ┌─────────────────────┐                          │\n│                              │  agent.yaml file    │  ──▶  Submit to Platform │\n│                              └─────────────────────┘                          │\n└──────────────────────────────────────────────────────────────────────────────┘","step-by-step-breakdown#Step-by-Step Breakdown":"","step-1-build#Step 1: Build":"Developers use fluent builders to construct their agent:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My first agent\")\n    .add_workflow(\n        WorkflowBuilder(\"main\")\n        .add_node(NodeBuilder(\"start\").type(\"llm\").build())\n        .build()\n    )\n    .build()  # ← Returns AgentDefinition\n)\nWhat happens:\nAgentBuilder is an Inbound Adapter\nCollects configuration via fluent methods\n.build() creates an immutable AgentDefinition","step-2-create-domain-entity#Step 2: Create Domain Entity":"The builder creates an AgentDefinition domain entity:\n@dataclass(frozen=True)\nclass AgentDefinition:\n    name: str\n    version: str\n    description: str\n    workflows: tuple[Workflow, ...]\n    def __post_init__(self) -> None:\n        # Domain validation runs immediately\n        if not DefinitionRules.is_valid_name(self.name):\n            raise InvalidFormatError(...)\nWhat happens:\nEntity is created as frozen (immutable)\n__post_init__ runs domain validation\nInvalid entities cannot exist","step-3-compile-via-api#Step 3: Compile via API":"Developer calls the high-level API:\nfrom ainalyn import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nWhat happens:\ncompile_agent() is an Inbound Adapter (public API)\nGets DefinitionService from infrastructure\nDelegates to service for orchestration\nInternal flow:\n# api.py\ndef compile_agent(definition, output_path=None):\n    service = _get_service()  # From infrastructure\n    if output_path:\n        return service.compile_to_file(definition, output_path)\n    return service.compile(definition)","step-4a-schema-validation#Step 4a: Schema Validation":"SchemaValidator checks structural correctness:\nclass SchemaValidator:\n    \"\"\"Outbound Adapter implementing IDefinitionSchemaValidator\"\"\"\n    def validate_schema(self, definition: AgentDefinition) -> tuple[ValidationError, ...]:\n        errors = []\n        # Required fields\n        if not definition.workflows:\n            errors.append(ValidationError(\"E001\", \"At least one workflow required\"))\n        # Type validation\n        for workflow in definition.workflows:\n            if not workflow.nodes:\n                errors.append(ValidationError(\"E002\", f\"Workflow '{workflow.name}' has no nodes\"))\n        return tuple(errors)\nChecks performed:\nRequired fields present\nType correctness\nValue constraints\nStructural integrity","step-4b-static-analysis#Step 4b: Static Analysis":"StaticAnalyzer checks logical correctness:\nclass StaticAnalyzer:\n    \"\"\"Outbound Adapter implementing IDefinitionAnalyzer\"\"\"\n    def analyze(self, definition: AgentDefinition) -> tuple[AnalysisIssue, ...]:\n        issues = []\n        for workflow in definition.workflows:\n            # DAG validation\n            if self._has_cycles(workflow):\n                issues.append(AnalysisIssue(\"W001\", f\"Workflow '{workflow.name}' has cycles\"))\n            # Reference integrity\n            for edge in workflow.edges:\n                if not self._node_exists(workflow, edge.to):\n                    issues.append(AnalysisIssue(\"E010\", f\"Edge references unknown node '{edge.to}'\"))\n        return tuple(issues)\nChecks performed:\nWorkflow is a DAG (no cycles)\nAll references resolve\nNo orphan nodes\nNo unused definitions","step-4c-serialization#Step 4c: Serialization":"YamlExporter converts domain to YAML:\nclass YamlExporter:\n    \"\"\"Outbound Adapter implementing IDefinitionSerializer\"\"\"\n    def serialize(self, definition: AgentDefinition) -> str:\n        data = {\n            \"name\": definition.name,\n            \"version\": definition.version,\n            \"description\": definition.description,\n            \"workflows\": [\n                self._serialize_workflow(w) for w in definition.workflows\n            ],\n        }\n        return yaml.dump(data, sort_keys=False)\nWhat happens:\nDomain entities → Python dicts\nDicts → YAML string\nPlatform-compatible format","step-5-output#Step 5: Output":"CompilationResult contains the outcome:\n@dataclass\nclass CompilationResult:\n    validation_result: ValidationResult\n    yaml_content: str | None  # None if validation failed\n    output_path: Path | None  # Set if written to file\n    @property\n    def is_successful(self) -> bool:\n        return self.validation_result.is_valid\nUsage:\nresult = compile_agent(agent)\nif result.is_successful:\n    print(result.yaml_content)\n    # Submit to platform\nelse:\n    for error in result.validation_result.errors:\n        print(f\"{error.code}: {error.message}\")","validation-layers#Validation Layers":"The SDK has multiple validation layers, each with a specific responsibility:\nLayer\tLocation\tWhen\tPurpose\tDomain\tdomain/entities/\tEntity creation\tInvariants that must always hold\tSchema\tadapters/outbound/schema_validator.py\tCompilation\tStructural correctness\tStatic Analysis\tadapters/outbound/static_analyzer.py\tCompilation\tLogical correctness","domain-validation-example#Domain Validation Example":"# Cannot create invalid entity\nAgentDefinition(name=\"invalid name!\")  # Raises InvalidFormatError","schema-validation-example#Schema Validation Example":"# Valid entity, but missing required fields for platform\nagent = AgentBuilder(\"test\").build()  # Missing version\nresult = compile_agent(agent)\n# result.validation_result.errors contains \"version required\"","static-analysis-example#Static Analysis Example":"# Valid structure, but logical error\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"a\").build())\n    .add_node(NodeBuilder(\"b\").build())\n    .add_edge(\"a\", \"b\")\n    .add_edge(\"b\", \"a\")  # Creates cycle!\n    .build()\n)\nresult = compile_agent(agent)\n# result.validation_result.errors contains \"cycle detected\"","error-handling#Error Handling":"","error-categories#Error Categories":"Category\tCode Range\tExample\tDomain Errors\tExceptions\tInvalidFormatError, CyclicDependencyError\tSchema Errors\tE001-E099\tMissing required field\tAnalysis Errors\tE100-E199\tInvalid reference\tAnalysis Warnings\tW001-W099\tUnused definition","error-response#Error Response":"result = compile_agent(agent)\nif not result.is_successful:\n    for error in result.validation_result.errors:\n        print(f\"[{error.code}] {error.message}\")\n        print(f\"  Location: {error.location}\")\n        print(f\"  Suggestion: {error.suggestion}\")","related-pages#Related Pages":"Hexagonal Architecture - How components are organized\nSystem Context - SDK's role in the system\nValidation Guide - User-facing validation docs"}},"/v1/api-reference/api":{"title":"API Reference","data":{"":"Main API functions for validating and exporting agent definitions.","validate#validate()":"Validates an agent definition structure and logic.\nfrom ainalyn.api import validate\nresult = validate(agent)","signature#Signature":"def validate(definition: AgentDefinition) -> ValidationResult","parameters#Parameters":"definition (required) - AgentDefinition instance to validate","returns#Returns":"ValidationResult object with the following properties:\nProperty\tType\tDescription\tis_valid\tbool\tTrue if no errors found\thas_warnings\tbool\tTrue if warnings present\terrors\ttuple[ValidationError, ...]\tAll errors and warnings","validationerror-structure#ValidationError Structure":"Each error in result.errors contains:\nProperty\tType\tDescription\tcode\tstr\tError code (see Error Codes below)\tmessage\tstr\tHuman-readable error message\tseverity\tSeverity\tERROR or WARNING\tlocation\tstr | None\tOptional location where error occurred","validation-process#Validation Process":"The function performs two validation phases:1. Schema Validation\nChecks structural correctness\nVerifies all required fields present\nValidates field types and formats\n2. Static Analysis\nDetects cycles in workflows (DAG requirement)\nIdentifies unreachable nodes\nVerifies all references resolve","error-codes#Error Codes":"","schema-validation-errors#Schema Validation Errors":"Code\tSeverity\tDescription\tMISSING_FIELD\tERROR\tRequired field not provided\tINVALID_FORMAT\tERROR\tValue doesn't match required format\tDUPLICATE_NAME\tERROR\tName used multiple times in scope\tEMPTY_COLLECTION\tERROR\tRequired collection is empty","static-analysis-errors#Static Analysis Errors":"Code\tSeverity\tDescription\tCYCLIC_DEPENDENCY\tERROR\tWorkflow contains cycle (not a DAG)\tUNREACHABLE_NODE\tERROR\tNode cannot be reached from entry\tREFERENCE_ERROR\tERROR\tResource reference not found\tORPHANED_RESOURCE\tWARNING\tResource defined but never used","example#Example":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate\n# Build agent\nprompt = PromptBuilder(\"task-prompt\").description(\"Task\").template(\"Do task\").build()\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .description(\"Main workflow\")\n    .add_node(\n        NodeBuilder(\"task\")\n        .description(\"Execute task\")\n        .uses_prompt(\"task-prompt\")\n        .build()\n    )\n    .entry_node(\"task\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nresult = validate(agent)\nif result.is_valid:\n    print(\"Validation passed\")\nelse:\n    print(\"Validation failed:\")\n    for error in result.errors:\n        print(f\"  [{error.severity}] {error.code}: {error.message}\")\n        if error.location:\n            print(f\"    Location: {error.location}\")","error-handling#Error Handling":"result = validate(agent)\n# Check overall validity\nif not result.is_valid:\n    # Has errors - cannot proceed\n    for error in result.errors:\n        if error.severity == Severity.ERROR:\n            print(f\"ERROR: {error.message}\")\n# Check warnings\nif result.has_warnings:\n    # Has warnings - can proceed but should review\n    for error in result.errors:\n        if error.severity == Severity.WARNING:\n            print(f\"WARNING: {error.message}\")","export_yaml#export_yaml()":"Exports an agent definition to YAML string.\nfrom ainalyn.api import export_yaml\nyaml_output = export_yaml(agent)","signature-1#Signature":"def export_yaml(definition: AgentDefinition) -> str","parameters-1#Parameters":"definition (required) - AgentDefinition instance to export","returns-1#Returns":"YAML-formatted string with header comments","important-notes#Important Notes":"Does NOT validate before export\nFor validation + export, use compile_agent() instead\nOutput includes header comments explaining SDK boundary","output-format#Output Format":"# Ainalyn Agent Definition\n# This file is a description submitted to Platform Core for review.\n# It does NOT execute by itself. Execution is handled by Platform Core.\n#\n# Local compilation does NOT equal platform execution.\nname: my-agent\nversion: 1.0.0\ndescription: Agent description\nworkflows:\n  - name: main\n    description: Main workflow\n    entry_node: task\n    nodes:\n      - name: task\n        description: Task node\n        type: prompt\n        reference: task-prompt\nprompts:\n  - name: task-prompt\n    description: Task prompt\n    template: Do the task","example-1#Example":"from ainalyn import AgentBuilder\nfrom ainalyn.api import export_yaml\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_workflow(workflow)\n    .build()\n)\nyaml_str = export_yaml(agent)\nprint(yaml_str)\n# Write to file\nwith open(\"agent.yaml\", \"w\") as f:\n    f.write(yaml_str)","compile_agent#compile_agent()":"Validates and exports an agent definition (recommended workflow).\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))","signature-2#Signature":"def compile_agent(\n    definition: AgentDefinition,\n    output_path: Path | None = None\n) -> CompilationResult","parameters-2#Parameters":"definition (required) - AgentDefinition instance to compile\noutput_path (optional) - Path to write YAML file. If None, only returns YAML without writing.","returns-2#Returns":"CompilationResult object with the following properties:\nProperty\tType\tDescription\tvalidation_result\tValidationResult\tValidation results\tyaml_content\tstr | None\tYAML string if successful, None if validation failed\toutput_path\tPath | None\tFile path if written, None otherwise\tis_successful\tbool\tTrue if validation passed","compilation-workflow#Compilation Workflow":"Validate definition (schema + static analysis)\nExport to YAML (only if validation passes)\nWrite to file (if output_path provided)","important-note#Important Note":"Local compilation does NOT equal platform execution. This creates a description for platform submission. Platform Core applies additional validation and governance policies.","example-compile-to-string#Example: Compile to String":"from ainalyn import AgentBuilder\nfrom ainalyn.api import compile_agent\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .add_workflow(workflow)\n    .build()\n)\n# Compile without writing file\nresult = compile_agent(agent)\nif result.is_successful:\n    print(\"Compilation successful!\")\n    print(result.yaml_content)\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.code}: {error.message}\")","example-compile-to-file#Example: Compile to File":"from ainalyn.api import compile_agent\nfrom pathlib import Path\n# Compile and write to file\nresult = compile_agent(agent, Path(\"output/agent.yaml\"))\nif result.is_successful:\n    print(f\"Compiled successfully to {result.output_path}\")\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.code}: {error.message}\")","error-handling-1#Error Handling":"from ainalyn.api import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\n# Check success\nif result.is_successful:\n    # Validation passed, YAML generated and written\n    print(f\"Success! File: {result.output_path}\")\n    print(f\"YAML content:\\n{result.yaml_content}\")\nelse:\n    # Validation failed, no YAML generated\n    print(\"Compilation failed with errors:\")\n    for error in result.validation_result.errors:\n        print(f\"\\n[{error.severity}] {error.code}\")\n        print(f\"  Message: {error.message}\")\n        if error.location:\n            print(f\"  Location: {error.location}\")","complete-error-reference#Complete Error Reference":"","build-time-errors#Build-Time Errors":"These errors occur when calling .build() on builders:","missingfielderror#MissingFieldError":"Cause: Required field not providedExample:\nagent = AgentBuilder(\"test\").build()  # Missing version and description\nError Message:\nMissingFieldError: Required field 'version' is missing or empty in AgentBuilder\nFix:\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test agent\")\n    .build()\n)","invalidformaterror#InvalidFormatError":"Cause: Value doesn't match required formatExample:\nagent = AgentBuilder(\"Invalid Name\")  # Uppercase and space\nError Message:\nInvalidFormatError: Invalid value for 'name': 'Invalid Name'.\nAgent name must start with lowercase letter and contain only lowercase letters, numbers, and hyphens\nFix:\nagent = AgentBuilder(\"invalid-name\")  # Lowercase with hyphens","duplicateerror#DuplicateError":"Cause: Name used multiple times in same scopeExample:\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task\").description(\"Task 1\").uses_prompt(\"p1\").build())\n    .add_node(NodeBuilder(\"task\").description(\"Task 2\").uses_prompt(\"p2\").build())\n    .build()\n)\nError Message:\nDuplicateError: Duplicate node name 'task' in workflow 'main'.\nEach node must have a unique name within its scope.\nFix:\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task-1\").description(\"Task 1\").uses_prompt(\"p1\").build())\n    .add_node(NodeBuilder(\"task-2\").description(\"Task 2\").uses_prompt(\"p2\").build())\n    .build()\n)","referenceerror#ReferenceError":"Cause: Node references undefined resourceExample:\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test\")\n    .add_workflow(\n        WorkflowBuilder(\"main\")\n        .add_node(\n            NodeBuilder(\"task\")\n            .description(\"Task\")\n            .uses_prompt(\"undefined-prompt\")  # Prompt not defined\n            .build()\n        )\n        .entry_node(\"task\")\n        .build()\n    )\n    .build()\n)\nError Message:\nReferenceError: 'task' references undefined prompt 'undefined-prompt'.\nThe prompt must be defined in the agent.\nFix:\nprompt = PromptBuilder(\"my-prompt\").description(\"Prompt\").template(\"Text\").build()\nagent = (\n    AgentBuilder(\"test\")\n    .add_prompt(prompt)  # Define the prompt\n    .add_workflow(...)\n    .build()\n)","emptycollectionerror#EmptyCollectionError":"Cause: Required collection is emptyExample:\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test\")\n    .build()  # No workflows added\n)\nError Message:\nEmptyCollectionError: 'Agent 'test'' has no workflows.\nAt least one workflow is required.\nFix:\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test\")\n    .add_workflow(workflow)  # Add at least one workflow\n    .build()\n)","validation-errors#Validation Errors":"These errors occur during validate():","cyclicdependencyerror#CyclicDependencyError":"Cause: Workflow contains cycleDetection: Static analysis finds cycle in node graphExample:\n# node-a → node-b → node-c → node-a (cycle!)\nError Message:\nCyclicDependencyError: Workflow contains a cycle: node-a → node-b → node-c → node-a\nFix: Remove cycle by restructuring workflow to form a DAG","unreachablenodeerror#UnreachableNodeError":"Cause: Node cannot be reached from entry nodeDetection: Static analysis finds node with no path from entryExample:\n# entry-node → task-a\n# orphan-node (unreachable)\nError Message:\nUnreachableNodeError: Node 'orphan-node' is unreachable from entry node 'entry-node'.\nAll nodes must be reachable via edges.\nFix: Connect node to workflow or remove it","best-practices#Best Practices":"","1-use-compile_agent-for-production#1. Use compile_agent() for Production":"Recommended approach combines validation and export:\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    # Safe to submit to platform\n    submit_to_platform(result.output_path)\nelse:\n    # Fix errors before submission\n    handle_errors(result.validation_result.errors)","2-validate-during-development#2. Validate During Development":"Validate after each major change:\n# After adding workflow\nagent = agent.add_workflow(workflow)\nresult = validate(agent.build())\nassert result.is_valid\n# After adding resources\nagent = agent.add_prompt(prompt)\nresult = validate(agent.build())\nassert result.is_valid","3-handle-errors-specifically#3. Handle Errors Specifically":"from ainalyn.domain.errors import (\n    MissingFieldError,\n    InvalidFormatError,\n    ReferenceError,\n)\ntry:\n    agent = builder.build()\nexcept MissingFieldError as e:\n    print(f\"Missing required field: {e.field_name}\")\nexcept InvalidFormatError as e:\n    print(f\"Invalid {e.field_name}: {e.value}\")\n    print(f\"Constraint: {e.constraint}\")\nexcept ReferenceError as e:\n    print(f\"Undefined {e.resource_type}: {e.reference}\")","4-review-generated-yaml#4. Review Generated YAML":"Always inspect output before submission:\nyaml = export_yaml(agent)\nprint(yaml)  # Verify structure matches intent","submit_agent#submit_agent()":"Submits an agent definition to Platform Core for review.\nfrom ainalyn.api import submit_agent\nresult = submit_agent(agent, api_key=\"dev_sk_xxx\")","signature-3#Signature":"def submit_agent(\n    definition: AgentDefinition,\n    api_key: str,\n    *,\n    base_url: str | None = None,\n    auto_deploy: bool = False\n) -> SubmissionResult","parameters-3#Parameters":"definition (required) - AgentDefinition instance to submit\napi_key (required) - Developer API key for authentication\nbase_url (optional) - Platform Core API base URL (defaults to production)\nauto_deploy (optional) - Auto-deploy after approval (default: False)","returns-3#Returns":"SubmissionResult object with the following properties:\nProperty\tType\tDescription\treview_id\tstr\tUnique identifier for tracking\tstatus\tSubmissionStatus\tCurrent review status\tagent_id\tstr | None\tAssigned agent ID after approval\ttracking_url\tstr | None\tURL to track progress\tmarketplace_url\tstr | None\tURL if agent is live\tfeedback\ttuple\tFeedback items from Platform Core\tis_accepted\tbool\tTrue if accepted for review\tis_live\tbool\tTrue if published to marketplace\tis_rejected\tbool\tTrue if rejected","submission-workflow#Submission Workflow":"Validates the definition (SDK-level validation)\nExports to YAML format\nSubmits to Platform Core API","important---platform-constitution#Important - Platform Constitution":"SDK can submit but NOT approve (Platform Core has final authority)\nSubmission does NOT create an Execution\nSubmission does NOT incur billing (unless platform policy states)","example-2#Example":"from ainalyn import AgentBuilder\nfrom ainalyn.api import submit_agent\nfrom ainalyn.domain.entities import EIPDependency, CompletionCriteria\n# Build agent with Platform submission requirements\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .task_goal(\"Process and analyze user input\")\n    .completion_criteria(CompletionCriteria(\n        success=\"Output generated successfully\",\n        failure=\"Processing failed\"\n    ))\n    .add_eip_dependency(EIPDependency(\n        provider=\"openai\",\n        service=\"gpt-4\",\n        version=\">=1.0.0\"\n    ))\n    .add_workflow(workflow)\n    .build()\n)\n# Submit to Platform Core\nresult = submit_agent(agent, api_key=\"dev_sk_xxx\")\nif result.is_accepted:\n    print(f\"Submitted for review!\")\n    print(f\"Review ID: {result.review_id}\")\n    print(f\"Track at: {result.tracking_url}\")\nelse:\n    print(\"Submission rejected\")\n    for feedback in result.feedback:\n        print(f\"  - {feedback.message}\")","error-handling-2#Error Handling":"from ainalyn.domain.errors import (\n    SubmissionError,\n    AuthenticationError,\n    NetworkError,\n)\ntry:\n    result = submit_agent(agent, api_key=\"dev_sk_xxx\")\nexcept AuthenticationError as e:\n    print(f\"Invalid API key: {e.message}\")\nexcept NetworkError as e:\n    print(f\"Network error: {e.message}\")\nexcept SubmissionError as e:\n    print(f\"Submission failed: {e.message}\")\n    if e.validation_errors:\n        for err in e.validation_errors:\n            print(f\"  - {err.message}\")","track_submission#track_submission()":"Tracks the status of a submitted agent definition.\nfrom ainalyn.api import track_submission\nresult = track_submission(review_id=\"review_abc123\", api_key=\"dev_sk_xxx\")","signature-4#Signature":"def track_submission(\n    review_id: str,\n    api_key: str,\n    *,\n    base_url: str | None = None\n) -> SubmissionResult","parameters-4#Parameters":"review_id (required) - Review ID returned from submit_agent()\napi_key (required) - Developer API key for authentication\nbase_url (optional) - Platform Core API base URL","returns-4#Returns":"SubmissionResult object with current status and feedback.","example-3#Example":"from ainalyn.api import track_submission\nfrom ainalyn.domain.entities import SubmissionStatus\n# Check submission status\nresult = track_submission(review_id=\"review_abc123\", api_key=\"dev_sk_xxx\")\nprint(f\"Status: {result.status.value}\")\nif result.status == SubmissionStatus.ACCEPTED:\n    print(f\"Agent approved! ID: {result.agent_id}\")\nelif result.status == SubmissionStatus.DEPLOYED:\n    print(f\"Agent is live: {result.marketplace_url}\")\nelif result.status == SubmissionStatus.REJECTED:\n    print(\"Rejected. Feedback:\")\n    for issue in result.get_blocking_issues():\n        print(f\"  [{issue.severity.value}] {issue.message}\")\nelif result.status == SubmissionStatus.PENDING_REVIEW:\n    print(\"Still under review...\")","note#Note":"Currently uses MockPlatformClient for testing until Platform Core API is available. Real HTTP communication will be enabled in future versions.","related-documentation#Related Documentation":"Builders API - Builder methods and parameters\nEntities Reference - Domain entities including EIP types\nError Handling - Comprehensive error guide\nValidation Guide - Detailed validation rules\nHow the SDK Works - Compilation process"}},"/v1/api-reference/builders":{"title":"Builders API","data":{"":"Builders provide a fluent API for creating agent definitions with immediate validation.","agentbuilder#AgentBuilder":"Creates an agent definition.\nfrom ainalyn import AgentBuilder\nagent = (\n    AgentBuilder(\"my-agent\")\n    .description(\"What the agent does\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)","constructor#Constructor":"AgentBuilder(name: str)\nParameters:\nname (required) - Agent identifier. Must match pattern [a-z][a-z0-9-]*\nRaises:\nInvalidFormatError - If name doesn't match required pattern","methods#Methods":"","descriptiontext-str---self#.description(text: str) -> Self":"Set agent description.Parameters:\ntext (required) - Human-readable description of what this agent does\nReturns: Self for method chainingRequired: Yes","versionversion-str---self#.version(version: str) -> Self":"Set agent version.Parameters:\nversion (required) - Semantic version string (e.g., \"1.0.0\")\nReturns: Self for method chainingRequired: YesRaises:\nInvalidFormatError - If version doesn't follow semantic versioning","add_workflowworkflow-workflow---self#.add_workflow(workflow: Workflow) -> Self":"Add a workflow to this agent.Parameters:\nworkflow (required) - Workflow instance created with WorkflowBuilder\nReturns: Self for method chainingRequired: At least one workflow requiredRaises:\nDuplicateError - If workflow name already exists in this agent","workflowsworkflows-workflow---self#.workflows(*workflows: Workflow) -> Self":"Set all workflows at once.Parameters:\n*workflows (required) - Variable number of Workflow instances\nReturns: Self for method chainingRaises:\nDuplicateError - If any workflow names are duplicated","add_promptprompt-prompt---self#.add_prompt(prompt: Prompt) -> Self":"Add a prompt template to this agent.Parameters:\nprompt (required) - Prompt instance created with PromptBuilder\nReturns: Self for method chainingRequired: No (optional)Raises:\nDuplicateError - If prompt name already exists in this agent","promptsprompts-prompt---self#.prompts(*prompts: Prompt) -> Self":"Set all prompts at once.Parameters:\n*prompts (required) - Variable number of Prompt instances\nReturns: Self for method chainingRaises:\nDuplicateError - If any prompt names are duplicated","add_tooltool-tool---self#.add_tool(tool: Tool) -> Self":"Add a tool definition to this agent.Parameters:\ntool (required) - Tool instance created with ToolBuilder\nReturns: Self for method chainingRequired: No (optional)Raises:\nDuplicateError - If tool name already exists in this agent","toolstools-tool---self#.tools(*tools: Tool) -> Self":"Set all tools at once.Parameters:\n*tools (required) - Variable number of Tool instances\nReturns: Self for method chainingRaises:\nDuplicateError - If any tool names are duplicated","add_modulemodule-module---self#.add_module(module: Module) -> Self":"Add a reusable module to this agent.Parameters:\nmodule (required) - Module instance created with ModuleBuilder\nReturns: Self for method chainingRequired: No (optional)Raises:\nDuplicateError - If module name already exists in this agent","modulesmodules-module---self#.modules(*modules: Module) -> Self":"Set all modules at once.Parameters:\n*modules (required) - Variable number of Module instances\nReturns: Self for method chainingRaises:\nDuplicateError - If any module names are duplicated","task_goalgoal-str---self#.task_goal(goal: str) -> Self":"Set the high-level task goal for Platform Review Gate 1.Parameters:\ngoal (required) - Human-readable description of what task this agent accomplishes\nReturns: Self for method chainingRequired: No (but recommended for Platform submission)Example:\n.task_goal(\"Convert meeting audio recordings into structured text transcripts with timestamps\")","completion_criteriacriteria-completioncriteria---self#.completion_criteria(criteria: CompletionCriteria) -> Self":"Set success/failure conditions for Platform Review Gate 1.Parameters:\ncriteria (required) - CompletionCriteria instance defining success and failure conditions\nReturns: Self for method chainingRequired: No (but recommended for Platform submission)Example:\nfrom ainalyn.domain.entities import CompletionCriteria\n.completion_criteria(CompletionCriteria(\n    success=\"Complete transcript with timestamps generated\",\n    failure=\"Audio format unsupported or speech unrecognizable\"\n))","add_eip_dependencydependency-eipdependency---self#.add_eip_dependency(dependency: EIPDependency) -> Self":"Add an EIP dependency for Platform Review Gate 5.Parameters:\ndependency (required) - EIPDependency instance\nReturns: Self for method chainingRequired: No (but required if agent uses external EIP services)Example:\nfrom ainalyn.domain.entities import EIPDependency\n.add_eip_dependency(EIPDependency(\n    provider=\"openai\",\n    service=\"whisper\",\n    version=\">=1.0.0\",\n    config_hints={\"streaming\": True, \"model\": \"whisper-1\"}\n))","build---agentdefinition#.build() -> AgentDefinition":"Build and return immutable AgentDefinition.Returns: AgentDefinition instanceRaises:\nMissingFieldError - If required fields (version, description) not set\nEmptyCollectionError - If no workflows added\nReferenceError - If nodes reference undefined resources","naming-convention#Naming Convention":"Agent names must match pattern: [a-z][a-z0-9-]*Valid names:\nmy-agent\ndata-processor\nemail-extractor-v2\nInvalid names:\nMyAgent (uppercase)\nmy_agent (underscore)\n123agent (starts with number)\nmy agent (space)","workflowbuilder#WorkflowBuilder":"Creates a workflow definition.\nfrom ainalyn import WorkflowBuilder, NodeBuilder\nworkflow = (\n    WorkflowBuilder(\"main-flow\")\n    .description(\"Main workflow\")\n    .add_node(\n        NodeBuilder(\"task1\")\n        .description(\"Complete task 1\")\n        .uses_prompt(\"task-prompt\")\n        .build()\n    )\n    .entry_node(\"task1\")\n    .build()\n)","constructor-1#Constructor":"WorkflowBuilder(name: str)\nParameters:\nname (required) - Workflow identifier. Must match pattern [a-z][a-z0-9-]*\nRaises:\nInvalidFormatError - If name doesn't match required pattern","methods-1#Methods":"","descriptiontext-str---self-1#.description(text: str) -> Self":"Set workflow description.Parameters:\ntext (required) - Human-readable description of workflow purpose\nReturns: Self for method chainingRequired: Yes","add_nodenode-node---self#.add_node(node: Node) -> Self":"Add a node to this workflow.Parameters:\nnode (required) - Node instance created with NodeBuilder\nReturns: Self for method chainingRequired: At least one node requiredRaises:\nDuplicateError - If node name already exists in this workflow","nodesnodes-node---self#.nodes(*nodes: Node) -> Self":"Set all nodes at once.Parameters:\n*nodes (required) - Variable number of Node instances\nReturns: Self for method chainingRaises:\nDuplicateError - If any node names are duplicated","entry_nodename-str---self#.entry_node(name: str) -> Self":"Set the starting node for this workflow.Parameters:\nname (required) - Name of the node that serves as workflow entry point\nReturns: Self for method chainingRequired: YesRaises:\nReferenceError - If named node doesn't exist in workflow","build---workflow#.build() -> Workflow":"Build and return immutable Workflow.Returns: Workflow instanceRaises:\nMissingFieldError - If required fields (description, entry_node) not set\nEmptyCollectionError - If no nodes added","naming-convention-1#Naming Convention":"Workflow names must match pattern: [a-z][a-z0-9-]*","nodebuilder#NodeBuilder":"Creates a node (individual workflow step).\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"my-task\")\n    .description(\"What this task accomplishes\")\n    .uses_prompt(\"my-prompt\")\n    .inputs(\"input_data\")\n    .outputs(\"result_data\")\n    .next_nodes(\"next-task\")\n    .build()\n)","constructor-2#Constructor":"NodeBuilder(name: str)\nParameters:\nname (required) - Node identifier. Must match pattern [a-z][a-z0-9-]*\nRaises:\nInvalidFormatError - If name doesn't match required pattern","methods-2#Methods":"","descriptiontext-str---self-2#.description(text: str) -> Self":"Set node description.Parameters:\ntext (required) - Human-readable description of what this node does\nReturns: Self for method chainingRequired: Yes","uses_modulename-str---self#.uses_module(name: str) -> Self":"Set this node to use a module.Parameters:\nname (required) - Name of module defined in agent\nReturns: Self for method chainingRequired: Exactly one of uses_module, uses_prompt, or uses_tool requiredNote: Sets node type to \"module\". Cannot be used with uses_prompt() or uses_tool().","uses_promptname-str---self#.uses_prompt(name: str) -> Self":"Set this node to use a prompt.Parameters:\nname (required) - Name of prompt defined in agent\nReturns: Self for method chainingRequired: Exactly one of uses_module, uses_prompt, or uses_tool requiredNote: Sets node type to \"prompt\". Cannot be used with uses_module() or uses_tool().","uses_toolname-str---self#.uses_tool(name: str) -> Self":"Set this node to use a tool.Parameters:\nname (required) - Name of tool defined in agent\nReturns: Self for method chainingRequired: Exactly one of uses_module, uses_prompt, or uses_tool requiredNote: Sets node type to \"tool\". Cannot be used with uses_module() or uses_prompt().","inputsnames-str---self#.inputs(*names: str) -> Self":"Define input parameter names.Parameters:\n*names (optional) - Variable number of input parameter names\nReturns: Self for method chainingRequired: No","outputsnames-str---self#.outputs(*names: str) -> Self":"Define output parameter names.Parameters:\n*names (optional) - Variable number of output parameter names\nReturns: Self for method chainingRequired: No","next_nodesnames-str---self#.next_nodes(*names: str) -> Self":"Specify which nodes follow this one.Parameters:\n*names (optional) - Variable number of node names that can follow this node\nReturns: Self for method chainingRequired: NoNote: Creates directed edges in the workflow DAG.","build---node#.build() -> Node":"Build and return immutable Node.Returns: Node instanceRaises:\nMissingFieldError - If required fields (description, type) not set\nInvalidStateError - If no uses_* method was called","node-types#Node Types":"Node type is determined by resource reference:\nuses_module() → type: \"module\"\nuses_prompt() → type: \"prompt\"\nuses_tool() → type: \"tool\"\nEach node must reference exactly one resource type.","naming-convention-2#Naming Convention":"Node names must match pattern: [a-z][a-z0-9-]*","modulebuilder#ModuleBuilder":"Creates a reusable module definition.\nfrom ainalyn import ModuleBuilder\nmodule = (\n    ModuleBuilder(\"http-client\")\n    .description(\"HTTP request module\")\n    .input_schema({\"type\": \"object\", \"properties\": {\"url\": {\"type\": \"string\"}}})\n    .output_schema({\"type\": \"object\", \"properties\": {\"response\": {\"type\": \"string\"}}})\n    .build()\n)","constructor-3#Constructor":"ModuleBuilder(name: str)\nParameters:\nname (required) - Module identifier. Must match pattern [a-z][a-z0-9-]*\nRaises:\nInvalidFormatError - If name doesn't match required pattern","methods-3#Methods":"","descriptiontext-str---self-3#.description(text: str) -> Self":"Set module description.Parameters:\ntext (required) - Human-readable description of module functionality\nReturns: Self for method chainingRequired: Yes","input_schemaschema-dict---self#.input_schema(schema: dict) -> Self":"Define input JSON Schema.Parameters:\nschema (optional) - JSON Schema dict defining expected input structure\nReturns: Self for method chainingRequired: NoExample:\n.input_schema({\n    \"type\": \"object\",\n    \"properties\": {\n        \"url\": {\"type\": \"string\"},\n        \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\"]}\n    },\n    \"required\": [\"url\"]\n})","output_schemaschema-dict---self#.output_schema(schema: dict) -> Self":"Define output JSON Schema.Parameters:\nschema (optional) - JSON Schema dict defining output structure\nReturns: Self for method chainingRequired: NoExample:\n.output_schema({\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\"type\": \"integer\"},\n        \"body\": {\"type\": \"string\"}\n    }\n})","eip_bindingbinding-eipbinding---self#.eip_binding(binding: EIPBinding) -> Self":"Link this module to a specific EIP provider/service.Parameters:\nbinding (required) - EIPBinding instance specifying provider and service\nReturns: Self for method chainingRequired: No (but recommended for modules that use external services)Example:\nfrom ainalyn.domain.entities import EIPBinding\n.eip_binding(EIPBinding(provider=\"platform\", service=\"audio-segmenter\"))\nNote: EIP binding tells Platform Core which service implementation to use when executing this module.","build---module#.build() -> Module":"Build and return immutable Module.Returns: Module instanceRaises:\nMissingFieldError - If required field (description) not set","naming-convention-3#Naming Convention":"Module names must match pattern: [a-z][a-z0-9-]*","promptbuilder#PromptBuilder":"Creates an LLM prompt template.\nfrom ainalyn import PromptBuilder\nprompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a greeting message\")\n    .template(\"Hello {{name}}! Welcome to {{location}}.\")\n    .variables(\"name\", \"location\")\n    .build()\n)","constructor-4#Constructor":"PromptBuilder(name: str)\nParameters:\nname (required) - Prompt identifier. Must match pattern [a-z][a-z0-9-]*\nRaises:\nInvalidFormatError - If name doesn't match required pattern","methods-4#Methods":"","descriptiontext-str---self-4#.description(text: str) -> Self":"Set prompt description.Parameters:\ntext (required) - Human-readable description of prompt purpose\nReturns: Self for method chainingRequired: Yes","templatetext-str---self#.template(text: str) -> Self":"Set prompt template with variable placeholders.Parameters:\ntext (required) - Template string with {{variable}} placeholders\nReturns: Self for method chainingRequired: YesTemplate Syntax: Use double curly braces {{variable_name}} for placeholders.Example:\n.template(\"\"\"\nAnalyze the sentiment of the following text:\n{{text}}\nProvide a score from -1 (negative) to 1 (positive).\n\"\"\")","variablesnames-str---self#.variables(*names: str) -> Self":"List variable names used in template.Parameters:\n*names (optional) - Variable number of variable names matching template placeholders\nReturns: Self for method chainingRequired: No (but recommended for documentation)Example:\n.variables(\"text\", \"language\", \"format\")","build---prompt#.build() -> Prompt":"Build and return immutable Prompt.Returns: Prompt instanceRaises:\nMissingFieldError - If required fields (description, template) not set","template-variables#Template Variables":"Variables in templates use Jinja2-style syntax: {{variable_name}}Valid variable names: [a-zA-Z_][a-zA-Z0-9_]*Example:\ntemplate = \"Process {{input_data}} using {{model_name}} model\"\nvariables = (\"input_data\", \"model_name\")","naming-convention-4#Naming Convention":"Prompt names must match pattern: [a-z][a-z0-9-]*","toolbuilder#ToolBuilder":"Creates a tool definition (external service).\nfrom ainalyn import ToolBuilder\ntool = (\n    ToolBuilder(\"calculator-tool\")\n    .description(\"Performs mathematical calculations\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"expression\": {\"type\": \"string\"}\n        },\n        \"required\": [\"expression\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"result\": {\"type\": \"number\"}\n        }\n    })\n    .build()\n)","constructor-5#Constructor":"ToolBuilder(name: str)\nParameters:\nname (required) - Tool identifier. Must match pattern [a-z][a-z0-9-]*\nRaises:\nInvalidFormatError - If name doesn't match required pattern","methods-5#Methods":"","descriptiontext-str---self-5#.description(text: str) -> Self":"Set tool description.Parameters:\ntext (required) - Human-readable description of tool functionality\nReturns: Self for method chainingRequired: Yes","input_schemaschema-dict---self-1#.input_schema(schema: dict) -> Self":"Define input JSON Schema.Parameters:\nschema (optional) - JSON Schema dict defining expected input structure\nReturns: Self for method chainingRequired: NoExample:\n.input_schema({\n    \"type\": \"object\",\n    \"properties\": {\n        \"query\": {\"type\": \"string\"},\n        \"max_results\": {\"type\": \"integer\", \"minimum\": 1, \"maximum\": 100}\n    },\n    \"required\": [\"query\"]\n})","output_schemaschema-dict---self-1#.output_schema(schema: dict) -> Self":"Define output JSON Schema.Parameters:\nschema (optional) - JSON Schema dict defining output structure\nReturns: Self for method chainingRequired: NoExample:\n.output_schema({\n    \"type\": \"object\",\n    \"properties\": {\n        \"results\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"string\"}\n        },\n        \"count\": {\"type\": \"integer\"}\n    }\n})","eip_bindingbinding-eipbinding---self-1#.eip_binding(binding: EIPBinding) -> Self":"Link this tool to a specific EIP provider/service.Parameters:\nbinding (required) - EIPBinding instance specifying provider and service\nReturns: Self for method chainingRequired: No (but recommended for tools that use external services)Example:\nfrom ainalyn.domain.entities import EIPBinding\n.eip_binding(EIPBinding(provider=\"openai\", service=\"whisper\"))\nNote: EIP binding tells Platform Core which external service to invoke when executing this tool.","build---tool#.build() -> Tool":"Build and return immutable Tool.Returns: Tool instanceRaises:\nMissingFieldError - If required field (description) not set","naming-convention-5#Naming Convention":"Tool names must match pattern: [a-z][a-z0-9-]*","common-patterns#Common Patterns":"Always call .build()\n# Correct\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\").build()\n# Wrong - missing .build()\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\")\nChain methods\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_workflow(workflow)\n    .build()\n)\nSequential workflow with next_nodes\nprompt1 = PromptBuilder(\"prompt1\").description(\"First\").template(\"Step 1\").build()\nprompt2 = PromptBuilder(\"prompt2\").description(\"Second\").template(\"Step 2\").build()\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Sequential processing\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First step\")\n        .uses_prompt(\"prompt1\")\n        .next_nodes(\"step2\")  # Points to next step\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second step\")\n        .uses_prompt(\"prompt2\")\n        .build()\n    )\n    .entry_node(\"step1\")  # Start at step1\n    .build()\n)\nBranching workflow\n# Node that splits into multiple paths\nworkflow = (\n    WorkflowBuilder(\"branching\")\n    .description(\"Branching workflow\")\n    .add_node(\n        NodeBuilder(\"analyze\")\n        .description(\"Analyze input\")\n        .uses_module(\"analyzer\")\n        .next_nodes(\"path-a\", \"path-b\")  # Multiple next nodes\n        .build()\n    )\n    .add_node(NodeBuilder(\"path-a\").description(\"Path A\").uses_prompt(\"prompt-a\").build())\n    .add_node(NodeBuilder(\"path-b\").description(\"Path B\").uses_prompt(\"prompt-b\").build())\n    .entry_node(\"analyze\")\n    .build()\n)"}},"/v1/api-reference/cli":{"title":"Command Line Interface","data":{"":"The ainalyn CLI provides commands for validating and compiling agents.","installation#Installation":"The CLI is installed automatically with the SDK:\npip install ainalyn-sdk","commands#Commands":"","validate#validate":"Validates an agent definition file.\nainalyn validate agent.py\nArguments:\nfile - Path to Python file containing an AgentDefinition\nExample:\n# agent.py\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nprompt = PromptBuilder(\"my-prompt\").description(\"Test\").template(\"Hello\").build()\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .description(\"Test\")\n    .add_node(NodeBuilder(\"node1\").description(\"Node\").uses_prompt(\"my-prompt\").build())\n    .entry_node(\"node1\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\n$ ainalyn validate agent.py\nValidation successful","compile#compile":"Compiles an agent definition to YAML.\nainalyn compile agent.py -o output.yaml\nArguments:\nfile - Path to Python file\n-o, --output - Output YAML file path (required)\nExample:\n$ ainalyn compile agent.py -o my_agent.yaml\nCompiled successfully to my_agent.yaml","--version#--version":"Shows the SDK version.\nainalyn --version","exit-codes#Exit Codes":"0 - Success\n1 - Validation or compilation failed\n2 - File not found or invalid","common-workflows#Common Workflows":"Validate before deploying:\nainalyn validate agent.py && echo \"Ready to deploy!\"\nCompile multiple agents:\nainalyn compile agent1.py -o agent1.yaml\nainalyn compile agent2.py -o agent2.yaml"}},"/v1/api-reference/entities":{"title":"Entities","data":{"":"Core domain entities represent the structure of agent definitions.","agentdefinition#AgentDefinition":"The complete agent specification.Attributes:\nname (str) - Unique agent identifier (lowercase, hyphens only)\nversion (str) - Version string (e.g., \"1.0.0\")\ndescription (str) - What the agent does\ntask_goal (str | None) - High-level task goal for Platform Review Gate 1 (optional)\ncompletion_criteria (CompletionCriteria | None) - Success/failure conditions (optional)\nworkflows (tuple) - List of workflows (required, at least one)\nmodules (tuple) - Reusable modules (optional)\nprompts (tuple) - LLM prompt templates (optional)\ntools (tuple) - External tool definitions (optional)\neip_dependencies (tuple) - EIP dependencies for Platform Review Gate 5 (optional)\nExample:\nfrom ainalyn.domain.entities import AgentDefinition, CompletionCriteria, EIPDependency\nagent = AgentDefinition(\n    name=\"my-agent\",\n    version=\"1.0.0\",\n    description=\"Does something useful\",\n    task_goal=\"Process and analyze user input\",\n    completion_criteria=CompletionCriteria(\n        success=\"Output generated successfully\",\n        failure=\"Input format invalid or processing failed\"\n    ),\n    workflows=(workflow,),\n    modules=(),\n    prompts=(),\n    tools=(),\n    eip_dependencies=(\n        EIPDependency(provider=\"openai\", service=\"gpt-4\", version=\">=1.0.0\"),\n    )\n)\nNote: Usually created via AgentBuilder, not directly.","workflow#Workflow":"A task execution flow.Attributes:\nname (str) - Workflow identifier\ndescription (str) - What this workflow does (optional)\nentry_node (str) - Which node starts the workflow\nnodes (tuple) - List of nodes in this workflow\nExample:\nfrom ainalyn.domain.entities import Workflow\nworkflow = Workflow(\n    name=\"main\",\n    description=\"Main workflow\",\n    entry_node=\"start\",\n    nodes=(node1, node2)\n)","node#Node":"A single task unit within a workflow.Attributes:\nname (str) - Node identifier\ngoal (str) - What this node should accomplish\ndescription (str) - Additional details (optional)\nnode_type (NodeType) - Type: TASK, MODULE, or SUBWORKFLOW\noutputs (tuple) - Output variable names (optional)\ndependencies (tuple) - Names of nodes this depends on (optional)\nreference (str) - Reference to module/workflow (optional)\nExample:\nfrom ainalyn.domain.entities import Node, NodeType\nnode = Node(\n    name=\"process-data\",\n    goal=\"Process the input data\",\n    description=\"Cleans and validates data\",\n    node_type=NodeType.TASK,\n    outputs=(\"cleaned_data\",),\n    dependencies=(\"load-data\",),\n    reference=None\n)","nodetype#NodeType":"Enum for node types.Values:\nNodeType.TASK - A task node\nNodeType.MODULE - References a module\nNodeType.SUBWORKFLOW - References another workflow\nExample:\nfrom ainalyn.domain.entities import NodeType\n# Use in node creation\nnode_type = NodeType.TASK","module#Module":"A reusable capability unit.Attributes:\nname (str) - Module identifier\ndescription (str) - What this module does\ninput_schema (dict) - JSON Schema for inputs (optional)\noutput_schema (dict) - JSON Schema for outputs (optional)\neip_binding (EIPBinding | None) - Links module to EIP provider/service (optional)\nExample:\nfrom ainalyn.domain.entities import Module, EIPBinding\nmodule = Module(\n    name=\"http-client\",\n    description=\"Makes HTTP requests\",\n    input_schema={\"type\": \"object\", \"properties\": {\"url\": {\"type\": \"string\"}}},\n    output_schema={\"type\": \"object\", \"properties\": {\"body\": {\"type\": \"string\"}}},\n    eip_binding=EIPBinding(provider=\"platform\", service=\"http-client\")\n)","prompt#Prompt":"An LLM prompt template.Attributes:\nname (str) - Prompt identifier\ntemplate (str) - Prompt text with placeholders\nExample:\nfrom ainalyn.domain.entities import Prompt\nprompt = Prompt(\n    name=\"greeting\",\n    template=\"Hello {name}, welcome to {place}!\"\n)","tool#Tool":"An external tool definition.Attributes:\nname (str) - Tool identifier\ndescription (str) - What this tool does\ninput_schema (dict) - JSON Schema for inputs (optional)\noutput_schema (dict) - JSON Schema for outputs (optional)\neip_binding (EIPBinding | None) - Links tool to EIP provider/service (optional)\nExample:\nfrom ainalyn.domain.entities import Tool, EIPBinding\ntool = Tool(\n    name=\"speech-to-text\",\n    description=\"Converts audio to text using OpenAI Whisper\",\n    input_schema={\"type\": \"object\", \"properties\": {\"audio_url\": {\"type\": \"string\"}}},\n    output_schema={\"type\": \"object\", \"properties\": {\"text\": {\"type\": \"string\"}}},\n    eip_binding=EIPBinding(provider=\"openai\", service=\"whisper\")\n)","eipbinding#EIPBinding":"Links a Tool or Module to a specific EIP (Execution Implementation Provider) service.Attributes:\nprovider (str) - EIP provider identifier (e.g., \"openai\", \"anthropic\", \"platform\")\nservice (str) - Service name within the provider (e.g., \"whisper\", \"gpt-4\")\nExample:\nfrom ainalyn.domain.entities import EIPBinding\n# OpenAI Whisper binding\nwhisper_binding = EIPBinding(provider=\"openai\", service=\"whisper\")\n# OpenAI GPT-4 binding\ngpt_binding = EIPBinding(provider=\"openai\", service=\"gpt-4\")\n# Platform-provided service\nplatform_binding = EIPBinding(provider=\"platform\", service=\"http-client\")\nNote: EIPBinding tells Platform Core which external service implementation to use when executing this Tool or Module.","eipdependency#EIPDependency":"Declares an agent-level dependency on an EIP service for Platform Review Gate 5.Attributes:\nprovider (str) - EIP provider identifier\nservice (str) - Service name within the provider\nversion (str) - Version constraint (default: \"*\")\nconfig_hints (dict) - Configuration hints for the service (optional)\nExample:\nfrom ainalyn.domain.entities import EIPDependency\n# OpenAI Whisper with streaming\nwhisper_dep = EIPDependency(\n    provider=\"openai\",\n    service=\"whisper\",\n    version=\">=1.0.0\",\n    config_hints={\n        \"streaming\": True,\n        \"model\": \"whisper-1\",\n        \"response_format\": \"verbose_json\"\n    }\n)\n# OpenAI GPT-4 with specific settings\ngpt_dep = EIPDependency(\n    provider=\"openai\",\n    service=\"gpt-4\",\n    version=\">=1.0.0\",\n    config_hints={\n        \"streaming\": True,\n        \"temperature\": 0.3\n    }\n)\nNote: EIPDependency is used for agent-level declarations. Platform Core validates these during Review Gate 5.","completioncriteria#CompletionCriteria":"Defines success and failure conditions for an agent (Platform Review Gate 1).Attributes:\nsuccess (str) - Description of what constitutes successful completion\nfailure (str) - Description of what constitutes failure\nExample:\nfrom ainalyn.domain.entities import CompletionCriteria\ncriteria = CompletionCriteria(\n    success=\"Complete transcript generated with timestamps and speaker labels\",\n    failure=\"Audio format unsupported, file corrupted, or speech unrecognizable\"\n)\nNote: CompletionCriteria helps Platform Core understand when an agent has completed its task successfully or failed.","submissionresult#SubmissionResult":"Result of submitting an agent definition to Platform Core.Attributes:\nreview_id (str) - Unique identifier for tracking the submission\nstatus (SubmissionStatus) - Current review status\nagent_id (str | None) - Assigned agent ID after approval\ntracking_url (str | None) - URL to track submission progress\nmarketplace_url (str | None) - URL to agent in marketplace (if live)\nfeedback (tuple) - Feedback items from Platform Core\nProperties:\nis_accepted (bool) - True if submission was accepted for review\nis_live (bool) - True if agent is published to marketplace\nis_rejected (bool) - True if submission was rejected\nExample:\nfrom ainalyn import submit_agent, track_submission\n# Submit agent\nresult = submit_agent(agent, api_key=\"dev_sk_xxx\")\nprint(f\"Review ID: {result.review_id}\")\nprint(f\"Status: {result.status.value}\")\nprint(f\"Track at: {result.tracking_url}\")\n# Later, check status\nresult = track_submission(result.review_id, api_key=\"dev_sk_xxx\")\nif result.is_live:\n    print(f\"Agent is live: {result.marketplace_url}\")","submissionstatus#SubmissionStatus":"Enum for submission review status.Values:\nSubmissionStatus.PENDING_REVIEW - Awaiting Platform Core review\nSubmissionStatus.ACCEPTED - Approved and ready for deployment\nSubmissionStatus.REJECTED - Rejected with feedback\nSubmissionStatus.DEPLOYED - Live in marketplace\nExample:\nfrom ainalyn.domain.entities import SubmissionStatus\nif result.status == SubmissionStatus.ACCEPTED:\n    print(\"Agent approved!\")\nelif result.status == SubmissionStatus.REJECTED:\n    print(\"Agent rejected. Review feedback.\")","immutability#Immutability":"All entities are frozen dataclasses - they cannot be modified after creation.\n# Create new entity\nagent = AgentDefinition(name=\"my-agent\", ...)\n# Cannot modify\nagent.name = \"new-name\"  # Error!\n# Create new version instead\nagent_v2 = AgentDefinition(name=\"new-name\", ...)","creating-entities#Creating Entities":"Direct creation (advanced):\nfrom ainalyn.domain.entities import AgentDefinition, Workflow, Node\nagent = AgentDefinition(...)\nUsing builders (recommended):\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"My agent\")\n    .add_workflow(...)\n    .build()\n)\nBuilders are easier and include validation."}},"/v1/concepts/building-your-agent":{"title":"Building Your Agent","data":{"":"An Agent Definition is your blueprint for solving a specific problem. This guide shows you how to think about and structure your Agent for success.","the-core-structure#The Core Structure":"Every Agent has three essential parts:\nagent = (\n    AgentBuilder(\"YourAgent\")\n    .description(\"What it does\")     # 1. Identity\n    .version(\"1.0.0\")\n    .add_workflow(your_workflow)     # 2. Logic\n    .build()                         # 3. Validation\n)\nLet's break down each part:","1-identity-what-your-agent-is#1. Identity: What Your Agent Is":"AgentBuilder(\"EmailExtractor\")\n    .description(\"Extract email addresses from documents\")\n    .version(\"1.0.0\")\nThink about:\nWhat problem does this solve?\nHow would you explain it in one sentence?\nWhat version of the solution is this?\nGood names:\nClear: \"InvoiceProcessor\", \"EmailExtractor\"\nSpecific: \"PDFTableExtractor\" not \"DataProcessor\"\nMemorable: Users will search for these\nGood descriptions:\nOne clear sentence\nFocus on the outcome\nAvoid technical jargon","2-logic-how-your-agent-works#2. Logic: How Your Agent Works":".add_workflow(extraction_workflow)\nWorkflows define the steps your Agent takes:\nworkflow = (\n    WorkflowBuilder(\"extract_emails\")\n    .description(\"Find and validate email addresses\")\n    .add_node(parse_node)\n    .add_node(extract_node)\n    .add_node(validate_node)\n    .entry_node(\"parse\")\n    .build()\n)\nThink about:\nWhat steps are needed?\nWhat's the logical flow?\nHow do steps connect?","3-validation-making-sure-its-right#3. Validation: Making Sure It's Right":".build()  # ← This validates your definition\nThe SDK checks:\n✅ All required fields present\n✅ Names are valid\n✅ Workflows are connected properly\n✅ No circular dependencies","workflows-your-agents-brain#Workflows: Your Agent's Brain":"Workflows are where your Agent's logic lives.","simple-linear-workflow#Simple Linear Workflow":"workflow = (\n    WorkflowBuilder(\"process_data\")\n    .description(\"Process user input step by step\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"Load and validate input\")\n        .outputs(\"validated_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Process the data\")\n        .depends_on(\"step1\")\n        .outputs(\"result\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)\nFlow:\nstep1 (load and validate)\n  ↓\nstep2 (process)\n  ↓\nresult","parallel-processing-workflow#Parallel Processing Workflow":"workflow = (\n    WorkflowBuilder(\"analyze_document\")\n    .description(\"Extract multiple types of data in parallel\")\n    .add_node(\n        NodeBuilder(\"load\")\n        .description(\"Load document\")\n        .outputs(\"document\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"extract_text\")\n        .description(\"Extract text content\")\n        .depends_on(\"load\")\n        .outputs(\"text\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"extract_images\")\n        .description(\"Extract images\")\n        .depends_on(\"load\")\n        .outputs(\"images\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"combine\")\n        .description(\"Combine results\")\n        .depends_on(\"extract_text\", \"extract_images\")\n        .outputs(\"final_result\")\n        .build()\n    )\n    .entry_node(\"load\")\n    .build()\n)\nFlow:\n         load\n          ↓\n    ┌─────┴─────┐\n    ↓           ↓\nextract_text  extract_images\n    └─────┬─────┘\n          ↓\n       combine","conditional-workflow#Conditional Workflow":"workflow = (\n    WorkflowBuilder(\"smart_processor\")\n    .description(\"Process based on input type\")\n    .add_node(\n        NodeBuilder(\"detect_type\")\n        .description(\"Determine input type\")\n        .outputs(\"input_type\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process_pdf\")\n        .description(\"Handle PDF inputs\")\n        .depends_on(\"detect_type\")\n        .outputs(\"result\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process_image\")\n        .description(\"Handle image inputs\")\n        .depends_on(\"detect_type\")\n        .outputs(\"result\")\n        .build()\n    )\n    .entry_node(\"detect_type\")\n    .build()\n)\nThe platform routes to the appropriate node based on your logic.","nodes-individual-steps#Nodes: Individual Steps":"Each node represents one focused task:\nnode = (\n    NodeBuilder(\"extract_emails\")\n    .description(\"Find all email addresses in text\")\n    .depends_on(\"parse_text\")       # What comes before\n    .outputs(\"email_list\")           # What this produces\n    .build()\n)","node-design-principles#Node Design Principles":"1. Single Responsibility\n# Good: Each node does one thing\nparse_node = NodeBuilder(\"parse\").description(\"Parse document\").build()\nextract_node = NodeBuilder(\"extract\").description(\"Extract emails\").build()\n# Bad: Node does too much\nprocess_node = NodeBuilder(\"process\").description(\"Parse and extract\").build()\n2. Clear Dependencies\n# Good: Explicit dependencies\nNodeBuilder(\"step2\").depends_on(\"step1\").build()\n# Bad: Unclear flow\nNodeBuilder(\"process\").build()  # What runs before this?\n3. Meaningful Outputs\n# Good: Clear output names\n.outputs(\"validated_emails\", \"confidence_scores\")\n# Bad: Generic names\n.outputs(\"result\", \"data\")","prompts-guiding-llms#Prompts: Guiding LLMs":"If your Agent uses LLMs, define prompts:\nprompt = (\n    PromptBuilder(\"analyze_sentiment\")\n    .description(\"Analyze text sentiment\")\n    .template(\"\"\"\n        Analyze the sentiment of the following text:\n        {text}\n        Provide a sentiment score from -1 (negative) to 1 (positive).\n    \"\"\")\n    .variables(\"text\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"SentimentAnalyzer\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\nPrompt tips:\nBe specific about what you want\nProvide clear output format instructions\nUse variables for dynamic content\nTest with edge cases","tools-external-capabilities#Tools: External Capabilities":"Declare external services your Agent needs:\nweather_tool = (\n    ToolBuilder(\"weather_api\")\n    .description(\"Fetch current weather data\")\n    .add_parameter(\"location\")\n    .add_parameter(\"units\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"WeatherAgent\")\n    .add_tool(weather_tool)\n    .add_workflow(workflow)\n    .build()\n)\nThe platform handles the actual API integration.","modules-reusable-capabilities#Modules: Reusable Capabilities":"Share functionality across workflows:\n# Define reusable module\ndata_validator = (\n    ModuleBuilder(\"DataValidator\")\n    .description(\"Common validation utilities\")\n    .add_capability(\"validate_email\")\n    .add_capability(\"validate_phone\")\n    .add_capability(\"validate_url\")\n    .build()\n)\n# Use in multiple agents\nagent1 = AgentBuilder(\"EmailProcessor\").add_module(data_validator).build()\nagent2 = AgentBuilder(\"ContactManager\").add_module(data_validator).build()","complete-example-invoice-processor#Complete Example: Invoice Processor":"Let's build a real Agent from scratch:\nfrom ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    PromptBuilder,\n    ToolBuilder,\n)\n# Define tools\nocr_tool = (\n    ToolBuilder(\"ocr_service\")\n    .description(\"Extract text from images\")\n    .add_parameter(\"image_data\")\n    .build()\n)\n# Define prompts\nextraction_prompt = (\n    PromptBuilder(\"extract_invoice_data\")\n    .description(\"Extract structured data from invoice text\")\n    .template(\"\"\"\n        Extract the following fields from this invoice:\n        {invoice_text}\n        Fields to extract:\n        - Invoice number\n        - Date\n        - Vendor name\n        - Total amount\n        - Line items\n        Return as JSON.\n    \"\"\")\n    .variables(\"invoice_text\")\n    .build()\n)\n# Define workflow\nprocessing_workflow = (\n    WorkflowBuilder(\"process_invoice\")\n    .description(\"Extract and structure invoice data\")\n    .add_node(\n        NodeBuilder(\"load_image\")\n        .description(\"Load invoice image\")\n        .outputs(\"image_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"extract_text\")\n        .description(\"OCR the invoice\")\n        .depends_on(\"load_image\")\n        .uses_tool(\"ocr_service\")\n        .outputs(\"invoice_text\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"parse_data\")\n        .description(\"Extract structured fields\")\n        .depends_on(\"extract_text\")\n        .uses_prompt(\"extract_invoice_data\")\n        .outputs(\"structured_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"validate\")\n        .description(\"Validate extracted data\")\n        .depends_on(\"parse_data\")\n        .outputs(\"validated_data\")\n        .build()\n    )\n    .entry_node(\"load_image\")\n    .build()\n)\n# Build the Agent\ninvoice_processor = (\n    AgentBuilder(\"InvoiceProcessor\")\n    .description(\"Extract structured data from invoice images\")\n    .version(\"1.0.0\")\n    .add_tool(ocr_tool)\n    .add_prompt(extraction_prompt)\n    .add_workflow(processing_workflow)\n    .build()\n)\n# Validate\nfrom ainalyn.api import validate\nvalidate(invoice_processor)\n# Export\nfrom ainalyn.api import export_yaml\nyaml_output = export_yaml(invoice_processor)","design-guidelines#Design Guidelines":"","start-simple#Start Simple":"Your first version doesn't need to be perfect:\n# Version 1.0.0: Basic extraction\nagent = (\n    AgentBuilder(\"EmailExtractor\")\n    .version(\"1.0.0\")\n    .add_workflow(basic_workflow)\n    .build()\n)\n# Version 1.1.0: Add validation\nagent = (\n    AgentBuilder(\"EmailExtractor\")\n    .version(\"1.1.0\")\n    .add_workflow(enhanced_workflow)\n    .build()\n)\nShip early, iterate based on feedback.","think-about-edge-cases#Think About Edge Cases":"workflow = (\n    WorkflowBuilder(\"process\")\n    .add_node(\n        NodeBuilder(\"validate_input\")\n        .description(\"Check input is valid\")  # ← Handle bad inputs\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process validated input\")\n        .depends_on(\"validate_input\")\n        .build()\n    )\n    .build()\n)\nGood Agents handle edge cases gracefully.","design-for-users#Design for Users":"# Good: Clear output\n.outputs(\"extracted_emails\", \"confidence_scores\", \"invalid_addresses\")\n# Bad: Unclear output\n.outputs(\"result\")\nUsers should understand what they get.","keep-workflows-focused#Keep Workflows Focused":"# Good: One workflow, one purpose\nworkflow = WorkflowBuilder(\"extract_emails\").build()\n# Consider splitting if it does too much\nworkflow = WorkflowBuilder(\"extract_and_validate_and_categorize\").build()\nFocused workflows are easier to debug and maintain.","validation-and-testing#Validation and Testing":"","always-validate#Always Validate":"from ainalyn.api import validate\ntry:\n    validate(agent)\n    print(\"✓ Agent definition is valid\")\nexcept ValidationError as e:\n    print(f\"✗ Validation failed: {e}\")\nValidation catches:\nMissing required fields\nInvalid names\nCircular dependencies\nBroken references","review-generated-yaml#Review Generated YAML":"yaml = export_yaml(agent)\nprint(yaml)\nThe YAML is what the platform sees. Make sure it matches your intent.","iterate-based-on-feedback#Iterate Based on Feedback":"Once deployed:\nMonitor usage patterns\nRead user feedback\nFix edge cases\nRelease improved versions","versioning-your-agent#Versioning Your Agent":"Use semantic versioning:\n# Initial release\n.version(\"1.0.0\")\n# Bug fix (backwards compatible)\n.version(\"1.0.1\")\n# New feature (backwards compatible)\n.version(\"1.1.0\")\n# Breaking change\n.version(\"2.0.0\")\nThe platform helps users migrate between versions.","common-patterns#Common Patterns":"","input-validation-pattern#Input Validation Pattern":"workflow = (\n    WorkflowBuilder(\"safe_processing\")\n    .add_node(\n        NodeBuilder(\"validate\")\n        .description(\"Validate input meets requirements\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process validated input\")\n        .depends_on(\"validate\")\n        .build()\n    )\n    .entry_node(\"validate\")\n    .build()\n)","error-handling-pattern#Error Handling Pattern":"workflow = (\n    WorkflowBuilder(\"robust_processing\")\n    .add_node(\n        NodeBuilder(\"try_process\")\n        .description(\"Attempt processing\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"handle_error\")\n        .description(\"Provide helpful error message\")\n        .depends_on(\"try_process\")\n        .build()\n    )\n    .build()\n)","multi-stage-processing-pattern#Multi-Stage Processing Pattern":"workflow = (\n    WorkflowBuilder(\"multi_stage\")\n    .add_node(NodeBuilder(\"stage1\").description(\"Initial processing\").build())\n    .add_node(NodeBuilder(\"stage2\").depends_on(\"stage1\").build())\n    .add_node(NodeBuilder(\"stage3\").depends_on(\"stage2\").build())\n    .entry_node(\"stage1\")\n    .build()\n)","best-practices-summary#Best Practices Summary":"Agent Design Checklist:\n✅ Clear, specific name\n✅ One-sentence description\n✅ Semantic version\n✅ Focused workflows\n✅ Single-responsibility nodes\n✅ Clear dependencies\n✅ Meaningful output names\n✅ Edge case handling\n✅ Validated definition\n✅ Reviewed YAML output","next-steps#Next Steps":"Now that you understand Agent structure:\nBuild Your First Agent - Hands-on tutorial\nWorkflow Guide - Advanced workflow patterns\nAPI Reference - Complete builder documentation\nRemember: Your Agent definition is a blueprint, not executable code.Focus on describing the solution clearly.The platform handles executing it reliably.That's how great Agents are built."}},"/v1/concepts/what-you-control":{"title":"What You Control","data":{"":"The SDK defines what developers control versus what Platform Core manages.","sdk-responsibilities#SDK Responsibilities":"When using the SDK, you control:","1-agent-definition-structure#1. Agent Definition Structure":"Define task logic, workflows, and resource dependencies:\nagent = (\n    AgentBuilder(\"invoice-processor\")\n    .version(\"1.0.0\")\n    .description(\"Extract line items from invoices\")\n    .add_workflow(workflow)\n    .add_prompt(prompt)\n    .build()\n)\nDeveloper Controls:\nWorkflow structure (nodes and edges)\nResource definitions (prompts, tools, modules)\nInput/output schemas\nNode dependencies and execution order\nVersion numbers\nDeveloper Does NOT Control:\nWhen execution occurs (user-initiated)\nResource allocation (platform-managed)\nRetry logic (platform-managed)\nBilling calculation (usage-based)","2-inputoutput-contracts#2. Input/Output Contracts":"Define what your agent accepts and returns:\n# Input schema (optional, for documentation)\ntool = (\n    ToolBuilder(\"data-validator\")\n    .description(\"Validates input data\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"data\": {\"type\": \"string\"},\n            \"format\": {\"type\": \"string\", \"enum\": [\"json\", \"csv\"]}\n        },\n        \"required\": [\"data\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"is_valid\": {\"type\": \"boolean\"},\n            \"errors\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n        }\n    })\n    .build()\n)\nDeveloper Controls:\nExpected input structure\nOutput data format\nValidation rules\nError message content\nDeveloper Does NOT Control:\nAuthentication (platform handles)\nRate limiting (platform enforces)\nRequest routing (platform manages)","3-workflow-logic#3. Workflow Logic":"Define processing steps and dependencies:\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Process invoice data\")\n    .add_node(\n        NodeBuilder(\"extract\")\n        .description(\"Extract text from PDF\")\n        .uses_tool(\"ocr-service\")\n        .outputs(\"raw_text\")\n        .next_nodes(\"parse\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"parse\")\n        .description(\"Parse invoice data\")\n        .uses_prompt(\"invoice-parser\")\n        .outputs(\"structured_data\")\n        .build()\n    )\n    .entry_node(\"extract\")\n    .build()\n)\nDeveloper Controls:\nNode execution order\nData flow between nodes\nConditional branching logic\nError handling strategy\nDeveloper Does NOT Control:\nNode execution infrastructure\nParallel execution scheduling\nResource cleanup\nState persistence","4-versioning#4. Versioning":"Manage agent versions using semantic versioning:\n# Version 1.0.0 - Initial release\nagent_v1 = (\n    AgentBuilder(\"processor\")\n    .version(\"1.0.0\")\n    .description(\"Basic processing\")\n    .add_workflow(basic_workflow)\n    .build()\n)\n# Version 1.1.0 - Add new feature (backward compatible)\nagent_v1_1 = (\n    AgentBuilder(\"processor\")\n    .version(\"1.1.0\")\n    .description(\"Enhanced processing\")\n    .add_workflow(enhanced_workflow)\n    .build()\n)\n# Version 2.0.0 - Breaking change\nagent_v2 = (\n    AgentBuilder(\"processor\")\n    .version(\"2.0.0\")\n    .description(\"Redesigned processing\")\n    .add_workflow(new_workflow)\n    .build()\n)\nDeveloper Controls:\nWhen to release new versions\nVersion number assignment\nFeature additions\nDeprecation timeline\nPlatform Controls:\nVersion migration for users\nBackward compatibility enforcement\nDefault version selection\nVersion availability","platform-responsibilities#Platform Responsibilities":"Platform Core handles execution and infrastructure:\nPlatform Responsibility\tDescription\tUser Authentication\tOAuth, API keys, session management\tExecution Orchestration\tScheduling, queuing, resource allocation\tRetry Logic\tAutomatic retries on transient failures\tBilling Calculation\tUsage tracking, cost calculation\tState Management\tExecution state, persistence\tMonitoring\tLogs, metrics, alerts\tSecurity\tSandboxing, isolation, data encryption\tScaling\tAuto-scaling based on demand","responsibility-matrix#Responsibility Matrix":"Aspect\tSDK/Developer\tPlatform Core\tDefine workflow structure\tYes\tNo\tValidate definition locally\tYes\tNo\tExecute workflows\tNo\tYes\tHandle authentication\tNo\tYes\tCalculate costs\tNo\tYes\tRetry failed operations\tNo\tYes\tManage infrastructure\tNo\tYes\tStore execution results\tNo\tYes\tVersion agent definitions\tYes\tNo\tEnforce version compatibility\tNo\tYes","code-comparison#Code Comparison":"","what-you-write-sdk#What You Write (SDK)":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Define resources\nprompt = (\n    PromptBuilder(\"extract-data\")\n    .description(\"Extract structured data\")\n    .template(\"Extract data from: {{input}}\")\n    .variables(\"input\")\n    .build()\n)\n# Define workflow\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .description(\"Main processing workflow\")\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process input\")\n        .uses_prompt(\"extract-data\")\n        .outputs(\"result\")\n        .build()\n    )\n    .entry_node(\"process\")\n    .build()\n)\n# Define agent\nagent = (\n    AgentBuilder(\"data-processor\")\n    .version(\"1.0.0\")\n    .description(\"Process and extract data\")\n    .add_prompt(prompt)\n    .add_workflow(workflow)\n    .build()\n)\n# Compile and export\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nTotal: ~40 lines focused on task logic.","what-you-dont-write-platform#What You Don't Write (Platform)":"The platform handles (not your responsibility):\nUser authentication flows\nPayment processing\nExecution scheduling\nResource allocation\nRetry mechanisms\nState persistence\nMonitoring and logging\nInfrastructure scaling\nSecurity sandboxing\nBilling calculation\nEstimated: 1000+ lines you don't need to write or maintain.","boundary-clarification#Boundary Clarification":"","why-these-boundaries-exist#Why These Boundaries Exist":"Platform boundaries ensure:\nConsistent execution behavior across all agents\nFair resource allocation\nAccurate billing\nSecurity isolation\nOperational reliability","example-retry-logic#Example: Retry Logic":"If developers controlled retries:\n# Developer A\nretries = 3\n# Developer B\nretries = 1000\n# Developer C\nwhile True:  # Infinite retries\n    retry()\nProblem: Platform overload, unfair resource usage, billing chaos.Solution: Platform enforces consistent retry policy.","example-billing#Example: Billing":"If developers controlled billing:\n# Developer A\ncost = 0.01  # Underpriced\n# Developer B\ncost = calculate_llm_tokens()  # Forgot tool costs\n# Developer C\ncost = 100.00  # Overpriced\nProblem: Inconsistent pricing, user confusion, revenue issues.Solution: Platform calculates actual resource usage.","practical-implications#Practical Implications":"","agent-definition-lifecycle#Agent Definition Lifecycle":"1. Development (SDK)\n# You build the definition\nagent = AgentBuilder(\"test\").version(\"1.0.0\")...build()\n# You validate locally\nresult = validate(agent)\n# You export to YAML\nyaml = export_yaml(agent)\n2. Submission (Platform)\nUpload YAML to platform\nPlatform reviews definition\nPlatform applies governance policies\nPlatform approves or rejects\n3. Execution (Platform)\nUser requests execution\nPlatform authenticates user\nPlatform allocates resources\nPlatform executes workflow\nPlatform tracks usage\nPlatform calculates cost\nPlatform stores results","state-management#State Management":"Agents are stateless by design:\n# Each execution is independent\nexecution_1 = platform.execute(agent, input_1)\nexecution_2 = platform.execute(agent, input_2)\n# No shared state between executions\nDeveloper Perspective:\nProcess inputs\nReturn outputs\nNo state management code\nPlatform Perspective:\nManages execution state\nPersists results\nProvides execution history","resource-requirements#Resource Requirements":"Declare resource needs, platform provisions:\n# You declare requirements\nagent = (\n    AgentBuilder(\"processor\")\n    .add_tool(\n        ToolBuilder(\"external-api\")\n        .description(\"Requires external API access\")\n        .build()\n    )\n    .build()\n)\n# Platform provisions:\n# - API credentials\n# - Network access\n# - Request limits\n# - Monitoring","common-questions#Common Questions":"","q-can-i-test-execution-locally#Q: Can I test execution locally?":"A: No. The SDK validates structure only. Execution requires platform infrastructure.\n# SDK can do this\nresult = validate(agent)  # Structure validation\n# SDK cannot do this\n# execute(agent, input)  # No local execution\nFor testing, use platform's test/sandbox environment.","q-can-i-customize-retry-behavior#Q: Can I customize retry behavior?":"A: No. Platform enforces consistent retry policies for all agents.Reason: Ensures fair resource usage and reliable billing.","q-can-i-store-data-between-executions#Q: Can I store data between executions?":"A: No. Agents are stateless. Each execution is independent.Alternative: Use platform-provided state management services (if available).","q-can-i-control-execution-timing#Q: Can I control execution timing?":"A: No. Users initiate execution. Platform schedules and orchestrates.Developer Role: Define what happens, not when it happens.","best-practices#Best Practices":"","1-focus-on-definition-quality#1. Focus on Definition Quality":"# Good: Clear, well-documented definition\nagent = (\n    AgentBuilder(\"processor\")\n    .version(\"1.0.0\")\n    .description(\"Processes invoices and extracts line items\")\n    .add_workflow(\n        WorkflowBuilder(\"process\")\n        .description(\"Main processing workflow\")\n        .add_node(...)\n        .build()\n    )\n    .build()\n)","2-design-for-statelessness#2. Design for Statelessness":"# Good: Each execution is self-contained\nnode = (\n    NodeBuilder(\"process\")\n    .description(\"Process input and return result\")\n    .uses_prompt(\"process-prompt\")\n    .outputs(\"result\")\n    .build()\n)\n# Avoid: Assuming state persists\n# (Platform handles state if needed)","3-validate-thoroughly#3. Validate Thoroughly":"# Always validate before submission\nresult = validate(agent)\nif not result.is_valid:\n    for error in result.errors:\n        print(f\"{error.code}: {error.message}\")","4-version-appropriately#4. Version Appropriately":"# Follow semantic versioning\n# MAJOR.MINOR.PATCH\n# 1.0.0 → 1.0.1 (bug fix)\n# 1.0.0 → 1.1.0 (new feature, backward compatible)\n# 1.0.0 → 2.0.0 (breaking change)","summary#Summary":"You Control\tPlatform Controls\tAgent definition structure\tExecution infrastructure\tWorkflow logic\tResource allocation\tInput/output contracts\tAuthentication\tVersion numbers\tRetry logic\tResource declarations\tBilling calculation\tLocal validation\tExecution orchestration\t\nYour Focus: Define task logic clearly and correctly.Platform Focus: Execute reliably and fairly.","next-steps#Next Steps":"Building Your Agent - Design patterns\nHow the SDK Works - Compilation process\nAPI Reference - SDK functions"}},"/v1/getting-started/installation":{"title":"Installation","data":{"requirements#Requirements":"Python 3.11, 3.12, or 3.13\npip","install-from-pypi#Install from PyPI":"pip install ainalyn-sdk","install-from-source#Install from Source":"For development:\ngit clone https://github.com/CoreNovus/ainalyn-sdk.git\ncd ainalyn-sdk\npip install -e \".[dev]\"","verify-installation#Verify Installation":"Check the SDK is installed:\nainalyn --version\nTest Python import:\npython -c \"import ainalyn; print('OK')\"","next-steps#Next Steps":"Quickstart - 5-minute tutorial\nYour First Agent - Detailed walkthrough","need-help#Need Help?":"Report issues\nAsk questions"}},"/v1/getting-started/quickstart":{"title":"Quickstart","data":{"":"Build your first agent in 5 minutes.","install#Install":"pip install ainalyn-sdk","create-an-agent#Create an Agent":"Create my_agent.py:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate, export_yaml\n# Define a prompt\ngreeting_prompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a personalized greeting\")\n    .template(\"Generate a personalized greeting for {{user_name}}\")\n    .variables(\"user_name\")\n    .build()\n)\n# Define the agent\nagent = (\n    AgentBuilder(\"greeting-agent\")\n    .description(\"Generates personalized greetings\")\n    .version(\"1.0.0\")\n    .add_prompt(greeting_prompt)\n    .add_workflow(\n        WorkflowBuilder(\"greet-user\")\n        .description(\"Main greeting workflow\")\n        .add_node(\n            NodeBuilder(\"generate-greeting\")\n            .description(\"Generate a personalized greeting\")\n            .uses_prompt(\"greeting-prompt\")\n            .outputs(\"greeting\")\n            .build()\n        )\n        .entry_node(\"generate-greeting\")\n        .build()\n    )\n    .build()\n)\n# Validate\nvalidate(agent)\nprint(\"Valid!\")\n# Export to YAML\nyaml_output = export_yaml(agent)\nprint(yaml_output)","run#Run":"python my_agent.py\nOutput:\nValid!\n# Ainalyn Agent Definition\n# This file is a description submitted to Platform Core for review.\n# It does NOT execute by itself. Execution is handled by Platform Core.\n#\n# Local compilation does NOT equal platform execution.\nname: greeting-agent\nversion: 1.0.0\ndescription: Generates personalized greetings\nworkflows:\n- name: greet-user\n  description: Main greeting workflow\n  entry_node: generate-greeting\n  nodes:\n  - name: generate-greeting\n    description: Generate a personalized greeting\n    type: prompt\n    reference: greeting-prompt\n    outputs:\n    - greeting\nprompts:\n- name: greeting-prompt\n  description: Generates a personalized greeting\n  template: Generate a personalized greeting for {{user_name}}\n  variables:\n  - user_name","whats-happening#What's Happening":"PromptBuilder creates a prompt template\nAgentBuilder creates an agent\nWorkflowBuilder adds a workflow with entry_node\nNodeBuilder adds a task node that uses the prompt\nvalidate() checks the definition\nexport_yaml() converts to YAML","next-steps#Next Steps":"Build a more complex agent\nUnderstand platform boundaries\nExplore the API","using-the-cli#Using the CLI":"You can also use the command line:\n# Validate\nainalyn validate my_agent.py\n# Compile to YAML\nainalyn compile my_agent.py -o output.yaml","common-patterns#Common Patterns":"Multiple nodes with flow:\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Sequential processing workflow\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First step\")\n        .uses_prompt(\"step1-prompt\")\n        .next_nodes(\"step2\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second step\")\n        .uses_prompt(\"step2-prompt\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)\nMultiple workflows:\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow1)\n    .add_workflow(workflow2)\n    .build()\n)","need-help#Need Help?":"Full tutorial\nAPI reference\nReport issues"}},"/v1/getting-started/your-first-agent":{"title":"Your First Agent","data":{"":"Build a complete agent step by step.","what-well-build#What We'll Build":"A research assistant that:\nSearches for information\nAnalyzes findings\nGenerates a report","step-1-create-the-prompts-and-modules#Step 1: Create the Prompts and Modules":"from ainalyn import ModuleBuilder, PromptBuilder\n# Module for search\nsearch_module = (\n    ModuleBuilder(\"search-module\")\n    .description(\"Searches for relevant information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\"query\": {\"type\": \"string\"}},\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\"results\": {\"type\": \"array\"}},\n    })\n    .build()\n)\n# Prompt for analysis\nanalyze_prompt = (\n    PromptBuilder(\"analyze-prompt\")\n    .description(\"Analyzes collected information\")\n    .template(\"Analyze the following information: {{search_results}}\")\n    .variables(\"search_results\")\n    .build()\n)\n# Prompt for report generation\nreport_prompt = (\n    PromptBuilder(\"report-prompt\")\n    .description(\"Generates a structured research report\")\n    .template(\"Create a report based on: {{analysis}}\")\n    .variables(\"analysis\")\n    .build()\n)","step-2-create-the-nodes#Step 2: Create the Nodes":"from ainalyn import NodeBuilder\n# Node 1: Search\nsearch_node = (\n    NodeBuilder(\"search-information\")\n    .description(\"Search and collect relevant information\")\n    .uses_module(\"search-module\")\n    .inputs(\"query\")\n    .outputs(\"search_results\")\n    .next_nodes(\"analyze-findings\")\n    .build()\n)\n# Node 2: Analyze (follows search)\nanalyze_node = (\n    NodeBuilder(\"analyze-findings\")\n    .description(\"Analyze the collected information\")\n    .uses_prompt(\"analyze-prompt\")\n    .inputs(\"search_results\")\n    .outputs(\"analysis\")\n    .next_nodes(\"generate-report\")\n    .build()\n)\n# Node 3: Report (follows analyze)\nreport_node = (\n    NodeBuilder(\"generate-report\")\n    .description(\"Create a structured research report\")\n    .uses_prompt(\"report-prompt\")\n    .inputs(\"analysis\")\n    .outputs(\"report\")\n    .build()\n)\nFlow: search → analyze → report","step-3-create-the-workflow#Step 3: Create the Workflow":"from ainalyn import WorkflowBuilder\nresearch_workflow = (\n    WorkflowBuilder(\"conduct-research\")\n    .description(\"Research and reporting workflow\")\n    .add_node(search_node)\n    .add_node(analyze_node)\n    .add_node(report_node)\n    .entry_node(\"search-information\")\n    .build()\n)","step-4-create-the-agent#Step 4: Create the Agent":"from ainalyn import AgentBuilder\nresearch_agent = (\n    AgentBuilder(\"research-assistant\")\n    .description(\"Searches, analyzes, and reports on topics\")\n    .version(\"1.0.0\")\n    .add_module(search_module)\n    .add_prompt(analyze_prompt)\n    .add_prompt(report_prompt)\n    .add_workflow(research_workflow)\n    .build()\n)","step-5-validate-and-export#Step 5: Validate and Export":"from ainalyn.api import validate, export_yaml\n# Validate\nresult = validate(research_agent)\nif result.is_valid:\n    print(\"Valid!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error.message}\")\n# Export\nyaml_output = export_yaml(research_agent)\n# Save to file\nwith open(\"research_assistant.yaml\", \"w\", encoding=\"utf-8\") as f:\n    f.write(yaml_output)","complete-code#Complete Code":"research_agent.py:\nfrom ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    ModuleBuilder,\n    PromptBuilder,\n)\nfrom ainalyn.api import validate, export_yaml\n# Create resources\nsearch_module = (\n    ModuleBuilder(\"search-module\")\n    .description(\"Searches for relevant information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\"query\": {\"type\": \"string\"}},\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\"results\": {\"type\": \"array\"}},\n    })\n    .build()\n)\nanalyze_prompt = (\n    PromptBuilder(\"analyze-prompt\")\n    .description(\"Analyzes collected information\")\n    .template(\"Analyze the following information: {{search_results}}\")\n    .variables(\"search_results\")\n    .build()\n)\nreport_prompt = (\n    PromptBuilder(\"report-prompt\")\n    .description(\"Generates a structured research report\")\n    .template(\"Create a report based on: {{analysis}}\")\n    .variables(\"analysis\")\n    .build()\n)\n# Create nodes\nsearch_node = (\n    NodeBuilder(\"search-information\")\n    .description(\"Search and collect relevant information\")\n    .uses_module(\"search-module\")\n    .inputs(\"query\")\n    .outputs(\"search_results\")\n    .next_nodes(\"analyze-findings\")\n    .build()\n)\nanalyze_node = (\n    NodeBuilder(\"analyze-findings\")\n    .description(\"Analyze the collected information\")\n    .uses_prompt(\"analyze-prompt\")\n    .inputs(\"search_results\")\n    .outputs(\"analysis\")\n    .next_nodes(\"generate-report\")\n    .build()\n)\nreport_node = (\n    NodeBuilder(\"generate-report\")\n    .description(\"Create a structured research report\")\n    .uses_prompt(\"report-prompt\")\n    .inputs(\"analysis\")\n    .outputs(\"report\")\n    .build()\n)\n# Create workflow\nresearch_workflow = (\n    WorkflowBuilder(\"conduct-research\")\n    .description(\"Research and reporting workflow\")\n    .add_node(search_node)\n    .add_node(analyze_node)\n    .add_node(report_node)\n    .entry_node(\"search-information\")\n    .build()\n)\n# Create agent\nresearch_agent = (\n    AgentBuilder(\"research-assistant\")\n    .description(\"Searches, analyzes, and reports on topics\")\n    .version(\"1.0.0\")\n    .add_module(search_module)\n    .add_prompt(analyze_prompt)\n    .add_prompt(report_prompt)\n    .add_workflow(research_workflow)\n    .build()\n)\n# Validate and export\nresult = validate(research_agent)\nif result.is_valid:\n    yaml_output = export_yaml(research_agent)\n    with open(\"research_assistant.yaml\", \"w\", encoding=\"utf-8\") as f:\n        f.write(yaml_output)\n    print(\"Agent created and saved!\")\nelse:\n    for error in result.errors:\n        print(f\"Error: {error.message}\")","run-it#Run It":"python research_agent.py","the-generated-yaml#The Generated YAML":"name: research-assistant\nversion: 1.0.0\ndescription: Searches, analyzes, and reports on topics\nworkflows:\n- name: conduct-research\n  description: Research and reporting workflow\n  entry_node: search-information\n  nodes:\n  - name: search-information\n    description: Search and collect relevant information\n    type: module\n    reference: search-module\n    next_nodes:\n    - analyze-findings\n    inputs:\n    - query\n    outputs:\n    - search_results\n  - name: analyze-findings\n    description: Analyze the collected information\n    type: prompt\n    reference: analyze-prompt\n    next_nodes:\n    - generate-report\n    inputs:\n    - search_results\n    outputs:\n    - analysis\n  - name: generate-report\n    description: Create a structured research report\n    type: prompt\n    reference: report-prompt\n    inputs:\n    - analysis\n    outputs:\n    - report\nmodules:\n- name: search-module\n  description: Searches for relevant information\n  input_schema:\n    type: object\n    properties:\n      query:\n        type: string\n    required:\n    - query\n  output_schema:\n    type: object\n    properties:\n      results:\n        type: array\nprompts:\n- name: analyze-prompt\n  description: Analyzes collected information\n  template: 'Analyze the following information: {{search_results}}'\n  variables:\n  - search_results\n- name: report-prompt\n  description: Generates a structured research report\n  template: 'Create a report based on: {{analysis}}'\n  variables:\n  - analysis","key-concepts#Key Concepts":"Workflow Flow\nUse .next_nodes() to define the next steps in the flow\nSet .entry_node() on the workflow to specify where it starts\nNodes reference resources (modules, prompts, tools) via .uses_*()\nBuilder Pattern\nAlways call .build() at the end\nMethods return self for chaining\nImmutable entities created on .build()\nBottom-Up Construction\nBuild resources first (modules, prompts, tools)\nBuild nodes that reference those resources\nAdd nodes to workflow with entry_node\nAdd resources and workflows to agent","common-mistakes#Common Mistakes":"Forgetting .build()\n# Wrong\nnode = NodeBuilder(\"task\").description(\"Do something\")\n# Correct\nnode = NodeBuilder(\"task\").description(\"Do something\").uses_prompt(\"task-prompt\").build()\nCircular flow\n# Wrong (A points to B, B points to A)\nnode_a = NodeBuilder(\"a\").description(\"A\").uses_prompt(\"prompt-a\").next_nodes(\"b\").build()\nnode_b = NodeBuilder(\"b\").description(\"B\").uses_prompt(\"prompt-b\").next_nodes(\"a\").build()\nNot setting entry_node\n# Wrong\nworkflow = WorkflowBuilder(\"main\").add_node(node).build()\n# Correct\nworkflow = WorkflowBuilder(\"main\").add_node(node).entry_node(\"node-name\").build()\nInvalid names\n# Wrong\nAgentBuilder(\"My Agent\")   # No spaces\nAgentBuilder(\"MyAgent\")    # Must start with lowercase\n# Correct (use lowercase with hyphens)\nAgentBuilder(\"my-agent\")\nAgentBuilder(\"research-assistant\")","next-steps#Next Steps":"Platform Boundaries - What the SDK can/cannot do\nAPI Reference - All builder methods\nWorkflows - Advanced workflow patterns\nModules - Create custom modules","need-help#Need Help?":"Quickstart - Simpler example\nAPI docs - Function reference\nIssues - Report bugs"}},"/v1/guides/errors":{"title":"Error Handling","data":{"":"Complete reference for SDK errors and how to resolve them.","error-categories#Error Categories":"SDK errors occur at two stages:\nBuild-Time Errors - When calling .build() on builders\nValidation Errors - When calling validate() on agent definitions","build-time-errors#Build-Time Errors":"These errors are raised immediately when using builders incorrectly.","missingfielderror#MissingFieldError":"Required field not provided before calling .build().Example:\n# Error: Missing version and description\nagent = AgentBuilder(\"my-agent\").build()\nError Message:\nMissingFieldError: Required field 'version' is missing or empty in AgentBuilder\nFix:\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")        # Required\n    .description(\"Agent\")     # Required\n    .add_workflow(workflow)   # Required\n    .build()\n)\nRequired Fields by Builder:\nBuilder\tRequired Fields\tAgentBuilder\tname, version, description, workflows (at least one)\tWorkflowBuilder\tname, description, nodes (at least one), entry_node\tNodeBuilder\tname, description, resource reference (uses_*)\tPromptBuilder\tname, description, template\tToolBuilder\tname, description\tModuleBuilder\tname, description","invalidformaterror#InvalidFormatError":"Value doesn't match required format.Common Cases:","invalid-name-format#Invalid Name Format":"# Error: Name contains uppercase and space\nagent = AgentBuilder(\"My Agent\").build()\nError Message:\nInvalidFormatError: Invalid value for 'name': 'My Agent'.\nAgent name must start with lowercase letter and contain only lowercase letters, numbers, and hyphens\nName Format Rules:\nPattern: [a-z][a-z0-9-]*\nMust start with lowercase letter\nCan contain: lowercase letters, numbers, hyphens\nCannot contain: uppercase, spaces, underscores, special characters\nValid Names:\n\"my-agent\"           # Valid\n\"data-processor\"     # Valid\n\"agent-v2\"           # Valid\n\"task123\"            # Valid\nInvalid Names:\n\"MyAgent\"            # Uppercase (invalid)\n\"my_agent\"           # Underscore (invalid)\n\"123agent\"           # Starts with number (invalid)\n\"my agent\"           # Space (invalid)\n\"my@agent\"           # Special character (invalid)\nFix:\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\")...build()","invalid-version-format#Invalid Version Format":"# Error: Not semantic versioning\nagent = AgentBuilder(\"my-agent\").version(\"v1\").build()\nError Message:\nInvalidFormatError: Invalid value for 'version': 'v1'.\nVersion must follow semantic versioning format (e.g., '1.0.0')\nVersion Format Rules:\nPattern: MAJOR.MINOR.PATCH\nExample: 1.0.0, 2.3.1, 0.1.0\nFix:\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\")...build()","duplicateerror#DuplicateError":"Name used multiple times in same scope.Example:\n# Error: Two nodes named \"task\"\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task\").description(\"Task 1\").uses_prompt(\"p1\").build())\n    .add_node(NodeBuilder(\"task\").description(\"Task 2\").uses_prompt(\"p2\").build())\n    .build()\n)\nError Message:\nDuplicateError: Duplicate node name 'task' in workflow 'main'.\nEach node must have a unique name within its scope.\nScoping Rules:\nScope\tMust Be Unique Within\tNodes\tSame workflow\tWorkflows\tSame agent\tPrompts\tSame agent\tTools\tSame agent\tModules\tSame agent\t\nFix:\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(NodeBuilder(\"task-1\").description(\"Task 1\").uses_prompt(\"p1\").build())\n    .add_node(NodeBuilder(\"task-2\").description(\"Task 2\").uses_prompt(\"p2\").build())\n    .build()\n)","referenceerror#ReferenceError":"Node references undefined resource.Example:\n# Error: Prompt \"my-prompt\" not defined in agent\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test\")\n    .add_workflow(\n        WorkflowBuilder(\"main\")\n        .add_node(\n            NodeBuilder(\"task\")\n            .description(\"Task\")\n            .uses_prompt(\"my-prompt\")  # Not defined!\n            .build()\n        )\n        .entry_node(\"task\")\n        .build()\n    )\n    .build()\n)\nError Message:\nReferenceError: 'task' references undefined prompt 'my-prompt'.\nThe prompt must be defined in the agent.\nFix:\n# Define the prompt first\nprompt = (\n    PromptBuilder(\"my-prompt\")\n    .description(\"My prompt\")\n    .template(\"Do task\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test\")\n    .add_prompt(prompt)  # Add the prompt\n    .add_workflow(...)\n    .build()\n)\nResource Types:\nuses_module(name) → must match a module in agent.modules\nuses_prompt(name) → must match a prompt in agent.prompts\nuses_tool(name) → must match a tool in agent.tools","emptycollectionerror#EmptyCollectionError":"Required collection is empty.Example:\n# Error: No workflows added\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test\")\n    .build()\n)\nError Message:\nEmptyCollectionError: 'Agent 'test'' has no workflows.\nAt least one workflow is required.\nFix:\nagent = (\n    AgentBuilder(\"test\")\n    .version(\"1.0.0\")\n    .description(\"Test\")\n    .add_workflow(workflow)  # Add at least one\n    .build()\n)\nMinimum Requirements:\nCollection\tMinimum Count\tAgent workflows\t1\tWorkflow nodes\t1","validation-errors#Validation Errors":"These errors occur during validate() call.","cyclicdependencyerror#CyclicDependencyError":"Workflow contains cycle (not a DAG).Example:\n# Error: node-a → node-b → node-c → node-a (cycle!)\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(\n        NodeBuilder(\"node-a\")\n        .description(\"Node A\")\n        .uses_prompt(\"p\")\n        .next_nodes(\"node-b\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"node-b\")\n        .description(\"Node B\")\n        .uses_prompt(\"p\")\n        .next_nodes(\"node-c\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"node-c\")\n        .description(\"Node C\")\n        .uses_prompt(\"p\")\n        .next_nodes(\"node-a\")  # Creates cycle!\n        .build()\n    )\n    .entry_node(\"node-a\")\n    .build()\n)\nresult = validate(agent)\n# CyclicDependencyError in result.errors\nError Message:\nCyclicDependencyError: Workflow contains a cycle: node-a → node-b → node-c → node-a\nFix: Remove the cycle by restructuring workflow as a DAG:\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(\n        NodeBuilder(\"node-a\")\n        .description(\"Node A\")\n        .uses_prompt(\"p\")\n        .next_nodes(\"node-b\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"node-b\")\n        .description(\"Node B\")\n        .uses_prompt(\"p\")\n        .next_nodes(\"node-c\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"node-c\")\n        .description(\"Node C\")\n        .uses_prompt(\"p\")\n        .build()  # No cycle\n    )\n    .entry_node(\"node-a\")\n    .build()\n)","unreachablenodeerror#UnreachableNodeError":"Node cannot be reached from entry node.Example:\n# Error: orphan-node has no incoming edges\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .add_node(\n        NodeBuilder(\"entry\")\n        .description(\"Entry\")\n        .uses_prompt(\"p\")\n        .next_nodes(\"task-a\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"task-a\")\n        .description(\"Task A\")\n        .uses_prompt(\"p\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"orphan-node\")  # Not connected!\n        .description(\"Orphan\")\n        .uses_prompt(\"p\")\n        .build()\n    )\n    .entry_node(\"entry\")\n    .build()\n)\nresult = validate(agent)\n# UnreachableNodeError in result.errors\nError Message:\nUnreachableNodeError: Node 'orphan-node' is unreachable from entry node 'entry'.\nAll nodes must be reachable via edges.\nFix Option 1: Connect the node to workflow:\n.add_node(\n    NodeBuilder(\"entry\")\n    .next_nodes(\"task-a\", \"orphan-node\")  # Add connection\n    .build()\n)\nFix Option 2: Remove unused node:\n# Simply don't add orphan-node","error-handling-patterns#Error Handling Patterns":"","basic-try-catch#Basic Try-Catch":"from ainalyn.domain.errors import DomainError\ntry:\n    agent = (\n        AgentBuilder(\"my-agent\")\n        .version(\"1.0.0\")\n        .description(\"Agent\")\n        .add_workflow(workflow)\n        .build()\n    )\nexcept DomainError as e:\n    print(f\"Build error: {e.message}\")","specific-error-handling#Specific Error Handling":"from ainalyn.domain.errors import (\n    MissingFieldError,\n    InvalidFormatError,\n    ReferenceError,\n    DuplicateError,\n    EmptyCollectionError,\n)\ntry:\n    agent = AgentBuilder(\"test\").build()\nexcept MissingFieldError as e:\n    print(f\"Missing required field: {e.field_name}\")\n    print(f\"In: {e.entity_type}\")\nexcept InvalidFormatError as e:\n    print(f\"Invalid {e.field_name}: {e.value}\")\n    print(f\"Constraint: {e.constraint}\")\nexcept ReferenceError as e:\n    print(f\"'{e.source}' references undefined {e.resource_type}: {e.reference}\")\nexcept DuplicateError as e:\n    print(f\"Duplicate {e.entity_type} name: {e.name}\")\n    if e.scope:\n        print(f\"In: {e.scope}\")\nexcept EmptyCollectionError as e:\n    print(f\"{e.parent_name} has no {e.collection_name}\")","validation-result-handling#Validation Result Handling":"from ainalyn.api import validate\nresult = validate(agent)\n# Check if valid\nif not result.is_valid:\n    print(\"Validation failed:\")\n    for error in result.errors:\n        print(f\"  [{error.severity}] {error.code}\")\n        print(f\"    {error.message}\")\n        if error.location:\n            print(f\"    Location: {error.location}\")\n# Check for warnings\nif result.has_warnings:\n    print(\"\\nWarnings:\")\n    for error in result.errors:\n        if error.severity == Severity.WARNING:\n            print(f\"  {error.code}: {error.message}\")","compilation-error-handling#Compilation Error Handling":"from ainalyn.api import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(f\"Success! Compiled to {result.output_path}\")\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"\\n{error.code}\")\n        print(f\"  {error.message}\")","error-code-reference#Error Code Reference":"","build-time-error-codes#Build-Time Error Codes":"Code\tException\tSeverity\tDescription\tMISSING_FIELD\tMissingFieldError\tERROR\tRequired field not provided\tINVALID_FORMAT\tInvalidFormatError\tERROR\tValue doesn't match format\tDUPLICATE_NAME\tDuplicateError\tERROR\tName collision in scope\tREFERENCE_ERROR\tReferenceError\tERROR\tUndefined resource reference\tEMPTY_COLLECTION\tEmptyCollectionError\tERROR\tRequired collection empty","validation-error-codes#Validation Error Codes":"Code\tException\tSeverity\tDescription\tCYCLIC_DEPENDENCY\tCyclicDependencyError\tERROR\tWorkflow contains cycle\tUNREACHABLE_NODE\tUnreachableNodeError\tERROR\tNode unreachable from entry\tORPHANED_RESOURCE\tN/A\tWARNING\tResource defined but unused","best-practices#Best Practices":"","1-build-incrementally#1. Build Incrementally":"Catch errors early by validating after each step:\n# Build nodes\nnode1 = NodeBuilder(\"task1\").description(\"Task 1\").uses_prompt(\"p1\").build()\nnode2 = NodeBuilder(\"task2\").description(\"Task 2\").uses_prompt(\"p2\").build()\n# Build workflow\nworkflow = (\n    WorkflowBuilder(\"main\")\n    .description(\"Main\")\n    .add_node(node1)\n    .add_node(node2)\n    .entry_node(\"task1\")\n    .build()\n)\n# Build agent\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Agent\")\n    .add_prompt(prompt1)\n    .add_prompt(prompt2)\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nresult = validate(agent)\nassert result.is_valid","2-use-compile_agent#2. Use compile_agent()":"Combines validation and export:\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    # Safe to submit\n    print(\"Ready for submission\")\nelse:\n    # Fix errors first\n    for error in result.validation_result.errors:\n        print(error.message)","3-handle-errors-specifically#3. Handle Errors Specifically":"Catch specific error types for targeted fixes:\ntry:\n    agent = builder.build()\nexcept MissingFieldError as e:\n    # Add missing field\n    pass\nexcept InvalidFormatError as e:\n    # Fix format\n    pass\nexcept ReferenceError as e:\n    # Define resource\n    pass","4-review-error-messages#4. Review Error Messages":"Error messages include helpful information:\nField name that caused error\nInvalid value\nConstraint that was violated\nLocation in definition\nexcept InvalidFormatError as e:\n    print(f\"Field: {e.field_name}\")\n    print(f\"Value: {e.value}\")\n    print(f\"Rule: {e.constraint}\")","quick-reference-table#Quick Reference Table":"Error\tCommon Cause\tQuick Fix\tMissingFieldError\tForgot .version() or .description()\tAdd required method call\tInvalidFormatError (name)\tUsed uppercase or spaces in name\tUse lowercase with hyphens\tInvalidFormatError (version)\tVersion not \"X.Y.Z\" format\tUse semantic versioning\tDuplicateError\tTwo nodes with same name\tRename one node\tReferenceError\tNode uses undefined prompt\tAdd prompt to agent\tEmptyCollectionError\tNo workflows in agent\tAdd at least one workflow\tCyclicDependencyError\tCircular workflow\tRemove cycle\tUnreachableNodeError\tDisconnected node\tConnect or remove node","getting-help#Getting Help":"If you encounter an error not covered here:\nRead the full error message carefully\nCheck API Reference for detailed error information\nReview Validation Guide for validation rules\nConsult How the SDK Works for compilation process\nReport issues on GitHub"}},"/v1/guides/modules":{"title":"Modules","data":{"":"How to define reusable capability units for your agents.","what-is-a-module#What is a Module?":"A module is a self-contained functional component that can perform specific tasks. It defines:\nWhat it does (description)\nWhat input it expects (input schema)\nWhat output it produces (output schema)\nImportant: The SDK only defines the module's contract. The actual implementation is provided by the platform.","creating-a-module#Creating a Module":"from ainalyn import ModuleBuilder\nmodule = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Fetches data from HTTP endpoints\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\"]}\n        },\n        \"required\": [\"url\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\"type\": \"integer\"},\n            \"body\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","eip-binding#EIP Binding":"Modules can be linked to EIP (Execution Implementation Provider) services using .eip_binding():\nfrom ainalyn import ModuleBuilder\nfrom ainalyn.domain.entities import EIPBinding\n# Module with platform-provided implementation\naudio_segmenter = (\n    ModuleBuilder(\"audio-segmenter\")\n    .description(\"Splits long audio files into segments\")\n    .eip_binding(EIPBinding(provider=\"platform\", service=\"audio-segmenter\"))\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"audio_url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"max_segment_size_mb\": {\"type\": \"number\", \"default\": 24}\n        },\n        \"required\": [\"audio_url\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"segments\": {\"type\": \"array\"},\n            \"segment_count\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)\nWhen to use EIP binding:\nWhen the module requires a specific platform service implementation\nWhen Platform Core needs to know which service to invoke\nFor modules that interface with external systems\nCommon EIP providers:\nplatform - Platform-provided services\nopenai - OpenAI services\nanthropic - Anthropic services","using-modules-in-workflows#Using Modules in Workflows":"Step 1: Define the module\nhttp_module = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Fetches data from HTTP endpoints\")\n    .input_schema({...})\n    .output_schema({...})\n    .build()\n)\nStep 2: Add module to agent\nagent = (\n    AgentBuilder(\"data-agent\")\n    .version(\"1.0.0\")\n    .add_module(http_module)  # Register module\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"fetch-data\")\n    .description(\"Fetch user data\")\n    .uses_module(\"http-client\")  # References the module\n    .inputs(\"url\")\n    .outputs(\"response\")\n    .build()\n)","json-schema#JSON Schema":"Modules use JSON Schema to define input/output contracts.Basic types:\n# String\n{\"type\": \"string\"}\n# Number\n{\"type\": \"number\"}\n# Integer\n{\"type\": \"integer\"}\n# Boolean\n{\"type\": \"boolean\"}\n# Array\n{\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n# Object\n{\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    }\n}\nRequired fields:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"url\": {\"type\": \"string\"},\n        \"timeout\": {\"type\": \"integer\"}\n    },\n    \"required\": [\"url\"]  # url is required, timeout is optional\n}\nDefault values:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"method\": {\n            \"type\": \"string\",\n            \"default\": \"GET\"  # Default if not provided\n        }\n    }\n}\nEnums:\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"enum\": [\"active\", \"inactive\", \"pending\"]\n        }\n    }\n}","common-module-patterns#Common Module Patterns":"","http-client#HTTP Client":"http_module = (\n    ModuleBuilder(\"http-client\")\n    .description(\"Makes HTTP requests\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"string\"}\n        },\n        \"required\": [\"url\", \"method\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status\": {\"type\": \"integer\"},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","data-processor#Data Processor":"processor = (\n    ModuleBuilder(\"data-processor\")\n    .description(\"Processes and transforms data\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"data\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n            \"operation\": {\"type\": \"string\", \"enum\": [\"filter\", \"map\", \"reduce\"]}\n        },\n        \"required\": [\"data\", \"operation\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"result\": {\"type\": \"array\"},\n            \"count\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","file-operations#File Operations":"file_module = (\n    ModuleBuilder(\"file-handler\")\n    .description(\"Reads and writes files\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"path\": {\"type\": \"string\"},\n            \"operation\": {\"type\": \"string\", \"enum\": [\"read\", \"write\"]},\n            \"content\": {\"type\": \"string\"}\n        },\n        \"required\": [\"path\", \"operation\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"success\": {\"type\": \"boolean\"},\n            \"content\": {\"type\": \"string\"},\n            \"size\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","module-naming#Module Naming":"Valid names:\n\"http-client\"        # Lowercase with hyphens\n\"data-processor\"     # Descriptive\n\"file-handler-v2\"    # With version suffix\nInvalid names:\n\"HttpClient\"         # Must be lowercase\n\"data_processor\"     # No underscores\n\"my module\"          # No spaces","best-practices#Best Practices":"1. Keep schemas simple\n# Simple, focused schema\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"url\": {\"type\": \"string\"}\n    },\n    \"required\": [\"url\"]\n}\n# Avoid overly complex nested schemas\n2. Use descriptive property names\n# Clear property names\n{\n    \"properties\": {\n        \"user_id\": {\"type\": \"string\"},\n        \"email_address\": {\"type\": \"string\"}\n    }\n}\n# Avoid unclear names like \"id\" or \"data\"\n3. Document expected formats\n# Specify format\n{\n    \"properties\": {\n        \"email\": {\"type\": \"string\", \"format\": \"email\"},\n        \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n        \"date\": {\"type\": \"string\", \"format\": \"date\"}\n    }\n}\n4. Define required fields\n# Explicit required fields\n{\n    \"properties\": {\n        \"id\": {\"type\": \"string\"},\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"integer\"}\n    },\n    \"required\": [\"id\", \"name\"]  # age is optional\n}","module-vs-prompt-vs-tool#Module vs Prompt vs Tool":"Use Module when:\nYou need custom business logic\nPlatform provides the implementation\nInput/output are structured data\nUse Prompt when:\nYou need LLM-based reasoning\nInput/output are text-based\nSee Prompts Guide\nUse Tool when:\nYou need external services (APIs, databases)\nPlatform provides the integration\nSee Tools Guide","complete-example#Complete Example":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, ModuleBuilder, NodeType\n# Define module\nemail_module = (\n    ModuleBuilder(\"email-sender\")\n    .description(\"Sends emails via SMTP\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"to\": {\"type\": \"string\", \"format\": \"email\"},\n            \"subject\": {\"type\": \"string\"},\n            \"body\": {\"type\": \"string\"}\n        },\n        \"required\": [\"to\", \"subject\", \"body\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"sent\": {\"type\": \"boolean\"},\n            \"message_id\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"send-notification\")\n    .entry_node(\"send\")\n    .add_node(\n        NodeBuilder(\"send\")\n        .description(\"Send email notification\")\n        .uses_module(\"email-sender\")  # Reference module\n        .inputs(\"to\", \"subject\", \"body\")\n        .outputs(\"sent\", \"message_id\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"notification-agent\")\n    .version(\"1.0.0\")\n    .description(\"Sends email notifications\")\n    .add_module(email_module)  # Register module\n    .add_workflow(workflow)\n    .build()\n)","see-also#See Also":"ModuleBuilder API - Full API reference\nPrompts Guide - Using prompt templates\nTools Guide - External tool integration\nWorkflows - Using modules in workflows"}},"/v1/guides/tools":{"title":"Tools","data":{"":"How to define external tool interfaces for your agents.","what-is-a-tool#What is a Tool?":"A tool represents an external capability that your agent can invoke. It defines:\nWhat it does (description)\nWhat input it expects (input schema)\nWhat output it produces (output schema)\nImportant: The SDK only defines the tool's interface contract. The platform provides the actual implementation.","creating-a-tool#Creating a Tool":"from ainalyn import ToolBuilder\ntool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"max_results\": {\"type\": \"integer\", \"default\": 10}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"title\": {\"type\": \"string\"},\n                        \"url\": {\"type\": \"string\"},\n                        \"snippet\": {\"type\": \"string\"}\n                    }\n                }\n            }\n        }\n    })\n    .build()\n)","eip-binding#EIP Binding":"Tools can be linked to external EIP (Execution Implementation Provider) services using .eip_binding():\nfrom ainalyn import ToolBuilder\nfrom ainalyn.domain.entities import EIPBinding\n# Tool with OpenAI Whisper binding\nspeech_to_text = (\n    ToolBuilder(\"speech-to-text\")\n    .description(\"Converts audio to text using OpenAI Whisper\")\n    .eip_binding(EIPBinding(provider=\"openai\", service=\"whisper\"))\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"audio_url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"language\": {\"type\": \"string\", \"default\": \"auto\"}\n        },\n        \"required\": [\"audio_url\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"text\": {\"type\": \"string\"},\n            \"segments\": {\"type\": \"array\"}\n        }\n    })\n    .build()\n)\nWhen to use EIP binding:\nWhen the tool uses an external service (OpenAI, Anthropic, etc.)\nWhen Platform Core needs to know which service to invoke\nFor tools that require specific provider implementations\nCommon EIP providers:\nopenai - OpenAI services (whisper, gpt-4, dall-e, etc.)\nanthropic - Anthropic services (claude, etc.)\nplatform - Platform-provided services","using-tools-in-workflows#Using Tools in Workflows":"Step 1: Define the tool\nsearch_tool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web\")\n    .input_schema({...})\n    .output_schema({...})\n    .build()\n)\nStep 2: Add tool to agent\nagent = (\n    AgentBuilder(\"research-agent\")\n    .version(\"1.0.0\")\n    .add_tool(search_tool)  # Register tool\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"search\")\n    .description(\"Search for information\")\n    .uses_tool(\"web-search\")  # References the tool\n    .inputs(\"query\")\n    .outputs(\"results\")\n    .build()\n)","common-tool-patterns#Common Tool Patterns":"","web-search#Web Search":"search = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"language\": {\"type\": \"string\", \"default\": \"en\"},\n            \"safe_search\": {\"type\": \"boolean\", \"default\": True}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},\n            \"total_count\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)","database-query#Database Query":"db_query = (\n    ToolBuilder(\"database-query\")\n    .description(\"Executes SQL queries on database\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"parameters\": {\"type\": \"array\"},\n            \"timeout\": {\"type\": \"integer\", \"default\": 30}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"rows\": {\"type\": \"array\"},\n            \"row_count\": {\"type\": \"integer\"},\n            \"execution_time\": {\"type\": \"number\"}\n        }\n    })\n    .build()\n)","file-operations#File Operations":"file_writer = (\n    ToolBuilder(\"file-writer\")\n    .description(\"Writes content to files\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"path\": {\"type\": \"string\"},\n            \"content\": {\"type\": \"string\"},\n            \"encoding\": {\"type\": \"string\", \"default\": \"utf-8\"},\n            \"append\": {\"type\": \"boolean\", \"default\": False}\n        },\n        \"required\": [\"path\", \"content\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"success\": {\"type\": \"boolean\"},\n            \"bytes_written\": {\"type\": \"integer\"},\n            \"file_path\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)","email-sender#Email Sender":"email_sender = (\n    ToolBuilder(\"email-sender\")\n    .description(\"Sends emails via SMTP\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"to\": {\"type\": \"array\", \"items\": {\"type\": \"string\", \"format\": \"email\"}},\n            \"subject\": {\"type\": \"string\"},\n            \"body\": {\"type\": \"string\"},\n            \"attachments\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n        },\n        \"required\": [\"to\", \"subject\", \"body\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"sent\": {\"type\": \"boolean\"},\n            \"message_id\": {\"type\": \"string\"},\n            \"recipients\": {\"type\": \"array\"}\n        }\n    })\n    .build()\n)","api-client#API Client":"api_client = (\n    ToolBuilder(\"rest-api-client\")\n    .description(\"Makes REST API calls\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"endpoint\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"object\"}\n        },\n        \"required\": [\"endpoint\", \"method\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"status_code\": {\"type\": \"integer\"},\n            \"headers\": {\"type\": \"object\"},\n            \"body\": {\"type\": \"object\"}\n        }\n    })\n    .build()\n)","tool-naming#Tool Naming":"Valid names:\n\"web-search\"          # Lowercase with hyphens\n\"file-writer\"         # Descriptive\n\"api-client-v2\"       # With version\nInvalid names:\n\"WebSearch\"           # Must be lowercase\n\"file_writer\"         # No underscores\n\"my tool\"             # No spaces","best-practices#Best Practices":"1. Use descriptive schemas\n# Clear input contract\ninput_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"search_query\": {\"type\": \"string\"},\n        \"result_limit\": {\"type\": \"integer\", \"minimum\": 1, \"maximum\": 100}\n    },\n    \"required\": [\"search_query\"]\n}\n2. Provide defaults for optional parameters\n{\n    \"properties\": {\n        \"timeout\": {\"type\": \"integer\", \"default\": 30},\n        \"retry_count\": {\"type\": \"integer\", \"default\": 3},\n        \"encoding\": {\"type\": \"string\", \"default\": \"utf-8\"}\n    }\n}\n3. Use appropriate constraints\n{\n    \"properties\": {\n        \"page_size\": {\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 100,\n            \"default\": 20\n        },\n        \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\"\n        },\n        \"url\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        }\n    }\n}\n4. Document expected behavior\n# Clear description\nToolBuilder(\"cache-manager\")\n    .description(\"Manages in-memory cache with TTL support\")","tool-vs-module-vs-prompt#Tool vs Module vs Prompt":"Use Tool when:\nYou need external services (APIs, databases, web search)\nPlatform provides the integration\nTask involves I/O operations\nUse Module when:\nYou need custom business logic\nTask is computation or data processing\nSee Modules Guide\nUse Prompt when:\nYou need LLM-based reasoning\nTask involves text understanding/generation\nSee Prompts Guide","complete-example#Complete Example":"from ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    ToolBuilder,\n    NodeType\n)\n# Define tool\nsearch_tool = (\n    ToolBuilder(\"web-search\")\n    .description(\"Searches the web for information\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"query\": {\"type\": \"string\"},\n            \"max_results\": {\"type\": \"integer\", \"default\": 10}\n        },\n        \"required\": [\"query\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"results\": {\"type\": \"array\"},\n            \"total_found\": {\"type\": \"integer\"}\n        }\n    })\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"research\")\n    .entry_node(\"search\")\n    .add_node(\n        NodeBuilder(\"search\")\n        .description(\"Search for research topic\")\n        .uses_tool(\"web-search\")\n        .inputs(\"query\")\n        .outputs(\"results\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"research-agent\")\n    .version(\"1.0.0\")\n    .description(\"Web research assistant\")\n    .add_tool(search_tool)\n    .add_workflow(workflow)\n    .build()\n)","see-also#See Also":"ToolBuilder API - Full API reference\nModules Guide - Custom business logic\nPrompts Guide - LLM templates\nWorkflows - Using tools in workflows"}},"/v1/guides/validation":{"title":"Validation","data":{"":"How validation works and what gets checked.","what-gets-validated#What Gets Validated":"The SDK validates your agent definition before export to ensure it's ready for the platform.Schema Validation:\nRequired fields are present\nNaming conventions are correct\nVersion format is valid (semantic versioning)\nReferences are defined\nStructural Validation:\nWorkflows have at least one node\nEntry nodes exist\nNode references point to valid resources\nAll dependencies are defined","using-validate#Using validate()":"from ainalyn import AgentBuilder, validate\nagent = (\n    AgentBuilder(\"MyAgent\")\n    .version(\"1.0.0\")\n    .description(\"My first agent\")\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nresult = validate(agent)\nif result.is_valid:\n    print(\"Validation passed!\")\nelse:\n    print(\"Validation failed:\")\n    for error in result.errors:\n        print(f\"  {error.code}: {error.message}\")","validation-results#Validation Results":"The ValidationResult object contains:Properties:\nis_valid - Boolean indicating if validation passed\nerrors - List of validation errors\nwarnings - List of warnings (optional issues)\nError Details:\nEach error contains:\ncode - Error code (e.g., \"MISSING_AGENT_VERSION\")\npath - Location in the definition (e.g., \"agent.version\")\nmessage - Human-readable description\nseverity - ERROR or WARNING","naming-rules#Naming Rules":"Valid names:\n\"my-agent\"           # Lowercase with hyphens\n\"data-processor-v2\"  # Letters, numbers, hyphens\n\"fetch-data\"         # Starts with letter\nInvalid names:\n\"MyAgent\"      # Must be lowercase\n\"my_agent\"     # No underscores\n\"my agent\"     # No spaces\n\"2-agent\"      # Must start with letter","version-format#Version Format":"Valid versions:\n\"1.0.0\"        # Semantic versioning\n\"2.1.3\"        # Major.minor.patch\n\"0.1.0\"        # Pre-release\nInvalid versions:\n\"1.0\"          # Must have three parts\n\"v1.0.0\"       # No 'v' prefix\n\"1.0.0-beta\"   # No pre-release tags (yet)","common-validation-errors#Common Validation Errors":"","missing_agent_version#MISSING_AGENT_VERSION":"Cause: Forgot to set agent version.\n# Error\nagent = AgentBuilder(\"my-agent\").build()\n# Fix\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()","invalid_workflow_name#INVALID_WORKFLOW_NAME":"Cause: Workflow name doesn't follow naming rules.\n# Error\nworkflow = WorkflowBuilder(\"MyWorkflow\").build()\n# Fix\nworkflow = WorkflowBuilder(\"my-workflow\").build()","missing_workflows#MISSING_WORKFLOWS":"Cause: Agent has no workflows.\n# Error\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\n# Fix\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(workflow)\n    .build()\n)","undefined_resource_reference#UNDEFINED_RESOURCE_REFERENCE":"Cause: Node references a resource that doesn't exist.\n# Error - prompt not defined\nnode = (\n    NodeBuilder(\"task\")\n    .description(\"Task node\")\n    .uses_prompt(\"analyzer\")  # No prompt named \"analyzer\"\n    .build()\n)\n# Fix - define the prompt first\nprompt = PromptBuilder(\"analyzer\").template(\"Analyze: {data}\").build()\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .add_prompt(prompt)  # Add prompt to agent\n    .add_workflow(workflow)\n    .build()\n)","invalid_entry_node#INVALID_ENTRY_NODE":"Cause: Workflow entry_node doesn't exist in nodes.\n# Error\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .entry_node(\"start\")  # No node named \"start\"\n    .add_node(NodeBuilder(\"step1\").goal(\"Do something\").build())\n    .build()\n)\n# Fix\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .entry_node(\"step1\")  # Valid node name\n    .add_node(NodeBuilder(\"step1\").goal(\"Do something\").build())\n    .build()\n)","best-practices#Best Practices":"1. Validate early and often\n# Build progressively, validate at each step\nnode = NodeBuilder(\"task\").goal(\"Process data\").build()\nworkflow = WorkflowBuilder(\"main\").add_node(node).build()\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").add_workflow(workflow).build()\n# Validate before export\nresult = validate(agent)\nif not result.is_valid:\n    print(\"Fix these errors before exporting:\")\n    for error in result.errors:\n        print(f\"  - {error.message}\")\n2. Check validation results\nresult = validate(agent)\n# Don't ignore validation!\nif not result.is_valid:\n    raise ValueError(f\"Invalid agent: {result.errors[0].message}\")\n# Now safe to export\nyaml_output = export_yaml(agent)\n3. Use compile_agent() for safety\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Automatically validates before exporting\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.message}\")","when-validation-happens#When Validation Happens":"Builder validation:\nHappens during .build() call\nChecks required fields\nValidates value formats\nThrows exceptions immediately\nSchema validation:\nHappens when you call validate()\nChecks structural correctness\nReturns ValidationResult\nDoes not throw exceptions\nExample:\n# Builder validation - throws exception\ntry:\n    agent = AgentBuilder(\"Invalid Name!\").build()  # Throws exception\nexcept InvalidValueError as e:\n    print(f\"Builder error: {e.message}\")\n# Schema validation - returns result\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\nresult = validate(agent)  # Returns ValidationResult\nif not result.is_valid:\n    print(f\"Schema error: {result.errors[0].message}\")","see-also#See Also":"Error Handling - Builder errors and how to fix them\nAPI Reference - validate() function details\nBuilders - Builder validation rules"}},"/v1/guides/workflows":{"title":"Workflows","data":{"":"How to structure task flows with nodes and dependencies.","what-is-a-workflow#What is a Workflow?":"A workflow defines the execution flow of tasks in your agent. It's a directed graph where:\nNodes are processing steps\nnext_nodes define execution order\nentry_node is where execution starts","basic-workflow#Basic Workflow":"from ainalyn import WorkflowBuilder, NodeBuilder\nworkflow = (\n    WorkflowBuilder(\"process-data\")\n    .description(\"Fetch and process data\")\n    .add_node(\n        NodeBuilder(\"fetch\")\n        .description(\"Fetch raw data\")\n        .uses_module(\"http-client\")\n        .outputs(\"raw_data\")\n        .next_nodes(\"process\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"process\")\n        .description(\"Process the data\")\n        .uses_prompt(\"analyzer\")\n        .inputs(\"raw_data\")\n        .build()\n    )\n    .entry_node(\"fetch\")\n    .build()\n)\nExecution flow: fetch → process","node-dependencies#Node Dependencies":"Dependencies define execution order through next_nodes.Linear flow:\n# A → B → C\nnode_a = (\n    NodeBuilder(\"step-a\")\n    .description(\"First step\")\n    .uses_prompt(\"prompt-a\")\n    .next_nodes(\"step-b\")\n    .build()\n)\nnode_b = (\n    NodeBuilder(\"step-b\")\n    .description(\"Second step\")\n    .uses_prompt(\"prompt-b\")\n    .next_nodes(\"step-c\")\n    .build()\n)\nnode_c = (\n    NodeBuilder(\"step-c\")\n    .description(\"Final step\")\n    .uses_prompt(\"prompt-c\")\n    .build()\n)\nParallel execution:\n# A → [B, C] → D\nnode_a = (\n    NodeBuilder(\"start\")\n    .description(\"Start processing\")\n    .uses_prompt(\"start-prompt\")\n    .next_nodes(\"process-1\", \"process-2\")  # Both run in parallel\n    .build()\n)\nnode_b = (\n    NodeBuilder(\"process-1\")\n    .description(\"First parallel task\")\n    .uses_prompt(\"process-prompt-1\")\n    .next_nodes(\"merge\")\n    .build()\n)\nnode_c = (\n    NodeBuilder(\"process-2\")\n    .description(\"Second parallel task\")\n    .uses_prompt(\"process-prompt-2\")\n    .next_nodes(\"merge\")\n    .build()\n)\nnode_d = (\n    NodeBuilder(\"merge\")\n    .description(\"Merge results\")\n    .uses_prompt(\"merge-prompt\")\n    .build()\n)\nConditional branching:\n# A → [B or C] (decided by platform)\nnode_a = (\n    NodeBuilder(\"analyze\")\n    .description(\"Analyze input\")\n    .uses_module(\"analyzer\")\n    .next_nodes(\"path-a\", \"path-b\")  # Platform decides which path\n    .build()\n)","entry-node#Entry Node":"Every workflow must specify where execution starts.\nworkflow = (\n    WorkflowBuilder(\"my-workflow\")\n    .entry_node(\"start\")  # Execution begins here\n    .add_node(\n        NodeBuilder(\"start\")\n        .description(\"Starting point\")\n        .build()\n    )\n    .build()\n)\nRules:\nEntry node must exist in the workflow's nodes\nOnly one entry node per workflow\nEntry node name must match exactly","data-flow#Data Flow":"Nodes pass data using inputs and outputs.\n# Node 1: Produces data\nproducer = (\n    NodeBuilder(\"fetch-user\")\n    .description(\"Fetch user data\")\n    .outputs([\"user_id\", \"user_name\"])  # Outputs these values\n    .next_nodes([\"process\"])\n    .build()\n)\n# Node 2: Consumes data\nconsumer = (\n    NodeBuilder(\"process\")\n    .description(\"Process user data\")\n    .inputs([\"user_id\", \"user_name\"])  # Uses these inputs\n    .outputs([\"result\"])\n    .build()\n)\nNotes:\nInput/output names are descriptive\nPlatform handles actual data passing\nSDK just defines the structure","multiple-workflows#Multiple Workflows":"Agents can have multiple workflows for different tasks.\nfrom ainalyn import AgentBuilder\n# Workflow 1: Data processing\nprocessing_workflow = WorkflowBuilder(\"process-data\").build()\n# Workflow 2: Reporting\nreporting_workflow = WorkflowBuilder(\"generate-report\").build()\n# Agent with both workflows\nagent = (\n    AgentBuilder(\"data-agent\")\n    .version(\"1.0.0\")\n    .add_workflow(processing_workflow)\n    .add_workflow(reporting_workflow)\n    .build()\n)\nEach workflow is independent and can be invoked separately by the platform.","node-types#Node Types":"Uses Prompt - Uses a prompt template\nNodeBuilder(\"analyze\")\n    .description(\"Analyze data\")\n    .uses_prompt(\"analyzer-prompt\")  # References a Prompt\nUses Module - Executes custom logic\nNodeBuilder(\"fetch\")\n    .description(\"Fetch data\")\n    .uses_module(\"http-client\")  # References a Module\nUses Tool - Calls an external tool\nNodeBuilder(\"search\")\n    .description(\"Search web\")\n    .uses_tool(\"web-search\")  # References a Tool\nNote: The node type is automatically determined by which .uses_*() method you call.","common-patterns#Common Patterns":"","sequential-processing#Sequential Processing":"# Step 1 → Step 2 → Step 3\nworkflow = (\n    WorkflowBuilder(\"sequential\")\n    .description(\"Sequential workflow\")\n    .add_node(\n        NodeBuilder(\"step1\")\n        .description(\"First\")\n        .uses_prompt(\"prompt1\")\n        .next_nodes(\"step2\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step2\")\n        .description(\"Second\")\n        .uses_prompt(\"prompt2\")\n        .next_nodes(\"step3\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"step3\")\n        .description(\"Final\")\n        .uses_prompt(\"prompt3\")\n        .build()\n    )\n    .entry_node(\"step1\")\n    .build()\n)","fan-out-fan-in#Fan-Out, Fan-In":"# One node → Multiple parallel nodes → Merge\nworkflow = (\n    WorkflowBuilder(\"parallel\")\n    .description(\"Parallel workflow\")\n    .add_node(\n        NodeBuilder(\"split\")\n        .description(\"Split work\")\n        .uses_prompt(\"split-prompt\")\n        .next_nodes(\"work1\", \"work2\", \"work3\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work1\")\n        .description(\"Work 1\")\n        .uses_prompt(\"work-prompt-1\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work2\")\n        .description(\"Work 2\")\n        .uses_prompt(\"work-prompt-2\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"work3\")\n        .description(\"Work 3\")\n        .uses_prompt(\"work-prompt-3\")\n        .next_nodes(\"merge\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"merge\")\n        .description(\"Combine results\")\n        .uses_prompt(\"merge-prompt\")\n        .build()\n    )\n    .entry_node(\"split\")\n    .build()\n)","pipeline-processing#Pipeline Processing":"# Input → Transform → Filter → Output\nworkflow = (\n    WorkflowBuilder(\"pipeline\")\n    .description(\"Pipeline workflow\")\n    .add_node(\n        NodeBuilder(\"input\")\n        .description(\"Read input\")\n        .uses_module(\"input-reader\")\n        .next_nodes(\"transform\")\n        .outputs(\"raw_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"transform\")\n        .description(\"Transform data\")\n        .uses_prompt(\"transform-prompt\")\n        .inputs(\"raw_data\")\n        .next_nodes(\"filter\")\n        .outputs(\"transformed_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"filter\")\n        .description(\"Filter data\")\n        .uses_prompt(\"filter-prompt\")\n        .inputs(\"transformed_data\")\n        .next_nodes(\"output\")\n        .outputs(\"filtered_data\")\n        .build()\n    )\n    .add_node(\n        NodeBuilder(\"output\")\n        .description(\"Write output\")\n        .uses_module(\"output-writer\")\n        .inputs(\"filtered_data\")\n        .build()\n    )\n    .entry_node(\"input\")\n    .build()\n)","validation-rules#Validation Rules":"Valid workflows:\nAt least one node\nEntry node exists in nodes\nAll next_nodes references exist\nNo circular dependencies (A → B → A)\nInvalid workflows:\n# No nodes\nworkflow = WorkflowBuilder(\"empty\").build()\n# Entry node doesn't exist\nworkflow = (\n    WorkflowBuilder(\"bad\")\n    .entry_node(\"missing\")  # No node named \"missing\"\n    .add_node(NodeBuilder(\"actual\").build())\n    .build()\n)\n# Undefined next_node reference\nnode = (\n    NodeBuilder(\"broken\")\n    .next_nodes([\"nonexistent\"])  # No node named \"nonexistent\"\n    .build()\n)","best-practices#Best Practices":"1. Use descriptive names\n# Clear names\nNodeBuilder(\"fetch-user-data\")\nNodeBuilder(\"validate-email\")\nNodeBuilder(\"send-notification\")\n# Unclear names\nNodeBuilder(\"step1\")\nNodeBuilder(\"process\")\nNodeBuilder(\"do-stuff\")\n2. Define clear data flow\n# Explicit inputs/outputs\nNodeBuilder(\"transform\")\n    .inputs([\"raw_data\"])\n    .outputs([\"clean_data\"])\n# No data flow specified\nNodeBuilder(\"transform\")\n    # Where does data come from?\n3. Keep workflows focused\n# Single responsibility\nprocess_workflow = WorkflowBuilder(\"process-orders\")\nreport_workflow = WorkflowBuilder(\"generate-reports\")\n# Too many responsibilities\neverything_workflow = WorkflowBuilder(\"do-everything\")","see-also#See Also":"Your First Agent - Complete workflow example\nNodeBuilder API - All node options\nValidation - Workflow validation rules"}},"/v1/advanced/system-context":{"title":"System Context","data":{"":"Understanding where the Ainalyn SDK fits in the overall system architecture.","application-architecture#Application Architecture":"","sdk-as-a-compiler#SDK as a Compiler":"The most important concept to understand: The SDK is a compiler, not a runtime.","key-boundaries#Key Boundaries":"","what-the-sdk-does#What the SDK Does":"Responsibility\tDescription\tDefine\tProvides builders to define Agent structure\tValidate\tChecks definition correctness before submission\tExport\tProduces platform-compatible YAML format\tCompile\tComplete workflow: validate → serialize → output","what-the-sdk-does-not-do#What the SDK Does NOT Do":"NOT Responsibility\tWhy\tExecute agents\tPlatform Core handles execution\tCall LLMs\tPlatform Core manages LLM interactions\tManage state\tPlatform Core handles runtime state\tHandle I/O\tPlatform Core manages external integrations","the-compilation-analogy#The Compilation Analogy":"Think of Ainalyn SDK like a programming language compiler:\n┌─────────────────────────────────────────────────────────────────────┐\n│                        Traditional Compiler                          │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│   Source Code (.py)  ──▶  Compiler  ──▶  Bytecode (.pyc)           │\n│                                                                     │\n│   The compiler doesn't run your program;                            │\n│   it produces something that can be run later.                      │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘\n┌─────────────────────────────────────────────────────────────────────┐\n│                          Ainalyn SDK                                 │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                     │\n│   Python Builders  ──▶  SDK  ──▶  Agent Definition (YAML)          │\n│                                                                     │\n│   The SDK doesn't run your agent;                                   │\n│   it produces a definition that Platform Core executes.             │\n│                                                                     │\n└─────────────────────────────────────────────────────────────────────┘","data-flow-overview#Data Flow Overview":"Developer                    SDK                         Platform\n────────                    ───                         ────────\n  │                          │                             │\n  │  1. Write Python code    │                             │\n  │  using builders          │                             │\n  │                          │                             │\n  ├─────────────────────────▶│                             │\n  │                          │                             │\n  │                          │  2. Validate structure      │\n  │                          │     Check references        │\n  │                          │     Detect cycles           │\n  │                          │                             │\n  │                          │  3. Serialize to YAML       │\n  │                          │                             │\n  │◀─────────────────────────┤                             │\n  │  4. Return YAML / errors │                             │\n  │                          │                             │\n  │                          │                             │\n  ├──────────────────────────┼────────────────────────────▶│\n  │  5. Submit YAML to platform                            │\n  │                          │                             │\n  │                          │                             │  6. Parse YAML\n  │                          │                             │  7. Execute agent\n  │                          │                             │  8. Call LLMs\n  │                          │                             │  9. Return results\n  │                          │                             │","why-this-separation#Why This Separation?":"","benefits-of-compiler-pattern#Benefits of Compiler Pattern":"Offline Validation\nCatch errors before deployment\nNo network calls needed for validation\nFast feedback loop for developers\nPlatform Independence\nSDK produces a standard format (YAML)\nPlatform can evolve independently\nMultiple platforms could consume the same format\nClear Responsibility\nSDK: definition correctness\nPlatform: execution correctness\nNo confusion about where bugs originate\nTestability\nTest definitions without running agents\nMock-free unit tests for SDK\nIntegration tests only at platform level","what-gets-compiled#What Gets Compiled":"The SDK compiles your Python builder calls into an Agent Definition:Input (Python):\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nagent = (\n    AgentBuilder(\"customer-support\")\n    .version(\"1.0.0\")\n    .description(\"Handles customer inquiries\")\n    .add_workflow(\n        WorkflowBuilder(\"handle-inquiry\")\n        .add_node(NodeBuilder(\"classify\").type(\"llm\").build())\n        .add_node(NodeBuilder(\"respond\").type(\"llm\").build())\n        .add_edge(\"classify\", \"respond\")\n        .build()\n    )\n    .build()\n)\nOutput (YAML):\nname: customer-support\nversion: 1.0.0\ndescription: Handles customer inquiries\nworkflows:\n  - name: handle-inquiry\n    nodes:\n      - id: classify\n        type: llm\n      - id: respond\n        type: llm\n    edges:\n      - from: classify\n        to: respond","related-pages#Related Pages":"Hexagonal Architecture - Internal SDK architecture\nCompilation Flow - Detailed compilation process"}},"/v1/concepts/agent-definition":{"title":"Agent Definition","data":{"":"An Agent Definition is the formal description of what an Agent does and how it accomplishes its task. It's the contract between you (the developer) and Platform Core about how your agent should behave.","what-is-an-agent-definition#What Is an Agent Definition?":"An Agent Definition is a declarative, structured description of:\nWhat task the agent accomplishes\nWhat inputs it expects\nWhat outputs it produces\nHow the task workflow is organized\nWhat resources (prompts, tools, modules) it needs\nThink of an Agent Definition as a recipe:\nIt describes ingredients (tools, prompts)\nIt defines steps (workflow nodes)\nIt specifies order (workflow edges)\nBut it doesn't cook anything—Platform Core does that","agent-vs-agent-definition#Agent vs Agent Definition":"This distinction is constitutional (from Platform Vision & System Boundary):\nAgent\tAgent Definition\tMarketplace contract entity\tInternal description language\tWhat users invoke\tWhat developers submit\tPlatform's billing unit\tDeveloper's build artifact\tPublic-facing product\tImplementation specification\tLives in Platform Core\tLives in YAML files\t\n# This creates an Agent DEFINITION\nagent_def = (\n    AgentBuilder(\"email-parser\")\n    .version(\"1.0.0\")\n    .description(\"Extract emails from text\")\n    .build()\n)\n# After submission and approval, it becomes an AGENT\n# Users don't see the definition—they just invoke \"email-parser\"\nAgent ≠ Agent DefinitionAn Agent is what users see in the marketplace and invoke.\nAn Agent Definition is your implementation that describes how the agent works.Users care about the Agent (the product).\nDevelopers work with Agent Definitions (the spec).","structure-of-an-agent-definition#Structure of an Agent Definition":"Every Agent Definition has a hierarchical structure:\nAgent Definition\n├── Metadata (name, version, description)\n├── Workflows (at least one)\n│   ├── Nodes (processing steps)\n│   ├── Edges (execution flow)\n│   └── Entry Node (where to start)\n├── Prompts (optional, LLM templates)\n├── Tools (optional, external services)\n└── Modules (optional, reusable components)","required-components#Required Components":"Metadata\nname: Unique identifier ([a-z][a-z0-9-]*)\nversion: Semantic version (e.g., \"1.0.0\")\ndescription: Human-readable summary\nAt least one Workflow\nDefines the task execution logic\nMust form a valid DAG (Directed Acyclic Graph)\nAll nodes must be reachable from entry node","optional-components#Optional Components":"Prompts: LLM prompt templates\nTools: External API/service declarations\nModules: Reusable workflow components","building-an-agent-definition#Building an Agent Definition":"","using-the-builder-api#Using the Builder API":"The SDK provides a fluent builder API:\nfrom ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    PromptBuilder,\n    ToolBuilder\n)\n# Define a prompt\nsummarize_prompt = (\n    PromptBuilder(\"summarize\")\n    .description(\"Summarize text concisely\")\n    .template(\"Summarize the following text:\\n{{input_text}}\")\n    .variables(\"input_text\")\n    .build()\n)\n# Define workflow nodes\nextract_node = (\n    NodeBuilder(\"extract\", \"prompt\")\n    .reference(\"summarize\")\n    .outputs(\"summary\")\n    .build()\n)\nformat_node = (\n    NodeBuilder(\"format\", \"module\")\n    .reference(\"text-formatter\")\n    .inputs(\"summary\")\n    .outputs(\"formatted_output\")\n    .build()\n)\n# Define workflow\nmain_workflow = (\n    WorkflowBuilder(\"main\")\n    .description(\"Summarization workflow\")\n    .add_node(extract_node)\n    .add_node(format_node)\n    .add_edge(\"extract\", \"format\")\n    .entry_node(\"extract\")\n    .build()\n)\n# Build complete Agent Definition\nagent_definition = (\n    AgentBuilder(\"text-summarizer\")\n    .version(\"1.0.0\")\n    .description(\"Summarize long text into concise summaries\")\n    .add_prompt(summarize_prompt)\n    .add_workflow(main_workflow)\n    .build()\n)","validation#Validation":"Before submitting, the SDK validates your definition:\nfrom ainalyn import validate\nresult = validate(agent_definition)\nif result.is_valid:\n    print(\"✓ Ready to submit\")\nelse:\n    for error in result.errors:\n        print(f\"✗ {error.code}: {error.message}\")\nThe SDK checks:\n✓ Required fields present\n✓ Names match pattern [a-z][a-z0-9-]*\n✓ Versions follow semantic versioning\n✓ All references resolve (no undefined prompts/tools/modules)\n✓ Workflows form valid DAGs (no cycles)\n✓ All nodes reachable from entry node\n✓ No duplicate names within scope","workflow-structure#Workflow Structure":"Workflows are the core of your Agent Definition. They describe how the task gets done.","directed-acyclic-graph-dag#Directed Acyclic Graph (DAG)":"Every workflow must be a valid DAG:\n# Valid DAG ✓\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .add_node(NodeBuilder(\"A\", \"prompt\").reference(\"prompt-a\").build())\n    .add_node(NodeBuilder(\"B\", \"tool\").reference(\"tool-b\").build())\n    .add_node(NodeBuilder(\"C\", \"module\").reference(\"module-c\").build())\n    .add_edge(\"A\", \"B\")  # A → B\n    .add_edge(\"B\", \"C\")  # B → C\n    .add_edge(\"A\", \"C\")  # A → C (branching is OK)\n    .entry_node(\"A\")\n    .build()\n)\n# Invalid: Cycle ✗\nworkflow = (\n    WorkflowBuilder(\"bad\")\n    .add_node(NodeBuilder(\"X\", \"prompt\").reference(\"p\").build())\n    .add_node(NodeBuilder(\"Y\", \"prompt\").reference(\"q\").build())\n    .add_edge(\"X\", \"Y\")  # X → Y\n    .add_edge(\"Y\", \"X\")  # Y → X ← Creates cycle!\n    .entry_node(\"X\")\n    .build()\n)\n# CyclicDependencyError: Workflow contains a cycle: X → Y → X","node-types#Node Types":"Nodes specify what processing happens at each step:\nNode Type\tReference\tPurpose\tprompt\tPrompt name\tLLM-based processing\ttool\tTool name\tExternal API/service call\tmodule\tModule name\tReusable component invocation\t\n# Prompt node - LLM processing\nllm_node = (\n    NodeBuilder(\"analyze\", \"prompt\")\n    .reference(\"analysis-prompt\")\n    .outputs(\"analysis_result\")\n    .build()\n)\n# Tool node - External service\napi_node = (\n    NodeBuilder(\"fetch\", \"tool\")\n    .reference(\"weather-api\")\n    .outputs(\"weather_data\")\n    .build()\n)\n# Module node - Reusable component\nmodule_node = (\n    NodeBuilder(\"transform\", \"module\")\n    .reference(\"data-transformer\")\n    .inputs(\"raw_data\")\n    .outputs(\"processed_data\")\n    .build()\n)","edges-and-flow-control#Edges and Flow Control":"Edges define execution order:\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .add_node(node1)\n    .add_node(node2)\n    .add_node(node3)\n    .add_edge(\"node1\", \"node2\")  # Sequential: 1 → 2\n    .add_edge(\"node2\", \"node3\")  # Sequential: 2 → 3\n    .entry_node(\"node1\")         # Start at node1\n    .build()\n)\nParallel ExecutionIf a node has edges to multiple nodes, Platform Core may execute them in parallel:\nworkflow = (\n    WorkflowBuilder(\"parallel-demo\")\n    .add_node(node_start)\n    .add_node(node_branch_a)\n    .add_node(node_branch_b)\n    .add_node(node_merge)\n    .add_edge(\"start\", \"branch_a\")   # start → branch_a\n    .add_edge(\"start\", \"branch_b\")   # start → branch_b (parallel)\n    .add_edge(\"branch_a\", \"merge\")   # branch_a → merge\n    .add_edge(\"branch_b\", \"merge\")   # branch_b → merge\n    .entry_node(\"start\")\n    .build()\n)\nParallelism is determined by Platform Core at runtime, not by the SDK.","resources-prompts-tools-modules#Resources: Prompts, Tools, Modules":"","prompts#Prompts":"Prompts define LLM interactions:\nprompt = (\n    PromptBuilder(\"classify\")\n    .description(\"Classify text sentiment\")\n    .template(\n        \"Classify the sentiment of this text as positive, negative, or neutral:\\n\"\n        \"{{text}}\\n\"\n        \"Sentiment:\"\n    )\n    .variables(\"text\")\n    .build()\n)","tools#Tools":"Tools declare external service integrations:\nweather_tool = (\n    ToolBuilder(\"weather-api\")\n    .description(\"Fetch current weather data\")\n    .input_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\"type\": \"string\"}\n        },\n        \"required\": [\"location\"]\n    })\n    .output_schema({\n        \"type\": \"object\",\n        \"properties\": {\n            \"temperature\": {\"type\": \"number\"},\n            \"conditions\": {\"type\": \"string\"}\n        }\n    })\n    .build()\n)\nTool Declarations vs Tool ImplementationsThe Agent Definition declares what tools are needed.\nPlatform Core manages how tools are implemented and called.The SDK doesn't implement tools—it just describes their interface.","modules#Modules":"Modules are reusable workflow components (see Modules Guide).","yaml-output#YAML Output":"Agent Definitions compile to YAML for submission to Platform Core:\nfrom ainalyn import export_yaml\nyaml_content = export_yaml(agent_definition)\nOutput:\n# Ainalyn Agent Definition\n# This is a description submitted to Platform Core for review.\nname: text-summarizer\nversion: 1.0.0\ndescription: Summarize long text into concise summaries\nworkflows:\n- name: main\n  description: Summarization workflow\n  entry_node: extract\n  nodes:\n  - name: extract\n    description: Extract key information\n    type: prompt\n    reference: summarize\n    outputs:\n    - summary\n  - name: format\n    description: Format output\n    type: module\n    reference: text-formatter\n    inputs:\n    - summary\n    outputs:\n    - formatted_output\n  edges:\n  - from: extract\n    to: format\nprompts:\n- name: summarize\n  description: Summarize text concisely\n  template: \"Summarize the following text:\\n{{input_text}}\"\n  variables:\n  - input_text","submission-and-lifecycle#Submission and Lifecycle":"Once you have a valid definition, submit it to Platform Core:\nfrom ainalyn import submit_agent\nresult = submit_agent(\n    definition=agent_definition,\n    api_key=\"dev_sk_your_key\"\n)\nprint(f\"Review ID: {result.review_id}\")\nprint(f\"Status: {result.status.value}\")","definition-lifecycle#Definition Lifecycle":"Build: Create definition using SDK\nValidate: SDK checks structural correctness\nSubmit: Send to Platform Core for review\nReview: Platform applies governance policies\nApprove/Reject: Platform decides if definition meets standards\nMarketplace: Approved definitions become available Agents\nExecution: Users invoke the Agent; Platform executes the definition\nAgent Definition vs Execution\nAgent Definition is a static description (what you build)\nExecution is a runtime instance (what Platform Core creates when a user invokes the agent)\nOne Agent Definition → Many Executions (one per user invocation)","platform-cores-role#Platform Core's Role":"Once submitted, Platform Core:✓ Reviews the definition for security, governance, and policy compliance\n✓ Approves or rejects based on platform standards\n✓ Stores approved definitions in the marketplace\n✓ Executes the definition when users invoke the agent\n✓ Manages all resources (LLMs, tools, modules) at runtime\n✓ Bills based on actual execution usage\nConstitutional BoundaryThe SDK can submit Agent Definitions but cannot approve them.Only Platform Core has the authority to:\nApprove or reject definitions\nCreate Executions\nDetermine billing\nEnforce governance\nThis is not a technical limitation—it's a governance rule that ensures platform integrity.","best-practices#Best Practices":"","1-version-your-definitions#1. Version Your Definitions":"Use semantic versioning:\n# Initial release\nagent_v1 = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\n# Bug fix (backward compatible)\nagent_v1_1 = AgentBuilder(\"my-agent\").version(\"1.0.1\").build()\n# New features (backward compatible)\nagent_v1_2 = AgentBuilder(\"my-agent\").version(\"1.2.0\").build()\n# Breaking changes (new major version)\nagent_v2 = AgentBuilder(\"my-agent\").version(\"2.0.0\").build()","2-write-clear-descriptions#2. Write Clear Descriptions":"# ✗ Vague\n.description(\"Does stuff\")\n# ✓ Clear\n.description(\"Extract email addresses from PDF documents\")","3-keep-workflows-simple#3. Keep Workflows Simple":"# ✓ Good: Linear, easy to understand\nworkflow = (\n    WorkflowBuilder(\"simple\")\n    .add_node(fetch)\n    .add_node(process)\n    .add_node(output)\n    .add_edge(\"fetch\", \"process\")\n    .add_edge(\"process\", \"output\")\n    .entry_node(\"fetch\")\n    .build()\n)\n# ⚠ Complex: Hard to debug, maintain\n# (20 nodes, 50 edges, multiple branches)","4-validate-before-submitting#4. Validate Before Submitting":"# Always validate locally first\nresult = validate(agent_definition)\nif not result.is_valid:\n    for error in result.errors:\n        print(f\"Fix: {error.message}\")\n    exit(1)\n# Only submit if validation passes\nsubmit_agent(agent_definition, api_key=api_key)","common-patterns#Common Patterns":"","sequential-processing#Sequential Processing":"workflow = (\n    WorkflowBuilder(\"sequential\")\n    .add_node(step1)\n    .add_node(step2)\n    .add_node(step3)\n    .add_edge(\"step1\", \"step2\")\n    .add_edge(\"step2\", \"step3\")\n    .entry_node(\"step1\")\n    .build()\n)","branching#Branching":"workflow = (\n    WorkflowBuilder(\"branching\")\n    .add_node(input_node)\n    .add_node(branch_a)\n    .add_node(branch_b)\n    .add_edge(\"input\", \"branch_a\")  # input → branch_a\n    .add_edge(\"input\", \"branch_b\")  # input → branch_b (parallel)\n    .entry_node(\"input\")\n    .build()\n)","converging#Converging":"workflow = (\n    WorkflowBuilder(\"converging\")\n    .add_node(source_a)\n    .add_node(source_b)\n    .add_node(merge)\n    .add_edge(\"source_a\", \"merge\")\n    .add_edge(\"source_b\", \"merge\")\n    .entry_node(\"source_a\")  # Note: source_b must also be reachable\n    .build()\n)","summary#Summary":"An Agent Definition is:\n✓ A declarative description of what your agent does\n✓ Built using the SDK's fluent builder API\n✓ Validated for structural correctness by the SDK\n✓ Compiled to YAML for submission\n✓ Submitted to Platform Core for review and approval\n✗ NOT an executable (Platform Core executes it)\n✗ NOT a runtime (SDK is a compiler)","next-steps#Next Steps":"Compiler, Not Runtime - Understand the SDK's role\nBuilding Your Agent - Design patterns and best practices\nWorkflows Guide - Deep dive into workflow construction\nValidation Guide - What gets validated and why"}},"/v1/concepts/compiler-not-runtime":{"title":"Compiler, Not Runtime","data":{"":"The Ainalyn SDK is a compiler, not a runtime. Understanding this distinction is critical to using the SDK correctly and avoiding common misconceptions about what the SDK does—and what only Platform Core can do.","the-core-distinction#The Core Distinction":"SDK = Compiler\nTransforms your Python code into a validated YAML definition.Platform Core = Runtime\nExecutes the definition, manages resources, handles billing, and enforces governance.\nThink of it like this:\nA compiler (like gcc or javac) transforms source code into executable format. It checks syntax, validates types, and catches errors—but it doesn't run your program.\nA runtime (like the JVM or operating system) actually executes the compiled output, manages memory, handles I/O, and enforces security policies.\nThe Ainalyn SDK is your compiler. Platform Core is your runtime.","what-the-sdk-actually-does#What the SDK Actually Does":"The SDK's job is to help you build a valid Agent Definition and catch errors early:\nfrom ainalyn import AgentBuilder, validate, export_yaml\n# Build: Describe what your agent does\nagent = (\n    AgentBuilder(\"email-parser\")\n    .version(\"1.0.0\")\n    .description(\"Extract emails from text\")\n    .add_workflow(workflow)\n    .build()\n)\n# Validate: Check for structural errors\nresult = validate(agent)\nif result.is_valid:\n    # Compile: Transform to YAML\n    yaml_output = export_yaml(agent)\nAt this point, you have a description. Not an execution. Not a running agent. Just a validated definition ready for submission to Platform Core.","what-the-sdk-does-not-do#What the SDK Does NOT Do":"The SDK does not and cannot:\nExecute your agent workflows\nCall external APIs or tools\nManage authentication or API keys\nCalculate execution costs\nHandle retries or error recovery\nMake decisions about billing\nEnforce governance policies\nCreate Executions\nThese are Platform Core responsibilities. Only Platform Core has the authority to execute, bill, and govern.","why-this-matters#Why This Matters":"","1-local-validation--platform-approval#1. Local Validation ≠ Platform Approval":"Just because your agent compiles successfully doesn't mean Platform Core will accept it:\n# SDK says: \"Valid structure\"\nresult = validate(agent)\nassert result.is_valid  # ✓ Passes\n# But Platform Core might still reject it for:\n# - Security policy violations\n# - Excessive resource usage\n# - Restricted content\n# - Governance rules\n# - Business policy constraints\nThe SDK checks structural correctness. Platform Core enforces platform policies.","2-sdk-cannot-predict-execution-costs#2. SDK Cannot Predict Execution Costs":"# This does NOT calculate costs\nagent = AgentBuilder(\"my-agent\").build()\n# ❌ No cost estimation available\n# Costs are determined by:\n# - Actual execution (runtime usage)\n# - Resources consumed (tokens, API calls)\n# - Platform pricing policy\n# - Dynamic factors (model costs, etc.)\nOnly Platform Core knows execution costs because only Platform Core executes agents.","3-sdk-cannot-run-workflows#3. SDK Cannot Run Workflows":"# This creates a DESCRIPTION of a workflow\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .add_node(node1)\n    .add_node(node2)\n    .add_edge(\"node1\", \"node2\")\n    .build()\n)\n# ❌ SDK cannot run this workflow\n# ❌ SDK cannot call the tools/prompts\n# ❌ SDK cannot produce execution results\n# ✓ SDK can only validate structure:\n# - Is it a valid DAG?\n# - Are all references defined?\n# - Are there cycles or unreachable nodes?","the-compilation-process#The Compilation Process":"What happens when you use the SDK:\nSteps 1-6: SDK (Compiler)\nStep 7: Platform Core (Runtime)","compilation-steps#Compilation Steps":"Build: Use fluent API to construct definition\nagent = AgentBuilder(\"my-agent\").version(\"1.0.0\").build()\nValidate: Check structural correctness\nresult = validate(agent)\nExport: Transform to YAML\nyaml_content = export_yaml(agent)\nSubmit: Send to Platform Core for review\nsubmission = submit_agent(agent, api_key=\"dev_sk_xxx\")","platform-core-steps-outside-sdk#Platform Core Steps (Outside SDK)":"Review: Platform applies governance policies\nApprove/Reject: Platform decides if agent can be listed\nMarketplace: Agent becomes available to users\nExecution: Users invoke agent → Platform creates Execution\nBilling: Platform calculates costs based on actual usage","execution-authority#Execution Authority":"Per the Platform Constitution, execution authority belongs exclusively to Platform Core.\nEntity\tCan Describe\tCan Execute\tCan Bill\tSDK\t✓\t✗\t✗\tPlatform Core\t✓\t✓\t✓\tClient Apps\t✗\t✗\t✗\tDeveloper\t✓ (via SDK)\t✗\t✗\t\nHard Constraint: No system except Platform Core can create Executions, determine execution success/failure, or calculate billing.This is not a technical limitation—it's a governance boundary that ensures consistency, security, and fair billing across the platform.","common-misconceptions#Common Misconceptions":"","-the-sdk-runs-my-agent-locally#❌ \"The SDK runs my agent locally\"":"No. The SDK builds a definition. Platform Core runs agents.\n# This doesn't run anything\nagent = AgentBuilder(\"test\").build()\nvalidate(agent)  # Just checks structure","-if-validation-passes-my-agent-will-work#❌ \"If validation passes, my agent will work\"":"Not guaranteed. The SDK validates structure. Platform Core validates policy.\n# Passes SDK validation\nresult = validate(agent)\nassert result.is_valid\n# But Platform Core might reject for:\n# - Security violations\n# - Resource limits\n# - Governance policies","-i-can-test-execution-locally#❌ \"I can test execution locally\"":"No. There is no local runtime. You must submit to Platform Core.\n# ❌ No local testing available\n# ❌ No simulation mode\n# ✓ Submit to Platform Core for real execution","-the-sdk-handles-billing#❌ \"The SDK handles billing\"":"Never. Billing is always Platform Core's responsibility.\n# SDK cannot and will not:\n# - Calculate costs\n# - Apply pricing policies\n# - Generate invoices\n# - Process payments","what-you-control#What You Control":"As a developer using the SDK, you control:✓ Agent Definition structure\nWorkflows, nodes, prompts, tools\nInput/output specifications\nResource declarations\n✓ Local validation\nCatch structural errors early\nVerify reference integrity\nCheck DAG validity\n✓ YAML output\nFormat for submission\nVersion control\nDocumentation\n✗ Execution - Platform Core only\n✗ Billing - Platform Core only\n✗ Governance - Platform Core only\n✗ Resource allocation - Platform Core only\n✗ User authentication - Platform Core only","the-boundary#The Boundary":"┌─────────────────────────────────────────────────────────┐\n│  YOUR RESPONSIBILITY (SDK as Compiler)                  │\n│                                                          │\n│  • Write agent definitions                              │\n│  • Validate structure                                   │\n│  • Export to YAML                                       │\n│  • Submit to Platform Core                              │\n│                                                          │\n└─────────────────────────────────────────────────────────┘\n                            ↓\n                     [Submit Definition]\n                            ↓\n┌─────────────────────────────────────────────────────────┐\n│  PLATFORM CORE RESPONSIBILITY (Runtime)                 │\n│                                                          │\n│  • Review and approve definitions                       │\n│  • Execute workflows                                    │\n│  • Manage resources (LLMs, tools, APIs)                 │\n│  • Handle authentication                                │\n│  • Enforce governance policies                          │\n│  • Calculate costs and billing                          │\n│  • Create and manage Executions                         │\n│  • Deliver results to users                             │\n│                                                          │\n└─────────────────────────────────────────────────────────┘","summary#Summary":"The Ainalyn SDK is a description compiler, not an execution runtime:\nCompilers validate and transform — The SDK checks structure and exports YAML\nRuntimes execute and manage — Platform Core runs workflows and handles everything else\nBoundaries are constitutional — These aren't technical limitations; they're governance rules that ensure platform integrity\nWhen you use the SDK, you're writing a recipe (Agent Definition).\nPlatform Core is the kitchen that actually cooks it (Execution).","next-steps#Next Steps":"Agent Definition - Understand the definition structure\nWhat You Control - SDK vs Platform responsibilities in detail\nValidation - What the SDK validates and why"}},"/v1/concepts/how-the-sdk-works":{"title":"How the SDK Works","data":{"":"The SDK is a compiler that transforms Python code into validated YAML definitions for Platform Core.","core-function#Core Function":"SDK Purpose: Create and validate Agent Definitions locally before platform submission.It does NOT execute agents or simulate runtime behavior.","compilation-pipeline#Compilation Pipeline":"Python Code → Builders → Entities → Validation → YAML","step-1-define-with-builders#Step 1: Define with Builders":"Builders provide a fluent API for constructing definitions:\nfrom ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Main processing workflow\")\n    .add_node(\n        NodeBuilder(\"task\")\n        .description(\"Process data\")\n        .uses_prompt(\"task-prompt\")\n        .build()\n    )\n    .entry_node(\"task\")\n    .build()\n)\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Processes user data\")\n    .add_workflow(workflow)\n    .build()\n)\nBuilders perform immediate validation:\nName format checking\nRequired field validation\nDuplicate detection\nReference integrity","step-2-validate-definition#Step 2: Validate Definition":"from ainalyn.api import validate\nresult = validate(agent)\nValidation performs:\nSchema Validation\nStructural correctness\nType checking\nRequired fields present\nStatic Analysis\nWorkflow is DAG (no cycles)\nAll nodes reachable from entry\nAll references resolve\nNo orphaned resources\nif result.is_valid:\n    print(\"Validation passed\")\nelse:\n    for error in result.errors:\n        print(f\"{error.severity}: {error.code} - {error.message}\")","step-3-export-to-yaml#Step 3: Export to YAML":"from ainalyn.api import export_yaml\nyaml_output = export_yaml(agent)\nprint(yaml_output)\nOutput format:\n# Ainalyn Agent Definition\n# This file is a description submitted to Platform Core for review.\n# It does NOT execute by itself. Execution is handled by Platform Core.\nname: my-agent\nversion: 1.0.0\ndescription: Processes user data\nworkflows:\n- name: process\n  description: Main processing workflow\n  entry_node: task\n  nodes:\n  - name: task\n    description: Process data\n    type: prompt\n    reference: task-prompt","what-the-sdk-validates#What the SDK Validates":"","builder-time-validation#Builder-Time Validation":"Immediate checks when calling .build():\nName format: [a-z][a-z0-9-]*\nVersion format: Semantic versioning\nRequired fields present\nNo duplicate names in scope\nReferenced resources exist\nExample error:\nAgentBuilder(\"Invalid Name\")  # Raises InvalidFormatError\n# InvalidFormatError: Invalid value for 'name': 'Invalid Name'.\n# Agent name must start with lowercase letter and contain only\n# lowercase letters, numbers, and hyphens","compile-time-validation#Compile-Time Validation":"Checks performed by validate():","schema-validation#Schema Validation":"All required fields present\nField types correct\nValues within constraints","static-analysis#Static Analysis":"Cycle Detection\n# This fails validation:\n# node-a → node-b → node-c → node-a (cycle!)\nError: CyclicDependencyError: Workflow contains a cycle: node-a → node-b → node-c → node-a\nReachability Analysis\n# This fails if node-orphan is unreachable:\nError: UnreachableNodeError: Node 'node-orphan' is unreachable from entry node 'start'\nReference Resolution\n# This fails if prompt doesn't exist:\nNodeBuilder(\"task\").uses_prompt(\"undefined-prompt\")\nError: ReferenceError: 'task' references undefined prompt 'undefined-prompt'","what-the-sdk-does-not-do#What the SDK Does NOT Do":"The SDK is NOT a runtime. It cannot and does not:\nExecute workflows\nMake network requests\nCall tools or modules\nCalculate costs\nAuthenticate users\nHandle retries\nManage state\nThese are Platform Core responsibilities.","complete-workflow#Complete Workflow":"","developer-side-sdk#Developer Side (SDK)":"# 1. Define agent\nagent = AgentBuilder(\"processor\").version(\"1.0.0\")...build()\n# 2. Validate locally\nresult = validate(agent)\nif not result.is_valid:\n    for error in result.errors:\n        print(error)\n    exit(1)\n# 3. Export to YAML\nyaml_content = export_yaml(agent)\n# 4. Write to file\nwith open(\"agent.yaml\", \"w\") as f:\n    f.write(yaml_content)\n# 5. Submit to platform (outside SDK scope)","platform-side-not-sdk#Platform Side (NOT SDK)":"Receive YAML submission\nApply governance policies\nReview definition\nApprove or reject\nMake available in marketplace\nHandle execution requests\nAllocate resources\nExecute workflows\nReturn results\nCalculate costs\nProcess payments","validation-result-structure#Validation Result Structure":"from ainalyn.api import validate\nresult = validate(agent)\n# Properties\nresult.is_valid         # bool: No errors\nresult.has_warnings     # bool: Has warnings\nresult.errors           # tuple[ValidationError, ...]\n# ValidationError structure\nfor error in result.errors:\n    error.code          # str: Error code (e.g., \"CYCLIC_DEPENDENCY\")\n    error.message       # str: Human-readable message\n    error.severity      # Severity: ERROR or WARNING\n    error.location      # Optional[str]: Where error occurred","error-codes#Error Codes":"","build-time-errors#Build-Time Errors":"Code\tDescription\tExample\tMISSING_FIELD\tRequired field not provided\tMissing version\tINVALID_FORMAT\tValue doesn't match pattern\tInvalid name format\tDUPLICATE_NAME\tName used multiple times in scope\tTwo nodes named \"task\"\tREFERENCE_ERROR\tResource reference not found\tNode uses undefined prompt\tEMPTY_COLLECTION\tRequired collection is empty\tAgent with no workflows","validation-errors#Validation Errors":"Code\tDescription\tExample\tCYCLIC_DEPENDENCY\tWorkflow contains cycle\tnode-a → node-b → node-a\tUNREACHABLE_NODE\tNode not reachable from entry\tOrphaned node\tSCHEMA_VIOLATION\tDefinition doesn't match schema\tInvalid field type","api-functions#API Functions":"","validate#validate()":"from ainalyn.api import validate\nfrom ainalyn.domain.entities import AgentDefinition\ndef validate(definition: AgentDefinition) -> ValidationResult:\n    \"\"\"\n    Validate agent definition structure and logic.\n    Parameters:\n        definition: AgentDefinition to validate\n    Returns:\n        ValidationResult with errors and warnings\n    Validation includes:\n    - Schema validation\n    - Static analysis (cycles, reachability)\n    - Reference integrity\n    \"\"\"","export_yaml#export_yaml()":"from ainalyn.api import export_yaml\nfrom ainalyn.domain.entities import AgentDefinition\ndef export_yaml(definition: AgentDefinition) -> str:\n    \"\"\"\n    Export agent definition to YAML string.\n    Parameters:\n        definition: AgentDefinition to export\n    Returns:\n        YAML-formatted string with header comments\n    Note: Does NOT validate before export.\n          Use compile_agent() for validation + export.\n    \"\"\"","compile_agent#compile_agent()":"from ainalyn.api import compile_agent\nfrom ainalyn.domain.entities import AgentDefinition\nfrom pathlib import Path\ndef compile_agent(\n    definition: AgentDefinition,\n    output_path: Path | None = None\n) -> CompilationResult:\n    \"\"\"\n    Validate and export agent definition.\n    Parameters:\n        definition: AgentDefinition to compile\n        output_path: Optional path to write YAML file\n    Returns:\n        CompilationResult with:\n        - validation_result: ValidationResult\n        - yaml_content: str | None (if successful)\n        - output_path: Path | None (if written)\n        - is_successful: bool\n    Workflow:\n    1. Validate definition\n    2. Export to YAML (only if valid)\n    3. Write to file (if output_path provided)\n    \"\"\"","development-flow#Development Flow":"","recommended-approach#Recommended Approach":"from ainalyn import AgentBuilder\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# 1. Build definition\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Agent description\")\n    .add_workflow(workflow)\n    .build()  # ← Immediate validation\n)\n# 2. Compile with validation\nresult = compile_agent(agent, Path(\"output.yaml\"))\n# 3. Check result\nif result.is_successful:\n    print(f\"Success! Written to {result.output_path}\")\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.code}: {error.message}\")","quick-validation#Quick Validation":"from ainalyn.api import validate\nresult = validate(agent)\nif result.is_valid:\n    print(\"Valid definition\")\nelse:\n    for error in result.errors:\n        print(f\"{error.severity}: {error.message}\")","common-patterns#Common Patterns":"","iterative-development#Iterative Development":"# Build incrementally\nagent = AgentBuilder(\"test-agent\").version(\"1.0.0\")\n# Add components\nagent = agent.description(\"Test agent\")\nagent = agent.add_workflow(workflow)\n# Validate at each step\ntry:\n    built_agent = agent.build()\n    result = validate(built_agent)\n    if result.is_valid:\n        print(\"Ready to export\")\nexcept DomainError as e:\n    print(f\"Build error: {e}\")","error-handling#Error Handling":"from ainalyn.domain.errors import (\n    MissingFieldError,\n    InvalidFormatError,\n    ReferenceError,\n    DomainError\n)\ntry:\n    agent = AgentBuilder(\"my-agent\").build()\nexcept MissingFieldError as e:\n    print(f\"Missing: {e.field_name}\")\nexcept InvalidFormatError as e:\n    print(f\"Invalid {e.field_name}: {e.value}\")\nexcept ReferenceError as e:\n    print(f\"Undefined {e.resource_type}: {e.reference}\")\nexcept DomainError as e:\n    print(f\"Error: {e.message}\")","best-practices#Best Practices":"","1-validate-early-and-often#1. Validate Early and Often":"# Validate after each major change\nworkflow = WorkflowBuilder(...).build()  # Validates workflow\nagent = AgentBuilder(...).build()        # Validates agent\nresult = validate(agent)                 # Full validation","2-use-compile_agent-for-production#2. Use compile_agent() for Production":"# Combines validation + export\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif not result.is_successful:\n    # Handle errors before submission\n    pass","3-handle-errors-specifically#3. Handle Errors Specifically":"# Catch specific error types\ntry:\n    agent = builder.build()\nexcept InvalidFormatError as e:\n    # Fix name format issues\n    pass\nexcept ReferenceError as e:\n    # Add missing resources\n    pass","4-review-generated-yaml#4. Review Generated YAML":"# Always inspect output\nyaml = export_yaml(agent)\nprint(yaml)  # Ensure it matches intent","next-steps#Next Steps":"What You Control - SDK vs Platform boundaries\nBuilding Your Agent - Design patterns\nValidation Guide - Detailed validation rules\nError Handling - Complete error reference"}},"/v1/concepts/what-is-an-agent":{"title":"What is an Agent?","data":{"":"An Agent is a declarative definition that describes a complete task workflow. The SDK helps you build valid definitions for submission to Platform Core.","core-concept#Core Concept":"An Agent Definition specifies:\nTask inputs and outputs\nProcessing workflow (DAG of nodes)\nRequired resources (prompts, tools, modules)\nVersion and metadata\nThe SDK compiles Agent Definitions to YAML. Platform Core executes them.","structure#Structure":"Every Agent has these components:\nagent = (\n    AgentBuilder(\"agent-name\")\n    .version(\"1.0.0\")           # Required: Semantic version\n    .description(\"What it does\") # Required: One-line description\n    .add_workflow(workflow)      # Required: At least one workflow\n    .add_prompt(prompt)          # Optional: LLM prompt templates\n    .add_tool(tool)              # Optional: External service definitions\n    .add_module(module)          # Optional: Reusable components\n    .build()\n)","workflows#Workflows":"Define processing logic as directed acyclic graphs (DAGs):\nworkflow = (\n    WorkflowBuilder(\"process\")\n    .description(\"Main processing workflow\")\n    .add_node(node1)\n    .add_node(node2)\n    .entry_node(\"node1\")  # Required: Entry point\n    .build()\n)","nodes#Nodes":"Individual processing steps:\nnode = (\n    NodeBuilder(\"extract-data\")\n    .description(\"Extract data from input\")\n    .uses_prompt(\"extraction-prompt\")  # References a prompt\n    .outputs(\"extracted_data\")\n    .next_nodes(\"validate-data\")\n    .build()\n)\nNode types are determined by resource reference:\nuses_prompt() - LLM-based processing\nuses_tool() - External service call\nuses_module() - Reusable component invocation","sdk-boundary#SDK Boundary":"The SDK is a compiler, not a runtime:\nSDK Does\tSDK Does NOT Do\tValidate definition structure\tExecute workflows\tCheck reference integrity\tMake network requests\tGenerate YAML output\tCalculate execution costs\tPerform static analysis\tHandle authentication\tCatch cycles and unreachable nodes\tManage retries\t\nLocal compilation success does not guarantee platform execution. Platform Core applies additional validation and governance policies.","execution-flow#Execution Flow":"Developer builds Agent Definition using SDK\nSDK validates structure and exports YAML\nDeveloper submits YAML to Platform Core\nPlatform reviews and approves definition\nUsers invoke Agent through official clients\nPlatform creates Execution instance\nPlatform runs workflow and returns results\nPlatform handles billing and payment","agent-definition-vs-execution#Agent Definition vs Execution":"Key distinction:\n# This creates a DEFINITION\nagent = AgentBuilder(\"my-agent\").build()\n# This validates and exports the DEFINITION\nvalidate(agent)\nyaml = export_yaml(agent)\n# Platform Core handles EXECUTION (not SDK)\n# - User authentication\n# - Resource allocation\n# - Workflow execution\n# - Result delivery\n# - Billing","required-fields#Required Fields":"Agent Definition:\nname - Matches pattern [a-z][a-z0-9-]*\nversion - Semantic versioning (e.g., \"1.0.0\")\ndescription - Human-readable summary\nworkflows - At least one workflow\nWorkflow:\nname - Matches pattern [a-z][a-z0-9-]*\ndescription - Workflow purpose\nnodes - At least one node\nentry_node - Name of starting node\nNode:\nname - Matches pattern [a-z][a-z0-9-]*\ndescription - Node purpose\ntype - One of: prompt, tool, module\nreference - Name of referenced resource","example-email-extractor#Example: Email Extractor":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate, export_yaml\n# Define prompt\nextraction_prompt = (\n    PromptBuilder(\"extract-emails\")\n    .description(\"Extract email addresses from text\")\n    .template(\"Extract all email addresses from: {{text}}\")\n    .variables(\"text\")\n    .build()\n)\n# Define workflow\nworkflow = (\n    WorkflowBuilder(\"extract\")\n    .description(\"Email extraction workflow\")\n    .add_node(\n        NodeBuilder(\"parse-text\")\n        .description(\"Parse input text\")\n        .uses_prompt(\"extract-emails\")\n        .outputs(\"email_list\")\n        .build()\n    )\n    .entry_node(\"parse-text\")\n    .build()\n)\n# Build agent\nagent = (\n    AgentBuilder(\"email-extractor\")\n    .version(\"1.0.0\")\n    .description(\"Extract email addresses from documents\")\n    .add_prompt(extraction_prompt)\n    .add_workflow(workflow)\n    .build()\n)\n# Validate\nresult = validate(agent)\nif result.is_valid:\n    yaml_output = export_yaml(agent)\n    print(yaml_output)","validation#Validation":"The SDK performs:\nSchema validation - Structural correctness\nStatic analysis - Logical consistency\nChecks include:\nRequired fields present\nNames match pattern [a-z][a-z0-9-]*\nVersions follow semantic versioning\nAll references resolve (no undefined resources)\nWorkflows form valid DAGs (no cycles)\nAll nodes reachable from entry node\nNo duplicate names within scope","output-format#Output Format":"Agents compile to YAML:\nname: email-extractor\nversion: 1.0.0\ndescription: Extract email addresses from documents\nworkflows:\n- name: extract\n  description: Email extraction workflow\n  entry_node: parse-text\n  nodes:\n  - name: parse-text\n    description: Parse input text\n    type: prompt\n    reference: extract-emails\n    outputs:\n    - email_list\nprompts:\n- name: extract-emails\n  description: Extract email addresses from text\n  template: Extract all email addresses from: {{text}}\n  variables:\n  - text\nThis YAML is submitted to Platform Core for execution.","next-steps#Next Steps":"How the SDK Works - Compilation process\nWhat You Control - SDK vs Platform responsibilities\nBuilding Your Agent - Design patterns"}},"/v1/getting-started":{"title":"Ainalyn SDK","data":{"":"Build task-oriented agents with Python. The Ainalyn SDK is a compiler that turns your Python code into platform-ready agent definitions.\nSDK = Compiler, Not RuntimeThe SDK creates agent descriptions. The Ainalyn Platform executes them.","user-flow#User Flow":"","what-it-does#What it does":"Define agents with a Python API\nValidate definitions before deployment\nExport to YAML for the platform","features#Features":"Type-safe API - Full type hints and IDE autocomplete\nFluent builders - Chainable, intuitive API\nValidation - Catch errors before deployment\nYAML export - One command to platform-ready format","example#Example":"from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder, PromptBuilder\nfrom ainalyn.api import validate, export_yaml\n# Define a prompt\ngreeting_prompt = (\n    PromptBuilder(\"greeting-prompt\")\n    .description(\"Generates a personalized greeting\")\n    .template(\"Generate a personalized greeting for {{user_name}}\")\n    .variables(\"user_name\")\n    .build()\n)\n# Define an agent\nagent = (\n    AgentBuilder(\"greeting-agent\")\n    .description(\"Generates personalized greetings\")\n    .version(\"1.0.0\")\n    .add_prompt(greeting_prompt)\n    .add_workflow(\n        WorkflowBuilder(\"greet-user\")\n        .description(\"Main greeting workflow\")\n        .add_node(\n            NodeBuilder(\"generate-greeting\")\n            .description(\"Generate a personalized greeting\")\n            .uses_prompt(\"greeting-prompt\")\n            .outputs(\"greeting\")\n            .build()\n        )\n        .entry_node(\"generate-greeting\")\n        .build()\n    )\n    .build()\n)\n# Validate and export\nvalidate(agent)\nyaml_output = export_yaml(agent)","getting-started#Getting Started":"New to the SDK?\nInstall the SDK\nTry the 5-minute quickstart\nBuild your first agent\nUnderstanding the SDK\nPlatform Boundaries - What the SDK can and cannot do\nCompiler vs Runtime - Why the SDK is a compiler\nArchitecture - How it's built\nAgent Definitions - What you're creating","important-sdk-boundaries#Important: SDK Boundaries":"The SDK creates descriptions. The platform runs them.What the SDK does:\nDefine agent structures\nValidate definitions\nExport to YAML\nWhat the SDK does NOT do:\nExecute agents\nHandle billing\nManage retries or timeouts\nLearn more about platform boundaries","support#Support":"Report issues\nAsk questions\nView source"}},"/v1/guides/prompts":{"title":"Prompts","data":{"":"How to create reusable LLM prompt templates for your agents.","what-is-a-prompt#What is a Prompt?":"A prompt is a template that defines how to interact with Language Models. It supports:\nTemplate text with variable placeholders\nVariable interpolation using {{variable}} syntax\nReusability across multiple workflows\nImportant: The SDK defines the prompt template. The platform handles LLM invocation.","creating-a-prompt#Creating a Prompt":"from ainalyn import PromptBuilder\nprompt = (\n    PromptBuilder(\"data-analyzer\")\n    .description(\"Analyzes data and provides insights\")\n    .template(\"\"\"\nPlease analyze the following data:\n{{data}}\nFocus on: {{focus_areas}}\nProvide detailed insights and recommendations.\n\"\"\")\n    .variables([\"data\", \"focus_areas\"])\n    .build()\n)","variable-syntax#Variable Syntax":"Use {{variable_name}} to mark placeholders in your template.\ntemplate = \"\"\"\nHello {{name}},\nYour order {{order_id}} has been {{status}}.\nThank you!\n\"\"\"\nprompt = (\n    PromptBuilder(\"order-notification\")\n    .template(template)\n    .variables([\"name\", \"order_id\", \"status\"])\n    .build()\n)\nAt runtime:\nPlatform replaces {{name}} with actual value\nVariables come from node inputs or previous outputs","using-prompts-in-workflows#Using Prompts in Workflows":"Step 1: Define the prompt\nanalyzer = (\n    PromptBuilder(\"analyzer\")\n    .description(\"Analyzes text content\")\n    .template(\"Analyze this: {{content}}\")\n    .variables([\"content\"])\n    .build()\n)\nStep 2: Add prompt to agent\nagent = (\n    AgentBuilder(\"text-agent\")\n    .version(\"1.0.0\")\n    .add_prompt(analyzer)  # Register prompt\n    .add_workflow(workflow)\n    .build()\n)\nStep 3: Reference in node\nfrom ainalyn import NodeBuilder\nnode = (\n    NodeBuilder(\"analyze\")\n    .description(\"Analyze content\")\n    .uses_prompt(\"analyzer\")  # References the prompt\n    .inputs(\"content\")\n    .outputs(\"analysis\")\n    .build()\n)","common-prompt-patterns#Common Prompt Patterns":"","text-analysis#Text Analysis":"analyzer = (\n    PromptBuilder(\"text-analyzer\")\n    .description(\"Analyzes text for sentiment and key points\")\n    .template(\"\"\"\nAnalyze the following text:\n{{text}}\nProvide:\n1. Sentiment (positive/negative/neutral)\n2. Key points (3-5 bullet points)\n3. Summary (1-2 sentences)\n\"\"\")\n    .variables([\"text\"])\n    .build()\n)","data-summarization#Data Summarization":"summarizer = (\n    PromptBuilder(\"data-summarizer\")\n    .description(\"Summarizes structured data\")\n    .template(\"\"\"\nSummarize this data:\n{{data}}\nFormat: {{format}}\nInclude statistics and key findings.\n\"\"\")\n    .variables([\"data\", \"format\"])\n    .build()\n)","content-generation#Content Generation":"generator = (\n    PromptBuilder(\"content-generator\")\n    .description(\"Generates content based on topic\")\n    .template(\"\"\"\nWrite a {{content_type}} about {{topic}}.\nTone: {{tone}}\nLength: {{length}} words\nRequirements:\n{{requirements}}\n\"\"\")\n    .variables([\"content_type\", \"topic\", \"tone\", \"length\", \"requirements\"])\n    .build()\n)","translation#Translation":"translator = (\n    PromptBuilder(\"translator\")\n    .description(\"Translates text between languages\")\n    .template(\"\"\"\nTranslate the following text from {{source_lang}} to {{target_lang}}:\n{{text}}\nMaintain the original tone and style.\n\"\"\")\n    .variables([\"source_lang\", \"target_lang\", \"text\"])\n    .build()\n)","qa-assistant#Q&A Assistant":"qa = (\n    PromptBuilder(\"qa-assistant\")\n    .description(\"Answers questions based on context\")\n    .template(\"\"\"\nContext:\n{{context}}\nQuestion: {{question}}\nProvide a clear, concise answer based only on the context provided.\n\"\"\")\n    .variables([\"context\", \"question\"])\n    .build()\n)","multiline-templates#Multiline Templates":"Use Python triple quotes for readable templates:\n# Readable multiline template\ntemplate = \"\"\"\nAnalyze the following report:\nTitle: {{title}}\nDate: {{date}}\nAuthor: {{author}}\nContent:\n{{content}}\nProvide a summary and key takeaways.\n\"\"\"\n# Avoid hard to read single line\n# template = \"Analyze: {{title}} Date: {{date}}...\"","variables-best-practices#Variables Best Practices":"1. List all variables used\n# All variables declared\nPromptBuilder(\"analyzer\")\n    .template(\"Analyze {{data}} focusing on {{aspect}}\")\n    .variables([\"data\", \"aspect\"])\n# Missing variable declaration - avoid this\nPromptBuilder(\"analyzer\")\n    .template(\"Analyze {{data}} focusing on {{aspect}}\")\n    .variables([\"data\"])  # Missing \"aspect\"\n2. Use descriptive variable names\n# Clear variable names\n.variables([\"user_email\", \"order_id\", \"delivery_date\"])\n# Unclear - avoid\n.variables([\"e\", \"id\", \"d\"])\n3. Keep variable count manageable\n# Focused prompt with 2-4 variables\n.variables([\"topic\", \"tone\", \"length\"])\n# Too many variables - consider splitting\n# .variables([\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\"])","prompt-naming#Prompt Naming":"Valid names:\n\"text-analyzer\"       # Lowercase with hyphens\n\"data-summarizer\"     # Descriptive\n\"qa-assistant-v2\"     # With version\nInvalid names:\n\"TextAnalyzer\"        # Must be lowercase\n\"text_analyzer\"       # No underscores\n\"my prompt\"           # No spaces","prompt-design-tips#Prompt Design Tips":"1. Be specific\n# Specific instructions\ntemplate = \"\"\"\nAnalyze the sentiment of this customer review:\n{{review}}\nClassify as: positive, negative, or neutral\nProvide reasoning in 1-2 sentences\n\"\"\"\n# Vague - avoid\n# template = \"What do you think about {{review}}?\"\n2. Structure the output\n# Structured output request\ntemplate = \"\"\"\nSummarize: {{article}}\nFormat:\n- Main idea: [1 sentence]\n- Key points: [3-5 bullets]\n- Conclusion: [1 sentence]\n\"\"\"\n# Unstructured - may give inconsistent results\n# template = \"Summarize {{article}}\"\n3. Provide context\n# With context\ntemplate = \"\"\"\nYou are a technical documentation expert.\nReview this code documentation:\n{{documentation}}\nSuggest improvements for clarity and completeness.\n\"\"\"\n# No context - less effective\n# template = \"Review {{documentation}}\"","complete-example#Complete Example":"from ainalyn import (\n    AgentBuilder,\n    WorkflowBuilder,\n    NodeBuilder,\n    PromptBuilder,\n    NodeType\n)\n# Define prompt\nreview_prompt = (\n    PromptBuilder(\"code-reviewer\")\n    .description(\"Reviews code for quality and best practices\")\n    .template(\"\"\"\nReview the following code:\nLanguage: {{language}}\nCode:\n{{code}}\nProvide:\n1. Overall quality assessment\n2. Potential issues or bugs\n3. Suggestions for improvement\n4. Best practice recommendations\n\"\"\")\n    .variables([\"language\", \"code\"])\n    .build()\n)\n# Use in workflow\nworkflow = (\n    WorkflowBuilder(\"code-review\")\n    .entry_node(\"review\")\n    .add_node(\n        NodeBuilder(\"review\")\n        .description(\"Review submitted code\")\n        .uses_prompt(\"code-reviewer\")\n        .inputs(\"language\", \"code\")\n        .outputs(\"review_result\")\n        .build()\n    )\n    .build()\n)\n# Create agent\nagent = (\n    AgentBuilder(\"code-review-agent\")\n    .version(\"1.0.0\")\n    .description(\"Automated code review assistant\")\n    .add_prompt(review_prompt)\n    .add_workflow(workflow)\n    .build()\n)","prompt-vs-module-vs-tool#Prompt vs Module vs Tool":"Use Prompt when:\nYou need LLM-based reasoning\nTask involves text understanding or generation\nOutput is natural language\nUse Module when:\nYou need deterministic logic\nTask is computation or data processing\nSee Modules Guide\nUse Tool when:\nYou need external services\nTask involves APIs or databases\nSee Tools Guide","see-also#See Also":"PromptBuilder API - Full API reference\nModules Guide - Custom business logic\nTools Guide - External integrations\nWorkflows - Using prompts in workflows"}},"/v1/guides/yaml-export":{"title":"YAML Export","data":{"":"Convert agent definitions to platform-ready YAML format.","what-is-yaml-export#What is YAML Export?":"YAML export transforms your Python agent definition into a YAML file that the Ainalyn Platform can execute.Key points:\nYAML is the platform's input format\nExport does NOT execute your agent\nThe platform reads YAML files to run agents\nSDK is a compiler, not a runtime","using-export_yaml#Using export_yaml()":"from ainalyn import AgentBuilder, export_yaml\nagent = (\n    AgentBuilder(\"my-agent\")\n    .version(\"1.0.0\")\n    .description(\"Process data\")\n    .add_workflow(workflow)\n    .build()\n)\n# Export to YAML string\nyaml_output = export_yaml(agent)\nprint(yaml_output)\nOutput:\nname: my-agent\nversion: 1.0.0\ndescription: Process data\nworkflows:\n  - name: main-workflow\n    description: Main processing workflow\n    entry_node: start\n    nodes:\n      - name: start\n        description: Start processing\n        type: prompt\n        reference: data-processor","saving-to-file#Saving to File":"from ainalyn import export_yaml\n# Export to string\nyaml_output = export_yaml(agent)\n# Save to file\nwith open(\"agent.yaml\", \"w\") as f:\n    f.write(yaml_output)\nprint(\"Saved to agent.yaml\")","using-compile_agent#Using compile_agent()":"Recommended: Use compile_agent() for automatic validation and export.\nfrom ainalyn.api import compile_agent\nfrom pathlib import Path\n# Validates and exports in one step\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(f\"Compiled to {result.output_path}\")\n    print(result.yaml_content)\nelse:\n    print(\"Compilation failed:\")\n    for error in result.validation_result.errors:\n        print(f\"  {error.message}\")\nAdvantages:\nValidates before exporting\nPrevents invalid YAML files\nReturns detailed error messages\nCreates parent directories automatically","yaml-structure#YAML Structure":"The exported YAML follows this structure:\n# Required fields\nname: agent-name\nversion: 1.0.0\ndescription: What the agent does\n# Workflows (required, at least one)\nworkflows:\n  - name: workflow-name\n    description: What this workflow does\n    entry_node: first-node\n    nodes:\n      - name: node-name\n        description: What this node does\n        type: prompt|module|tool\n        reference: resource-name\n        next_nodes:\n          - next-node-name\n        inputs:\n          - input-name\n        outputs:\n          - output-name\n# Resources (optional)\nmodules:\n  - name: module-name\n    description: What the module does\n    input_schema: {}\n    output_schema: {}\nprompts:\n  - name: prompt-name\n    description: What the prompt does\n    template: \"Prompt text with {variables}\"\n    variables:\n      - variable-name\ntools:\n  - name: tool-name\n    description: What the tool does\n    input_schema: {}\n    output_schema: {}","export-features#Export Features":"Unicode Support:\nagent = (\n    AgentBuilder(\"translator\")\n    .version(\"1.0.0\")\n    .description(\"翻譯助手\")  # Unicode supported\n    .build()\n)\nyaml_output = export_yaml(agent)\n# Output preserves Unicode characters\nDeterministic Ordering:\nKeys appear in consistent order\nWorkflows, modules, prompts, tools grouped logically\nReadable and version-control friendly\nHuman-Readable:\n# Indentation: 2 spaces\n# Flow style: False (multiline)\n# Sort keys: False (manual ordering)","export-vs-validation#Export vs Validation":"export_yaml() - No validation\n# Exports without checking validity\nyaml_output = export_yaml(agent)\n# May produce invalid YAML if agent is malformed\ncompile_agent() - Validates first\n# Validates before exporting\nresult = compile_agent(agent)\nif result.is_successful:\n    yaml_output = result.yaml_content\n# Only exports if valid","common-patterns#Common Patterns":"","export-to-string#Export to String":"from ainalyn import export_yaml\nyaml_string = export_yaml(agent)\nprint(yaml_string)","export-to-file#Export to File":"from ainalyn import export_yaml\nyaml_output = export_yaml(agent)\nwith open(\"agent.yaml\", \"w\", encoding=\"utf-8\") as f:\n    f.write(yaml_output)","validate-and-export#Validate and Export":"from ainalyn import validate, export_yaml\n# Validate first\nresult = validate(agent)\nif result.is_valid:\n    # Then export\n    yaml_output = export_yaml(agent)\n    with open(\"agent.yaml\", \"w\") as f:\n        f.write(yaml_output)\nelse:\n    print(\"Cannot export: validation failed\")","safe-compilation#Safe Compilation":"from ainalyn.api import compile_agent\nfrom pathlib import Path\n# All-in-one: validate + export + save\nresult = compile_agent(agent, Path(\"agent.yaml\"))\nif result.is_successful:\n    print(\"Ready for platform deployment\")\nelse:\n    print(f\"Fix these errors first:\")\n    for error in result.validation_result.errors:\n        print(f\"  - {error.message}\")","file-output#File Output":"Creating parent directories:\nfrom pathlib import Path\nfrom ainalyn.api import compile_agent\n# Creates 'output/' directory if it doesn't exist\nresult = compile_agent(agent, Path(\"output/agent.yaml\"))\nUTF-8 encoding:All files are written with UTF-8 encoding to support Unicode content.","what-happens-next#What Happens Next?":"After exporting your agent:\nYou created: YAML definition file\nPlatform reads: YAML to understand agent structure\nPlatform executes: Agent based on definition\nSDK's job is done: No runtime involvement\nSee Platform Boundaries for the SDK's role.","see-also#See Also":"Validation - Validate before export\ncompile_agent() API - Full API reference\nPlatform Boundaries - SDK vs Platform roles"}}}