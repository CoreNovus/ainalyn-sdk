# System Context

Understanding where the Ainalyn SDK fits in the overall system architecture.

---

## Application Architecture

{/* Application Architecture Diagram */}
<img src="/images/architecture.svg" alt="Application Architecture" style={{ width: '100%', maxWidth: '900px' }} />

---

## SDK as a Compiler

The most important concept to understand: the SDK is **compiler-first** with an optional runtime wrapper for ATOMIC handlers. Platform Core still owns execution, state, and billing.

---

## Key Boundaries

### What the SDK Does

| Responsibility | Description |
|----------------|-------------|
| **Define** | Provides builders to define Agent structure |
| **Validate** | Checks schema, review gates, and static analysis |
| **Export** | Produces platform-compatible YAML format |
| **Runtime wrapper (optional)** | Wraps ATOMIC handlers to follow the Core invocation protocol |
| **Compile** | Complete workflow: validate -> serialize -> output |

### What the SDK Does NOT Do

| NOT Responsibility | Why |
|--------------------|-----|
| **Decide execution** | Platform Core schedules and authorizes runs |
| **Call LLMs** | Platform Core manages LLM interactions |
| **Manage state** | Platform Core owns runtime state |
| **Handle I/O** | Platform Core manages external integrations |

---

## The Compilation Analogy

Think of Ainalyn SDK like a programming language compiler:

```
Python Builders -> SDK -> Agent Definition (YAML)
                        Platform Core executes
```

---

## Data Flow Overview

Developer -> SDK -> Platform Core

1) Build with builders
2) Validate (schema + gates + static)
3) Export YAML
4) Submit to Platform Core
5) Core executes and governs

---

## Why This Separation?

### Benefits of Compiler Pattern

1. **Offline Validation**
   - Catch errors before deployment
   - No network calls needed for validation
   - Fast feedback loop for developers

2. **Platform Independence**
   - SDK produces a standard format (YAML)
   - Platform can evolve independently
   - Multiple platforms could consume the same format

3. **Clear Responsibility**
   - SDK: definition correctness
   - Platform: execution correctness
   - No confusion about where bugs originate

4. **Testability**
   - Test definitions without running agents
   - Mock-free unit tests for SDK
   - Integration tests only at platform level

---

## What Gets Compiled

The SDK compiles your Python builder calls into an Agent Definition:

**Input (Python)**:
```python
from ainalyn import AgentBuilder, WorkflowBuilder, NodeBuilder

agent = (
    AgentBuilder("customer-support")
    .version("1.0.0")
    .description("Handles customer inquiries")
    .add_workflow(
        WorkflowBuilder("handle-inquiry")
        .add_node(
            NodeBuilder("classify")
            .description("Classify request")
            .uses_prompt("classify-prompt")
            .next_nodes("respond")
            .build()
        )
        .add_node(
            NodeBuilder("respond")
            .description("Respond to request")
            .uses_prompt("respond-prompt")
            .build()
        )
        .entry_node("classify")
        .build()
    )
    .build()
)
```

**Output (YAML)**:
```yaml
name: customer-support
version: 1.0.0
description: Handles customer inquiries
workflows:
  - name: handle-inquiry
    entry_node: classify
    nodes:
      - name: classify
        description: Classify request
        type: prompt
        reference: classify-prompt
        next_nodes:
          - respond
      - name: respond
        description: Respond to request
        type: prompt
        reference: respond-prompt
```

---

## Related Pages

- [Hexagonal Architecture](/v1/advanced/architecture-overview) - Internal SDK architecture
- [Compilation Flow](/v1/advanced/compilation-flow) - Detailed compilation process
